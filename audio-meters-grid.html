<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TSG Suite | VEROBAAMBI</title>
  <style>
    :root{
      --bg:#141618; --panel:#1b1f23; --ink:#e8eef9; --muted:#a9b2c7; --outline:#2a2f36; --grid:#29323b;
      --ok:#58d38c; --warn:#ffde58; --caution:#ff9a2d; --hot:#ff5a63; --cyan:#69bfff;
      --btn:#2d6bff; --btn-dark:#1e4edd; --btn-ghost:#0b1222;
      --meter-gap: 1.2em;
      /* **BEST PRACTICE 2025: Modern CSS Custom Properties for Performance** */
      /* Centralised values for consistent theming and easy maintenance */
      --drag-transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --canvas-border-radius: 10px;
      --vectorscope-min-size: 160px;
      --resize-debounce-delay: 16ms; /* ~60fps */
      --visibility-threshold: 0.1; /* 10% visibility for intersection observer */
    }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
    header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,rgba(20,22,24,.95),rgba(20,22,24,.6));backdrop-filter:saturate(140%) blur(8px);border-bottom:1px solid var(--outline)}
    h1{margin:0;padding:16px 20px;font-size:16px;letter-spacing:.3px}

    /* ===== TWO-COLUMN STEREO LAYOUT ===== */
    .stereoContainer {
      display: flex;
      gap: 10px;
      height: 100%;
      min-height: 0;
    }

    /* Left column: Goniometer + Phase Correlation (stacked) */
    .stereoLeftCol {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex-shrink: 0;
      min-height: 0;
    }

    /* Vectorscope - keeps aspect ratio, JS sets size */
    .gonioSquare {
      position: relative;
      flex-shrink: 0;
    }

    /* Phase correlation widget under goniometer - tar resterande höjd */
    .corrWidget {
      flex: 1;
      min-height: 0;
    }

    /* Right column: 2x2 grid + spectrum spanning full width */
    .stereoRightCol {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr 2fr;
      gap: 6px;
      flex: 1;
      min-height: 0;
      min-width: 180px;
    }

    /* Spectrum spans both columns and double height */
    .stereoRightCol .histogramWidget {
      grid-column: 1 / -1;
    }

    /* Individual widgets in right column */
    .phaseWidget {
      background: rgba(15, 18, 20, 0.6);
      border: 1px solid var(--outline);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
      overflow: hidden;
      padding: 6px 8px;
    }

    /* Widget label */
    .widgetLabel {
      font-size: 9px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.4px;
      margin-bottom: 4px;
      flex-shrink: 0;
    }

    /* Phase correlation, L/R balance, rotation and spectrum wraps */
    .phaseWidget .corrWrap,
    .phaseWidget .monoDevWrap,
    .phaseWidget .rotationWrap,
    .phaseWidget .spectrumWrap {
      flex: 1;
      min-height: 0;
      position: relative;
      width: 100%;
      margin: 0;
      padding: 0;
    }

    .phaseWidget .corrWrap .canvasPad,
    .phaseWidget .monoDevWrap .canvasPad,
    .phaseWidget .rotationWrap .canvasPad,
    .phaseWidget .spectrumWrap .canvasPad {
      width: 100%;
      height: 100%;
    }

    .phaseWidget .overlay {
      position: absolute;
      left: 50%;
      bottom: 4px;
      transform: translateX(-50%);
      font-size: 10px;
      padding: 2px 6px;
      background: rgba(0,0,0,.5);
      border-radius: 4px;
    }

    /* Canvas in widgets (direct children only, not inside .canvasPad) */
    .phaseWidget > canvas {
      display: block;
      width: 100%;
      height: 100%;
      flex: 1;
      min-height: clamp(2em, 8%, 4em);
      border-radius: 0.25em;
      background: #0a0c0e;
    }

    /* Rotation axis labels */
    .rotationAxis {
      display: flex;
      justify-content: space-between;
      font-size: 8px;
      color: var(--muted);
      opacity: 0.7;
      margin-top: 3px;
      padding: 0 2px;
    }
    .rotationAxis span:nth-child(2) {
      font-weight: 700;
    }

    /* L/R Balance axis - same style as rotationAxis */
    .balanceAxis {
      display: flex;
      justify-content: space-between;
      font-size: 8px;
      color: var(--muted);
      opacity: 0.7;
      margin-top: 3px;
      padding: 0 2px;
    }
    .balanceAxis span:nth-child(2) {
      font-family: ui-monospace, 'SF Mono', monospace;
      font-weight: 600;
      opacity: 1;
      color: var(--cyan);
    }

    /* M/S Meter */
    .msCompact {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex: 1;
      justify-content: center;
    }
    .msBar {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .msLabel {
      font-size: 10px;
      font-weight: 700;
      width: 14px;
      color: var(--muted);
    }
    .msTrack {
      flex: 1;
      height: 12px;
      background: #0a0c0e;
      border-radius: 4px;
      overflow: hidden;
    }
    .msFill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.05s linear;
    }
    .msFillM { background: linear-gradient(90deg, #3b82f6, #60a5fa); width: 0%; }
    .msFillS { background: linear-gradient(90deg, #22d3ee, #67e8f9); width: 0%; }
    .msValue {
      font-size: 10px;
      font-weight: 600;
      width: 52px;
      text-align: right;
      color: var(--ink);
      font-variant-numeric: tabular-nums;
    }

    /* Histogram widget */
    .histogramWidget {
      flex: 1.2;
    }
    .histogramAxis {
      display: flex;
      justify-content: space-between;
      font-size: 8px;
      color: var(--muted);
      opacity: 0.7;
      margin-top: 3px;
      padding: 0 2px;
    }

    /* Responsive: stack columns vertically on narrow screens */
    @media (max-width: 700px) {
      .stereoContainer {
        flex-direction: column;
      }
      .stereoLeftCol {
        flex-direction: row;
        gap: 8px;
      }
      .stereoRightCol {
        flex-direction: row;
        flex-wrap: wrap;
        min-width: 0;
      }
      .phaseWidget {
        flex: 1 1 45%;
        min-width: 120px;
      }
    }

    /* Goniometer canvas + overlay */
    .gonioSquare .canvasPad {
      width: 100%;
      height: 100%;
      position: relative;
    }

    .gonioSquare .overlay {
      position: absolute;
      left: 50%;
      bottom: 8px;
      transform: translateX(-50%);
      z-index: 2;
      pointer-events: none;
      background: rgba(0,0,0,.4);
      padding: 2px 8px;
      border-radius: 6px;
      font-size: 11px;
    }
    /* ===== NY LAYOUT: Loudness (höger kolumn) ===== */
    .loudnessModule {
      display: flex;
      flex-direction: column;
      gap: 12px;
      height: 100%;
      min-height: 0;
      align-items: center;
    }

    /* Radar wrapper - JS sätter storlek */
    .radarWrap {
      position: relative;
      flex-shrink: 0;
    }

    #loudnessRadar {
      width: 100%;
      height: 100%;
      background: #181c20;
      border-radius: 50%;
      border: 2px solid var(--outline);
      box-shadow: 0 4px 24px rgba(0,0,0,0.25);
      display: block;
    }

    .radar-lufs-value {
      display: none; /* Dold - LUFS visas i R128-panelen under radarn */
    }

    /* Peak LED - DOM-baserad (utanför canvas border-radius) */
    .peak-led {
      position: absolute;
      top: 2px;
      right: 2px;
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 3px 4px 3px 6px;
      border-radius: 8px;
      background: rgba(20, 24, 28, 0.7);
      pointer-events: none;
      z-index: 10;
    }
    .peak-led::after {
      content: '';
      width: 14px;
      height: 14px;
      border-radius: 3px;
      background: #3a1c1c;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.6);
      transition: all 0.1s;
      flex-shrink: 0;
    }
    .peak-led span {
      font-size: 9px;
      font-weight: 600;
      color: rgba(255,255,255,0.4);
      text-transform: uppercase;
      letter-spacing: 0.3px;
      line-height: 1;
      transition: color 0.1s;
    }
    .peak-led.on::after {
      background: #ff4e2d;
      box-shadow: 0 0 8px 3px rgba(255,78,45,0.7), inset 0 1px 2px rgba(255,255,255,0.3);
    }
    .peak-led.on span {
      color: #ff6655;
    }

    /* R128 värde-panel under radar */
    .r128-panel {
      flex: 1;
      min-height: 0;
      width: 100%;
      overflow-y: auto;
    }

    /* R128 värden - responsiva */
    .r128 .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .r128 .big {
      font-size: clamp(14px, 2.5vw, 20px);
      font-weight: 700;
      letter-spacing: .2px;
      white-space: nowrap;
    }
    .r128 small {
      color: #a9b2c7;
      font-size: clamp(10px, 1.5vw, 12px);
      white-space: nowrap;
    }

    .wrap{
      box-sizing:border-box;
      padding:20px;
      display:grid;
      gap:16px;
      grid-template-columns: var(--sidebar-width, 360px) 1fr;
      grid-template-rows: 1fr;
      height:calc(100dvh - 56px);
    }

    /*
     * Sidebar Collapse System
     * Synkroniserad animation för sidebar + grid
     */
    .sidebar-container {
      position: relative;
      overflow: hidden;
    }

    .sidebar-content {
      display: flex;
      flex-direction: column;
      gap: 16px;
      height: auto;
      min-height: 0;
    }

    /* Animerade transitions - läggs till efter page load */
    .sidebar-ready .wrap {
      transition: grid-template-columns 0.35s ease-out,
                  gap 0.35s ease-out,
                  padding-left 0.35s ease-out;
    }

    .sidebar-ready .sidebar-content {
      transition: transform 0.35s ease-out,
                  opacity 0.25s ease-out;
    }

    /* Collapsed state - ta bort sidebar helt */
    .wrap.sidebar-collapsed {
      grid-template-columns: 0px 1fr;
      gap: 0;
      padding-left: 20px; /* behåll samma marginal som höger */
    }

    .sidebar-collapsed .sidebar-content {
      transform: translateX(-100%);
      opacity: 0;
      pointer-events: none;
    }

    /* Initial collapsed state (ingen animation vid page load) */
    .sidebar-start-collapsed .wrap {
      grid-template-columns: 0px 1fr;
      gap: 0;
      padding-left: 20px;
    }

    .sidebar-start-collapsed .sidebar-content {
      transform: translateX(-100%);
      opacity: 0;
      pointer-events: none;
    }
    
    .collapse-toggle {
      position: fixed;
      left: calc(var(--sidebar-width, 360px) + 20px - 24px);
      top: 50%;
      transform: translateY(-50%);
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--panel), rgba(147, 197, 253, 0.1));
      border: 1px solid var(--outline);
      border-radius: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      box-shadow: 0 4px 16px rgba(0,0,0,.25);
      opacity: 0; /* Gömd som default */
    }

    /* Collapsed state - annan position */
    .sidebar-collapsed .collapse-toggle,
    .sidebar-start-collapsed .collapse-toggle {
      left: 24px;
    }

    /* Transition */
    .sidebar-ready .collapse-toggle {
      transition: left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                  opacity 0.2s ease;
    }
    /* Toggle visas/göms via JavaScript baserat på musrörelse */
    
    .collapse-toggle:hover {
      background: linear-gradient(135deg, rgba(147, 197, 253, 0.2), rgba(34, 211, 238, 0.1));
      box-shadow: 0 6px 24px rgba(0,0,0,.35), 0 0 16px rgba(147, 197, 253, 0.3);
      transform: translateY(-50%) scale(1.05);
      border-color: rgba(147, 197, 253, 0.5);
    }
    
    .collapse-toggle svg {
      width: 20px;
      height: 20px;
      fill: var(--ink);
    }

    .sidebar-ready .collapse-toggle svg {
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .sidebar-collapsed .collapse-toggle svg,
    .sidebar-start-collapsed .collapse-toggle svg {
      transform: rotate(180deg);
    }

    .collapse-toggle:hover svg {
      fill: rgba(147, 197, 253, 0.9);
    }
    .card{background:var(--panel);border:1px solid var(--outline);border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.25);padding:14px;min-height:0}
    /* Sidebar cards: no internal scroll, sidebar scrolls instead */
    .sidebar-content .card{overflow:visible;flex-shrink:0}
    .sidebar-content{overflow-y:auto;overflow-x:hidden;height:100%}
    .card h2{margin:0 0 10px;font-size:13px;color:var(--muted);letter-spacing:.35px;font-weight:700;text-transform:uppercase}

    /* Collapsible Panel System */
    .card.collapsible {
      transition: padding 0.2s ease;
    }
    .card.collapsible.collapsed {
      padding-bottom: 14px;
    }
    .card.collapsible h2 {
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      transition: margin 0.2s ease;
    }
    .card.collapsible.collapsed h2 {
      margin-bottom: 0;
    }
    .card.collapsible h2::before {
      content: '';
      display: inline-block;
      width: 0;
      height: 0;
      border-left: 5px solid var(--muted);
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
      transition: transform 0.2s ease;
      flex-shrink: 0;
    }
    .card.collapsible:not(.collapsed) h2::before {
      transform: rotate(90deg);
    }
    .card.collapsible h2:hover {
      color: var(--ink);
    }
    .card.collapsible h2:hover::before {
      border-left-color: var(--ink);
    }
    /* Smooth collapse animation using CSS Grid */
    .card.collapsible .card-body-wrapper {
      display: grid;
      grid-template-rows: 1fr;
      transition: grid-template-rows 0.25s ease-out;
    }
    .card.collapsible.collapsed .card-body-wrapper {
      grid-template-rows: 0fr;
    }
    .card.collapsible .card-body {
      overflow: hidden;
      min-height: 0;
    }
    /* Collapsed summary text */
    .card.collapsible .collapse-summary {
      display: none;
      font-size: 11px;
      color: var(--cyan);
      margin-left: auto;
      font-weight: 500;
    }
    .card.collapsible.collapsed .collapse-summary {
      display: inline;
    }

    .visning{
      grid-column:2;
      grid-row:1;
      display:grid;
      grid-template-rows:auto 1fr;
      gap:12px;
      min-height:0;
    }

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{background:var(--btn);border:0;color:white;padding:9px 12px;border-radius:11px;font-weight:700;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    .btn-ghost{background:var(--btn-ghost);color:var(--ink);border:1px solid #2a3a5f}
    .btn-active{background:var(--btn-dark)}
    .btn-muted{background:var(--hot);color:white}

    label{font-size:12px;color:var(--muted)}
    code.small{font-size:12px;color:var(--muted)}

    /* Inline editable value fields */
    .inline-edit {
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      color: var(--ink);
      font-size: 12px;
      font-family: monospace;
      padding: 2px 4px;
      width: 44px;
      text-align: center;
      flex-shrink: 0;
      transition: border-color 0.15s ease, background 0.15s ease;
    }
    .inline-edit:hover {
      border-color: var(--outline);
      background: rgba(255,255,255,0.05);
    }
    .inline-edit:focus {
      border-color: var(--cyan);
      background: rgba(0,0,0,0.3);
      outline: none;
    }
    /* Fixed-width control buttons for consistent alignment */
    .btn-ctrl {
      width: 56px;
      flex-shrink: 0;
      padding: 6px 0;
      text-align: center;
    }

    /* Source panel smooth transitions */
    .source-panel {
      display: grid;
      grid-template-rows: 1fr;
      transition: grid-template-rows 0.25s ease-out, opacity 0.2s ease;
      overflow: hidden;
    }
    .source-panel.source-panel-hidden {
      grid-template-rows: 0fr;
      opacity: 0;
      pointer-events: none;
    }
    .source-panel-content {
      min-height: 0;
      overflow: hidden;
    }

    /* Visning */
    .meters{
      display:grid;
      grid-template-columns:3fr 1fr;
      grid-template-rows:1fr;
      height:100%;
      gap:12px;
      min-height:0;
      overflow:hidden;
    }
    .stack-left{
      display: grid;
      grid-template-rows: 2fr 1fr;  /* Vectorscope 2/3, aktiv mätare 1/3 */
      gap: 12px;
      min-height: 0;
      align-items: stretch;
      height: 100%;
    }

    /* Meter mode switch */
    .meter-switcher {
      background: #111416;
      border: 1px solid var(--outline);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }
    .meter-switcher > header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      border-bottom: 1px solid var(--outline);
      flex-shrink: 0;
    }
    .meter-tabs {
      display: flex;
      gap: 4px;
    }
    .meter-tab {
      background: var(--btn-ghost);
      color: var(--muted);
      border: 1px solid var(--outline);
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .meter-tab:hover {
      background: #1a2030;
      color: var(--ink);
    }
    .meter-tab.active {
      background: var(--btn);
      color: white;
      border-color: var(--btn);
    }
    .meter-panels {
      flex: 1;
      min-height: 0;
      position: relative;
    }
    .meter-panel {
      position: absolute;
      inset: 0;
      padding: 8px 12px;
      display: none;
    }
    .meter-panel.active {
      display: flex;
      flex-direction: column;
    }
    .meter-panel .hMeter {
      flex: 1;
      min-height: 0;
    }
    .stack-right{display:grid;grid-template-rows:1fr;gap:12px;min-height:0}
    .meter{
      background: #111416;
      border: 1px solid var(--outline);
      border-radius: 12px;
      padding: var(--meter-gap) 2vw;
      position: relative;
      min-height: 0;
      display: flex;
      flex-direction: column;
      flex: 1 1 0;
      height: 100%;
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }
    .meter header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--meter-gap);
    }
    .badge{font-size:11px;padding:3px 8px;border-radius:999px;border:1px solid var(--outline);background:#0f1214;color:#cfe1ff}
    .tiny{opacity:.85;font-size:12px}

    canvas{display:block;width:100%;height:160px;background:#0d0f11;border-radius:10px;border:1px solid var(--outline)}

    /* Canvas för goniometer och correlation */
    #xy, #corr, #monoDev {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }

/*
 * Tabular Numbers - Framtidssäker implementation
 *
 * font-variant-numeric: tabular-nums gör att ALLA siffror får samma bredd
 * oavsett vilken font som används (så länge fonten stöder OpenType tnum).
 *
 * Detta är den moderna standarden (CSS Fonts Module Level 4) och tillåter
 * fritt byte av typsnitt utan att siffror "hoppar".
 *
 * Fallback: font-feature-settings för äldre browsers.
 * Monospace-fallback endast om fonten saknar tnum-stöd.
 */
.tabular-nums,
.mono-num,
.big,
.hLabel b,
.overlay b,
#r128Time,
#corrVal,
#monoDevVal,
#lufsM,
#lufsS,
#lufsI,
#lra,
#r128TpMax {
  font-variant-numeric: tabular-nums;
  font-feature-settings: "tnum" 1; /* Fallback för äldre browsers */
}

/*
 * För element som KRÄVER absolut fixed-width (t.ex. timers, counters)
 * kan man lägga till monospace som extra säkerhet:
 */
.mono-num-strict {
  font-variant-numeric: tabular-nums;
  font-feature-settings: "tnum" 1;
  font-family: ui-monospace, 'SF Mono', 'Fira Code', monospace;
}

/* Mono Deviation meter - samma bredd som goniometer */
.monoDevWrap {
  width: var(--gonio-size, 280px);
  margin: 0 auto;
  padding: 4px 0;
}
.monoDevWrap .canvasPad {
  height: 32px;
  width: 100%;
}
.monoDevWrap canvas {
  border-radius: 6px !important;
}

/* Canvas-pad gemensamma regler */
.canvasPad {
  width: 100%;
  height: 100%;
  position: relative;
}
.canvasPad > canvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  border-radius: 10px;
  border: 1px solid var(--outline);
  background: #0d0f11;
  box-sizing: border-box;
}

    /* Horisontella stapel-metrar */
    .hMeter{position:relative;height:100%;min-height:80px;margin-bottom: var(--meter-gap);}
    .hMeter canvas{position:absolute;inset:0;width:100%;height:100%}
    .hScale{position:absolute;inset:0;pointer-events:none}
    /* TP meter: add left/right margin so bars don't touch frame */
    #tpCard .hMeter canvas{left:1%;right:1%;width:98%}
    #tpCard .hScale{left:1%;right:1%}
    .hLabel{position:absolute;bottom:4px;left:8px;font-size:11px;color:#cfe1ff;background:rgba(0,0,0,.25);padding:2px 6px;border-radius:8px;border:1px solid #2a2f36}

    .overlay{position:absolute;left:10px;bottom:8px;background:rgba(0,0,0,.25);padding:2px 6px;border-radius:8px;font-size:12px;color:#cfe1ff;border:1px solid #2a2f36;text-align:left}

    /* R128 – sifferpanel (huvudregler finns ovan) */
    .r128{display:flex;flex-direction:column;gap:6px;min-height:0;overflow:hidden}

    .kv{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:8px}
    .kv div{background:#0f1214;border:1px solid var(--outline);border-radius:9px;padding:6px 8px}
    .kv small{display:block;font-size:11px;color:#a9b2c7}
    .kv .wide{grid-column:span 2}

    /* Settings rows */
    .setting-row{display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid var(--outline)}
    .setting-row:last-child{border-bottom:none}
    .setting-row label{font-size:12px;color:var(--muted);flex-shrink:0}
    .setting-row select{background:#0f1214;border:1px solid var(--outline);border-radius:6px;color:var(--ink);padding:6px 10px;font-size:12px;cursor:pointer;min-width:140px}
    .setting-row select:hover{border-color:var(--cyan)}
    .setting-row select:focus{outline:none;border-color:var(--cyan);box-shadow:0 0 0 2px rgba(105,191,255,0.2)}

    input[type="number"]{width:78px;background:#0f1214;border:1px solid #2a2f36;border-radius:8px;color:var(--ink);padding:6px}
    .hdr{display:flex;align-items:center;justify-content:space-between;padding:6px 20px}
    .brand{flex:1 1 60%;min-width:480px}
    .brand svg{display:block;height:64px;width:100%}
    .status{color:var(--muted);font-weight:600;margin-left:8px;white-space:nowrap}
    .brand svg{display:block;height:60px;width:auto}
    .status{color:var(--muted);font-weight:600;margin-left:8px;white-space:nowrap}

    /* Divider/linje under rubrik */
    .meter .divider {
      border: none;
      border-top: 1px solid var(--outline);
      margin: 0 0 var(--meter-gap) 0;
      width: 100%;
      background: none;
    }
    .hMeter {
      position: relative;
      height: 160px;
      margin-bottom: var(--meter-gap);
    }

    /* Drag & Drop Responsive Panels */
    .meter {
      cursor: grab;
    }

    .meter.dragging {
      cursor: grabbing;
        transition: var(--drag-transition);
        position: relative;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      .meter:hover {
        box-shadow: 0 8px 32px rgba(0,0,0,.4), 0 0 20px rgba(147, 197, 253, 0.3);
        border-color: rgba(147, 197, 253, 0.5);
        background: linear-gradient(135deg, var(--panel), rgba(147, 197, 253, 0.03));
      }

      .meter:hover h2 {
        color: rgba(147, 197, 253, 0.9);
        text-shadow: 0 0 8px rgba(147, 197, 253, 0.3);
      }

      .meter.dragging {
        cursor: grabbing;
        transform: scale(0.95);
        box-shadow: 0 16px 48px rgba(0,0,0,.6), 0 0 32px rgba(147, 197, 253, 0.2);
        border: 2px solid rgba(147, 197, 253, 0.3);
        z-index: 1000;
        background: linear-gradient(135deg, var(--panel), rgba(147, 197, 253, 0.02));
      }

      .meter.dragging::before {
        content: '';
        position: absolute;
        inset: -2px;
        border-radius: 16px;
        background: linear-gradient(45deg, rgba(147, 197, 253, 0.3), rgba(34, 211, 238, 0.3));
        z-index: -1;
        filter: blur(8px);
      }

      .meter.drag-over {
        border: 2px dashed rgba(147, 197, 253, 0.6);
        background: rgba(147, 197, 253, 0.05);
        animation: pulse-glow 1s ease-in-out infinite alternate;
      }

      .meter.transitioning {
        transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }

      @keyframes pulse-glow {
        0% { box-shadow: 0 0 16px rgba(147, 197, 253, 0.3); }
        100% { box-shadow: 0 0 24px rgba(147, 197, 253, 0.5); }
      }
  </style>
  <!-- Sidebar state BEFORE render - förhindrar "flash" -->
  <script>
    (function() {
      if (localStorage.getItem('tsg-sidebar-collapsed') === 'true') {
        document.documentElement.classList.add('sidebar-start-collapsed');
      }
    })();
  </script>
</head>
<body>
<header>
  <div class="hdr">
    <div class="brand">
      <!-- Vector logotyp: VEROBAAMBI utan mellanrum, BAAMBI tätare -->
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 4000 200"
     width="100%" height="auto"
     preserveAspectRatio="xMidYMid meet"
     role="img"
     aria-label="TSG Suite | VEROBAAMBI | Broadcast Audio Alignment & Meter Bridge Interface">
  <defs>
    <linearGradient id="lock-cyan" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="#38BDF8"/>
      <stop offset="1" stop-color="#22D3EE"/>
    </linearGradient>
  </defs>

  <text x="2%" y="50%" dominant-baseline="middle"
        font-family="Inter, Segoe UI, system-ui, -apple-system, Roboto, sans-serif"
        font-size="100">

    <!-- TSG Suite i samma cyan som tagline -->
    <tspan fill="#93C5FD" font-weight="800" letter-spacing="0.75">TSG Suite</tspan>

    <!-- separator -->
    <tspan fill="#6B7280" font-weight="300" dx="1.2em">|</tspan>

    <!-- VERO = extra bold -->
    <tspan fill="#E5E7EB" font-weight="950" letter-spacing="4" dx="1.2em">VERO</tspan>
    <!-- BAAMBI = väldigt tunn och tight -->
    <tspan fill="#E5E7EB" font-weight="200" letter-spacing="-3">BAAMBI</tspan>

    <!-- separator -->
    <tspan fill="#6B7280" font-weight="300" dx="1.2em">|</tspan>

    <!-- Tagline i samma cyan som TSG Suite -->
    <tspan fill="#93C5FD" font-weight="600" font-size="75" letter-spacing="2.5" dx="1.2em">
      Broadcast Audio Alignment &amp; Meter Bridge Interface
    </tspan>
  </text>
</svg>
    </div>
  </div>
</header>

<div id="wrap" class="wrap">
  <div class="sidebar-container">
    <div class="sidebar-content">
      <section class="card collapsible" id="panelInputSources" data-panel="inputSources">
        <h2>Input Sources <span class="collapse-summary" id="inputSourceSummary">–</span></h2>
        <div class="card-body-wrapper"><div class="card-body">
          <!-- Source Mode Selector (3 buttons) -->
          <div class="row" style="margin-bottom:8px;gap:4px">
            <button id="btnModeBrowser" class="btn-active" style="flex:1;line-height:1.2">Browser<br>Tab</button>
            <button id="btnModeExternal" class="btn-ghost" style="flex:1;line-height:1.2">External<br>Device</button>
            <button id="btnModeGenerator" class="btn-ghost" style="flex:1;line-height:1.2">Internal<br>Generator</button>
          </div>

          <!-- Unified Start/Stop Capture -->
          <div class="row" style="margin-bottom:10px">
            <button id="btnStartCapture" style="flex:1">Start Capture</button>
            <button id="btnStopCapture" class="btn-ghost" style="flex:1" disabled>Stop Capture</button>
          </div>

          <!-- Browser Source Panel -->
          <div id="browserSourcePanel" class="source-panel">
            <div class="source-panel-content">
            <p class="tiny">Captures via <code class="small">getDisplayMedia({audio:true})</code>. <b>Default:</b> monitoring OFF.</p>
            <div class="row" style="margin-top:6px;margin-bottom:8px;align-items:center;flex-wrap:nowrap">
              <label style="flex-shrink:0">Monitor (%):</label>
              <input type="range" id="sysMonGain" min="0" max="100" step="1" value="20" style="flex:1;min-width:60px" />
              <input type="text" id="sysMonVal" class="inline-edit" value="20" />
              <button id="btnSysMonMute" class="btn-muted btn-ctrl">Mute</button>
            </div>
            <div class="row" style="margin-bottom:8px;align-items:center;flex-wrap:nowrap">
              <label style="flex-shrink:0">Line-up (dB):</label>
              <input type="range" id="sysTrimRange" min="-48" max="24" step="0.1" value="-12" style="flex:1;min-width:60px" />
              <input type="text" id="sysTrimVal" class="inline-edit" value="-12" />
              <button id="sysTrimReset" class="btn-ghost btn-ctrl">Reset</button>
            </div>
            <div class="kv" id="info">
              <div><small>Source</small><span id="srcKind">–</span></div>
              <div><small>Channels</small><span id="cc">–</span></div>
              <div><small>Sample rate</small><span id="sr">–</span></div>
              <div><small>Stereo OK?</small><span id="stOK">–</span></div>
            </div>
            <p class="tiny">Tip: avoid feedback. Do <i>not</i> share this tab if you enable the monitor.</p>
            </div>
          </div>

          <!-- External Source Panel (hidden by default) -->
          <div id="externalSourcePanel" class="source-panel source-panel-hidden">
            <div class="source-panel-content">
            <div class="row" style="margin-bottom:8px;align-items:center;gap:8px">
              <label>Device:</label>
              <select id="extDeviceSelect" style="flex:1;padding:4px 8px;border-radius:6px;background:#0f1214;border:1px solid var(--outline);color:var(--ink);font-size:12px">
                <option value="">– Select audio input –</option>
              </select>
              <button id="btnExtRefresh" class="btn-ghost" title="Refresh device list">↻</button>
            </div>
            <p class="tiny">External audio via <code class="small">getUserMedia</code>. USB, Dante, etc.</p>
            <div class="row" style="margin-top:6px;margin-bottom:8px;align-items:center;flex-wrap:nowrap">
              <label style="flex-shrink:0">Monitor (%):</label>
              <input type="range" id="extMonGain" min="0" max="100" step="1" value="20" style="flex:1;min-width:60px" />
              <input type="text" id="extMonVal" class="inline-edit" value="20" />
              <button id="btnExtMonMute" class="btn-muted btn-ctrl">Mute</button>
            </div>
            <div class="row" style="margin-bottom:8px;align-items:center;flex-wrap:nowrap">
              <label style="flex-shrink:0">Line-up (dB):</label>
              <input type="range" id="extTrimRange" min="-48" max="24" step="0.1" value="0" style="flex:1;min-width:60px" />
              <input type="text" id="extTrimVal" class="inline-edit" value="0" />
              <button id="extTrimReset" class="btn-ghost btn-ctrl">Reset</button>
            </div>
            <div class="kv" id="extInfo">
              <div><small>Device</small><span id="extDevice">–</span></div>
              <div><small>Channels</small><span id="extCc">–</span></div>
              <div><small>Sample rate</small><span id="extSr">–</span></div>
              <div><small>Status</small><span id="extStatus">–</span></div>
            </div>
            <p class="tiny" id="extWarning" style="color:var(--caution);display:none">⚠ External input unavailable.</p>
            <p class="tiny">No AGC, no noise suppression, no echo cancellation.</p>
            </div>
          </div>

          <!-- Generator Source Panel (hidden by default) -->
          <div id="generatorSourcePanel" class="source-panel source-panel-hidden">
            <div class="source-panel-content">
            <div class="row" style="margin-bottom:8px;align-items:center;gap:8px;flex-wrap:wrap">
              <select id="genPreset" style="flex:1;padding:4px 8px;border-radius:6px;background:#0f1214;border:1px solid var(--outline);color:var(--ink);font-size:12px">
                <option value="400" selected>400 Hz · EBU broadcast line-up</option>
                <option value="1000">1 kHz · digital test tone (AES-style)</option>
                <option value="997">997 Hz · FFT-optimised test tone</option>
                <option value="440">440 Hz · musical A (non-broadcast)</option>
              </select>
            </div>
            <p class="tiny"><span class="badge" id="genBadge">400 Hz · −18 dBFS peak (0 dBu / 0 PPM)</span></p>
            <div class="row" style="margin-top:6px;margin-bottom:8px;align-items:center">
              <label><input type="checkbox" id="muteLeft"> EBU stereo-ID (L pulsed)</label>
              <span class="tiny" style="margin-left:8px;opacity:0.7">ITU-R BR.1385</span>
            </div>
            <div class="row" style="margin-top:6px;align-items:center;flex-wrap:nowrap">
              <label style="flex-shrink:0">Monitor (%):</label>
              <input type="range" id="monGain" min="0" max="100" step="1" value="20" style="flex:1;min-width:60px" />
              <input type="text" id="monVal" class="inline-edit" value="20" />
              <button id="btnMonMute" class="btn-ghost btn-ctrl">Mute</button>
            </div>
            </div>
          </div>
        </div></div>
      </section>

      <section class="card collapsible collapsed" id="panelMeteringSettings" data-panel="meteringSettings">
        <h2>Metering Settings <span class="collapse-summary">−23 LUFS / −1 dBTP</span></h2>
        <div class="card-body-wrapper"><div class="card-body">
          <!-- LUFS Target -->
          <div class="setting-row">
            <label for="targetPreset">Loudness Target</label>
            <select id="targetPreset">
              <option value="-23">−23 LUFS (EBU R128)</option>
              <option value="-24">−24 LUFS (ATSC A/85)</option>
              <option value="-16">−16 LUFS (Streaming)</option>
              <option value="-14">−14 LUFS (Podcast)</option>
            </select>
          </div>

          <!-- TP Limit -->
          <div class="setting-row">
            <label for="tpLimit">True Peak Limit</label>
            <select id="tpLimit">
              <option value="-1">−1 dBTP (Broadcast)</option>
              <option value="-2">−2 dBTP (Streaming)</option>
              <option value="-3">−3 dBTP (Safe)</option>
            </select>
          </div>

          <!-- Radar Sweep -->
          <div class="setting-row">
            <label for="radarSweep">Radar Sweep Time</label>
            <select id="radarSweep">
              <option value="30">30 seconds</option>
              <option value="60" selected>60 seconds</option>
              <option value="120">120 seconds</option>
            </select>
          </div>
        </div></div>
      </section>

      <section class="card collapsible collapsed" id="panelStatus" data-panel="status">
        <h2>Status & Live Data <span class="collapse-summary" id="statusSummary">–</span></h2>
        <div class="card-body-wrapper"><div class="card-body">
          <div class="kv">
            <div class="wide"><small>Uptime</small><span id="uptime" style="font-family:monospace">00:00:00.0</span></div>
            <div><small>AudioContext running</small><span id="ctxState">–</span></div>
            <div><small>Tab Capture running</small><span id="dbgTab">No</span></div>
            <div><small>External running</small><span id="dbgExt">No</span></div>
            <div><small>Generator running</small><span id="dbgGen">No</span></div>
            <div class="wide"><small>Monitor status</small><span id="monitorStatus" class="tiny">Tab: <b>OFF</b> · External: <b>OFF</b> · Generator: <b>ON</b></span></div>
          </div>
        </div></div>
      </section>
    </div>
  </div>

  <!-- Toggle utanför sidebar-container så position:fixed fungerar korrekt -->
  <div class="collapse-toggle" id="sidebarToggle">
    <svg viewBox="0 0 24 24">
      <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
    </svg>
  </div>

  <section class="card visning">
    <div class="meters" id="meters">
      <div class="stack-left">
        <!-- NY: Goniometer + Correlation (tidigare vectorscope) -->
        <div class="meter" id="xyCard">
          <header><label>Spatial Analysis</label><span class="badge">Goniometer + Phase Correlation</span></header>
          <div class="stereoContainer">
            <!-- Vänster kolumn: Goniometer + Phase Correlation -->
            <div class="stereoLeftCol">
              <div class="gonioSquare" id="xyWrap">
                <div class="canvasPad"><canvas id="xy"></canvas></div>
              </div>
              <div class="phaseWidget corrWidget">
                <div class="widgetLabel">Phase Correlation <span style="float:right">ρ = <b id="corrVal">+-.--</b></span></div>
                <div class="corrWrap">
                  <div class="canvasPad"><canvas id="corr"></canvas></div>
                </div>
              </div>
            </div>
            <!-- Höger kolumn: 2x2 grid + Spectrum (full width, double height) -->
            <div class="stereoRightCol">
              <!-- Row 1, Col 1: Balance Meter -->
              <div class="phaseWidget">
                <div class="widgetLabel">Balance</div>
                <div class="monoDevWrap">
                  <div class="canvasPad"><canvas id="monoDev"></canvas></div>
                </div>
                <div class="balanceAxis">
                  <span>L</span>
                  <span id="monoDevVal">--.- dB</span>
                  <span>R</span>
                </div>
              </div>
              <!-- Row 1, Col 2: Width Meter -->
              <div class="phaseWidget">
                <div class="widgetLabel">Width</div>
                <canvas id="widthMeter"></canvas>
                <div class="rotationAxis"><span>M</span><span></span><span>S</span></div>
              </div>
              <!-- Row 2, Col 1: Phase Axis Rotation Meter -->
              <div class="phaseWidget">
                <div class="widgetLabel">Phase Axis Rotation</div>
                <div class="rotationWrap">
                  <div class="canvasPad"><canvas id="rotationCanvas"></canvas></div>
                </div>
                <div class="rotationAxis"><span>L-Phase</span><span>Mono Axis</span><span>R-Phase</span></div>
              </div>
              <!-- Row 2, Col 2: M/S Meter -->
              <div class="phaseWidget">
                <div class="widgetLabel">M/S Meter</div>
                <div class="msCompact">
                  <div class="msBar">
                    <span class="msLabel">M</span>
                    <div class="msTrack"><div class="msFill msFillM" id="msFillM"></div></div>
                    <span class="msValue" id="msValueM">--.- dB</span>
                  </div>
                  <div class="msBar">
                    <span class="msLabel">S</span>
                    <div class="msTrack"><div class="msFill msFillS" id="msFillS"></div></div>
                    <span class="msValue" id="msValueS">--.- dB</span>
                  </div>
                </div>
              </div>
              <!-- Row 3-4: Spectrum Analyser (full width, double height) -->
              <div class="phaseWidget histogramWidget">
                <div class="widgetLabel">Spectrum</div>
                <div class="spectrumWrap">
                  <div class="canvasPad"><canvas id="spectrumAnalyzer"></canvas></div>
                </div>
                <div class="histogramAxis">
                  <span>Lo</span><span></span><span>Hi</span>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- Meter switcher: TP / RMS / PPM -->
        <div class="meter-switcher" id="meterSwitcher">
          <header>
            <div class="meter-tabs">
              <button class="meter-tab active" data-meter="tp">TP</button>
              <button class="meter-tab" data-meter="rms">RMS</button>
              <button class="meter-tab" data-meter="ppm">PPM</button>
            </div>
            <span class="badge" id="meterBadge">True Peak Level (dBTP)</span>
          </header>
          <div class="meter-panels">
            <div class="meter-panel active" id="tpCard" data-meter="tp">
              <span class="hLabel" id="tpLabel">L: <b id="tpL">--.-</b> · R: <b id="tpR">--.-</b> dBTP</span>
              <div class="hMeter">
                <canvas id="tp" height="160"></canvas>
                <div class="hScale" id="tpScale"></div>
              </div>
            </div>
            <div class="meter-panel" id="dbfsCard" data-meter="rms">
              <span class="hLabel" id="dbfsLabel">L: <b id="dbL">--.-</b> · R: <b id="dbR">--.-</b> dBFS</span>
              <div class="hMeter">
                <canvas id="dbfs" height="160"></canvas>
                <div class="hScale" id="dbfsScale"></div>
              </div>
            </div>
            <div class="meter-panel" id="ppmCard" data-meter="ppm">
              <span class="hLabel" id="ppmLabel">L: <b id="ppmLVal">--.-</b> · R: <b id="ppmRVal">--.-</b> PPM</span>
              <div class="hMeter">
                <canvas id="ppmCanvas" height="160"></canvas>
                <div class="hScale" id="ppmScale"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="stack-right">
        <!-- NY: Loudness (radar överst, siffror under) -->
        <div class="meter" id="loudnessCard">
          <header><label>Loudness</label><span class="badge">Radar + EBU R128</span></header>
          <div class="loudnessModule">
            <div class="radarWrap">
              <canvas id="loudnessRadar"></canvas>
              <div class="radar-lufs-value" id="radarLufsValue">—</div>
              <div class="peak-led" id="peakLed"><span>Peak</span></div>
            </div>
            <div class="r128-panel">
              <div class="r128">
                <div class="row"><small>M</small><span class="big" id="lufsM">--.- LUFS</span></div>
                <div class="row"><small>S</small><span class="big" id="lufsS">--.- LUFS</span></div>
                <div class="row"><small>I</small><span class="big" id="lufsI">--.- LUFS</span></div>
                <div class="row"><small>LRA</small><span class="big" id="lra">--.- LU</span></div>
                <div class="row"><small>TP</small><span class="big" id="r128TpMax">--.- dBTP</span></div>
                <div class="row"><small>Crest</small><span class="big" id="r128Crest">--.- dB</span></div>
                <div class="row"><small title="Time since start or reset">Elapsed</small><span class="big" id="r128Time">--:--:--</span></div>
                <div class="row" style="margin-top:4px"><button class="btn-ghost" id="r128Reset" style="width:100%;padding:6px 0;font-size:11px">Reset</button></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
</div>

<script>
(async function(){

  // =====================================================
  // CONFIGURABLE METERING SETTINGS
  // =====================================================
  let LOUDNESS_TARGET = -23;  // EBU R128 default, changeable via UI
  let TP_LIMIT = -1;          // True Peak limit in dBTP
  let radarMaxSeconds = 60;   // Radar sweep time

  // True Peak scale constants (fixed range -60 to +3 dBTP)
  const TP_SCALE_MIN = -60;
  const TP_SCALE_MAX = 3;
  const TP_SCALE_SPAN = TP_SCALE_MAX - TP_SCALE_MIN;  // 63 dB

  // =====================================================
  // LOUDNESS RADAR MODULE (Clarity-style)
  // =====================================================
  const LoudnessRadar = (function() {
    'use strict';

    // LOUDNESS_TARGET is a configurable global variable
    // Radar scale: -36 to +9 LU relative to target (EBU R128 full momentary range)

    // ----- MOMENTARY RING SCALE (EBU R128 compliant) -----
    // EBU R128 momentary range: -36 LU to +9 LU relative to target
    const MOMENTARY_LU_MIN = -36;  // Lägsta LU (relativt target) - EBU R128 full range
    const MOMENTARY_LU_MAX = 9;    // Högsta LU (+9 mode)
    const MOMENTARY_LU_RANGE = MOMENTARY_LU_MAX - MOMENTARY_LU_MIN; // 45 LU
    const LOW_LEVEL_BELOW = -12;   // EBU R128: under -12 LU = "low level" (blå)

    // Gemensam normaliseringsfunktion för LU → 0..1
    function luToNormalized(lu, minLu, maxLu) {
      return Math.max(0, Math.min(1, (lu - minLu) / (maxLu - minLu)));
    }

    // TC/RTW färglogik för momentary ring
    function colorForLu(lu) {
      if (lu >= 3) return '#ff4444';       // Röd: +3 till +9 (för högt)
      if (lu >= 0) return '#ffd700';       // Gul: 0 till +3 (över target)
      if (lu >= LOW_LEVEL_BELOW) return '#44bb66';  // Grön: normal nivå
      return '#4488cc';                     // Blå: under low level
    }

    // Radar radius: LUFS → LU relativt LOUDNESS_TARGET, EBU R128 scale (-36 till +9 LU)
    function lufsToRadius(lufs, rOuter, rInner) {
      const lu = lufs - LOUDNESS_TARGET;
      const clampedLu = Math.max(MOMENTARY_LU_MIN, Math.min(MOMENTARY_LU_MAX, lu));
      const t = (clampedLu - MOMENTARY_LU_MIN) / MOMENTARY_LU_RANGE; // 0..1
      return rInner + t * (rOuter - rInner);
    }

    // Radar färgzoner: LUFS → LU relativt LOUDNESS_TARGET (EBU R128 compliant)
    // EBU R128 defines < -12 LU as "low level"
    function radarColorForLufs(lufs) {
      const lu = lufs - LOUDNESS_TARGET;
      if (lu >= 3) return '#ff4335';    // röd – för högt (+3 och över)
      if (lu >= 0) return '#ff9a2d';    // orange – över target (0 till +3)
      if (lu >= -6) return '#ffd94a';   // gul – nära target (-6 till 0)
      if (lu >= -12) return '#88d65c';  // ljusgrön – normal (-12 till -6)
      return '#4488cc';                 // blå – low level (under -12 LU per EBU R128)
    }

    function drawRadarBackground(ctx, cx, cy, rOuter, rInner) {
      ctx.save();
      const gradient = ctx.createRadialGradient(cx, cy, rInner, cx, cy, rOuter);
      gradient.addColorStop(0, '#0a0c0e');
      gradient.addColorStop(1, '#181c20');
      ctx.beginPath();
      ctx.arc(cx, cy, rOuter, 0, 2 * Math.PI);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.strokeStyle = '#2a2f36';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, cy, rInner, 0, 2 * Math.PI);
      ctx.fillStyle = '#0d0f11';
      ctx.fill();
      ctx.strokeStyle = '#1a1e22';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }

    // Grå stödlinjer - ringar OCH spokes (ritas OVANPÅ segment)
    function drawGridOverlay(ctx, cx, cy, rOuter, rInner) {
      ctx.save();
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.55;

      // Ringar var 6 LU (utom target som ritas separat)
      const GRID_STEP_LU = 6;
      for (let lu = MOMENTARY_LU_MIN; lu <= MOMENTARY_LU_MAX; lu += GRID_STEP_LU) {
        if (lu === 0) continue;
        const lufs = lu + LOUDNESS_TARGET;
        const r = lufsToRadius(lufs, rOuter, rInner);
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.strokeStyle = '#8b95a5';
        ctx.setLineDash([3, 5]);
        ctx.lineWidth = 1.2;
        ctx.stroke();
      }

      // Spokes var 30° (12 "klockslag")
      ctx.setLineDash([]);
      ctx.strokeStyle = '#6b7580';
      ctx.lineWidth = 1.0;
      for (let deg = 0; deg < 360; deg += 30) {
        const a = (deg - 90) * Math.PI / 180;
        ctx.beginPath();
        ctx.moveTo(cx + rInner * Math.cos(a), cy + rInner * Math.sin(a));
        ctx.lineTo(cx + rOuter * Math.cos(a), cy + rOuter * Math.sin(a));
        ctx.stroke();
      }

      ctx.restore();
    }

    // Target-ring ritas separat EFTER segmenten så den syns ovanpå
    function drawTargetRing(ctx, cx, cy, rOuter, rInner) {
      ctx.save();
      const lufs = 0 + LOUDNESS_TARGET;  // LU=0 → LUFS
      const r = lufsToRadius(lufs, rOuter, rInner);

      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.strokeStyle = '#40a0ff';
      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 2.5;
      ctx.shadowColor = '#40a0ff';
      ctx.shadowBlur = 3;
      ctx.stroke();
      ctx.restore();
    }

    function drawRadarSegments(ctx, cx, cy, rOuter, rInner, history, maxAge) {
      ctx.save();
      const now = Date.now();
      const segmentCount = history.length;
      const anglePerSegment = (2 * Math.PI) / Math.max(segmentCount, 60);
      const FADE_START = 0.85;  // Börja tona vid 85% av ålder

      history.forEach((point, index) => {
        const age = now - point.t;
        if (age < 0 || age > maxAge) return;
        const normalizedAge = age / maxAge;
        const startAngle = (2 * Math.PI * normalizedAge) - Math.PI / 2;
        const endAngle = startAngle + anglePerSegment;
        const lufs = point.v;
        const r = lufsToRadius(lufs, rOuter, rInner);
        const color = radarColorForLufs(lufs);

        // Fade ut sista 15% av livstiden
        let fadeMultiplier = 1.0;
        if (normalizedAge > FADE_START) {
          fadeMultiplier = 1.0 - (normalizedAge - FADE_START) / (1.0 - FADE_START);
        }
        const opacity = 0.85 * (1 - normalizedAge * 0.2) * Math.max(0, fadeMultiplier);

        // DONUT: Rita arc från rInner till r
        ctx.beginPath();
        ctx.arc(cx, cy, rInner, startAngle, endAngle);
        ctx.arc(cx, cy, r, endAngle, startAngle, true);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.globalAlpha = opacity;

        // Färska segment (första 10%) får subtil glow
        if (normalizedAge < 0.10) {
          ctx.shadowColor = color;
          ctx.shadowBlur = 4 * (1 - normalizedAge / 0.10);
        } else {
          ctx.shadowBlur = 0;
        }

        ctx.fill();
        ctx.shadowBlur = 0;  // Reset efter fill

        // Mjukare kant som tonar med segmentet
        ctx.strokeStyle = `rgba(0, 0, 0, ${opacity * 0.3})`;
        ctx.lineWidth = 0.75;
        ctx.stroke();
      });
      if (history.length > 0) {
        const sweepAngle = -Math.PI / 2;
        ctx.globalAlpha = 0.9;
        ctx.strokeStyle = '#69bfff';
        ctx.lineWidth = 2;
        ctx.shadowColor = '#69bfff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        // Sweep line från rInner till rOuter
        ctx.moveTo(cx + rInner * Math.cos(sweepAngle), cy + rInner * Math.sin(sweepAngle));
        ctx.lineTo(cx + rOuter * Math.cos(sweepAngle), cy + rOuter * Math.sin(sweepAngle));
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
      ctx.restore();
    }

    // Radiella LU-labels längs kl 3-spaken (matchar grid-ringarna)
    // LU-värden: -18, -12, -6, 0, +6 (var 6:e LU)
    const RADAR_SCALE_LU = [-18, -12, -6, 0, 6];

    function drawRadarLabels(ctx, cx, cy, rOuter, rInner, canvasWidth) {
      ctx.save();
      const fontSize = Math.max(8, Math.floor(canvasWidth * 0.020));
      ctx.font = `600 ${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, sans-serif`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';

      const labelAngle = 0;  // kl 3-spaken

      RADAR_SCALE_LU.forEach(lu => {
        const lufs = lu + LOUDNESS_TARGET;
        const r = lufsToRadius(lufs, rOuter, rInner);
        const x = cx + r * Math.cos(labelAngle) + 3;
        const y = cy + r * Math.sin(labelAngle);

        // Highlight target (LU=0)
        if (lu === 0) {
          ctx.fillStyle = '#40a0ff';
          ctx.font = `700 ${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, sans-serif`;
        } else {
          ctx.fillStyle = '#9ca3af';  // Ljusare grå
          ctx.font = `600 ${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, sans-serif`;
        }
        // Visa LU-värde (med + för positiva)
        const label = lu > 0 ? `+${lu}` : lu.toString();
        ctx.fillText(label, x, y);
      });

      ctx.restore();
    }

    // TC/RTW-style outer ring med momentary bargraph
    // Geometri: 270° båge, -18 till +9 LU = 27 LU, 10° per LU
    // Ticks var 2°, major tick var 10° (1 per LU)
    function drawOuterMomentaryRing(ctx, cx, cy, rOuter, canvasWidth, momentaryLufs) {
      ctx.save();

      // Geometri för ringen
      const ringOuterRadius = rOuter * 1.16;
      const ringThickness = rOuter * 0.07;
      const ringInnerRadius = ringOuterRadius - ringThickness;
      const fontSize = Math.max(8, Math.floor(canvasWidth * 0.022));

      // 270° båge: -180° till +90° (kl 6 till kl 3)
      // -18 LU vid -180° (kl 6, botten), +9 LU vid +90° (kl 3, höger)
      const START_ANGLE_DEG = -180;  // -18 LU (kl 6, botten)
      const END_ANGLE_DEG = 90;      // +9 LU (kl 3, höger)
      const TOTAL_ARC_DEG = END_ANGLE_DEG - START_ANGLE_DEG;  // 270°

      // 27 LU = 270° → 10° per LU
      const DEG_PER_LU = TOTAL_ARC_DEG / MOMENTARY_LU_RANGE;  // 10°

      // Tick var 2° → 135 ticks totalt
      const TICK_STEP_DEG = 2;
      const NUM_TICKS = Math.floor(TOTAL_ARC_DEG / TICK_STEP_DEG) + 1;

      // Beräkna momentary LU relativt target
      const momentaryLu = (typeof momentaryLufs === 'number' && isFinite(momentaryLufs))
        ? momentaryLufs - LOUDNESS_TARGET
        : MOMENTARY_LU_MIN - 1;

      // Normalisera momentary → vinkel
      const normalized = luToNormalized(momentaryLu, MOMENTARY_LU_MIN, MOMENTARY_LU_MAX);
      const litAngleDeg = START_ANGLE_DEG + normalized * TOTAL_ARC_DEG;

      // Rita alla ticks (tända och släckta)
      ctx.lineCap = 'round';
      const tickOuterR = ringOuterRadius;
      const minorTickLen = rOuter * 0.055;
      const majorTickLen = rOuter * 0.085;

      for (let i = 0; i < NUM_TICKS; i++) {
        const angleDeg = START_ANGLE_DEG + i * TICK_STEP_DEG;
        const angleRad = (angleDeg - 90) * Math.PI / 180;  // -90° offset för kl 12

        // Major tick var 10° (1 per LU)
        const isMajor = (Math.round(angleDeg - START_ANGLE_DEG) % 10 === 0);
        const tickLen = isMajor ? majorTickLen : minorTickLen;
        const tickInnerR = tickOuterR - tickLen;

        // LU vid denna vinkel
        const t = (angleDeg - START_ANGLE_DEG) / TOTAL_ARC_DEG;
        const luAtTick = MOMENTARY_LU_MIN + t * MOMENTARY_LU_RANGE;

        // Tänd om vi är under momentary-nivån
        const isLit = angleDeg <= litAngleDeg;

        // Färg: tänd = zonbaserad, släckt = synlig grå
        const color = isLit ? colorForLu(luAtTick) : '#3a4048';
        const alpha = isLit ? 0.95 : 0.55;
        // Tjocklek: lit minor 2.5, major 4; unlit minor 2, major 3.5
        const lineWidth = isLit
          ? (isMajor ? 4 : 2.5)
          : (isMajor ? 3.5 : 2);

        ctx.beginPath();
        ctx.moveTo(cx + tickInnerR * Math.cos(angleRad), cy + tickInnerR * Math.sin(angleRad));
        ctx.lineTo(cx + tickOuterR * Math.cos(angleRad), cy + tickOuterR * Math.sin(angleRad));
        ctx.strokeStyle = color;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      }

      // Siffror runt ringen (var 3 LU)
      ctx.globalAlpha = 1;
      ctx.font = `600 ${fontSize}px system-ui, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const labelRadius = ringOuterRadius + fontSize * 1.1;
      const majorLabels = [-18, -15, -12, -9, -6, -3, 0, 3, 6, 9];

      majorLabels.forEach(lu => {
        if (lu < MOMENTARY_LU_MIN || lu > MOMENTARY_LU_MAX) return;

        const t = (lu - MOMENTARY_LU_MIN) / MOMENTARY_LU_RANGE;
        const angleDeg = START_ANGLE_DEG + t * TOTAL_ARC_DEG;
        const angleRad = (angleDeg - 90) * Math.PI / 180;
        const x = cx + labelRadius * Math.cos(angleRad);
        const y = cy + labelRadius * Math.sin(angleRad);

        // Färg baserat på zon (0 är grå som negativa)
        if (lu >= 3) {
          ctx.fillStyle = '#ff6666';
        } else if (lu > 0) {
          ctx.fillStyle = '#ffdd44';
        } else {
          ctx.fillStyle = '#8899aa';
        }

        const label = lu === 0 ? '0' : lu.toString();
        ctx.fillText(label, x, y);
      });

      ctx.restore();
    }

    function drawCenterLUFS(ctx, cx, cy, rInner, momentaryLufs) {
      ctx.save();
      const fontSize = Math.max(14, rInner * 0.35);
      ctx.font = `800 ${fontSize}px ui-sans-serif, Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if (typeof momentaryLufs === 'number' && isFinite(momentaryLufs)) {
        const color = radarColorForLufs(momentaryLufs);
        ctx.shadowColor = color;
        ctx.shadowBlur = 10;
        ctx.fillStyle = color;
        ctx.fillText(momentaryLufs.toFixed(1), cx, cy);
      } else {
        ctx.fillStyle = '#6b7280';
        ctx.fillText('—', cx, cy);
      }
      ctx.restore();
    }

    function drawEmptyRadar(ctx, w, h) {
      const cx = w / 2;
      const cy = h / 2;
      const rOuter = Math.min(w, h) * 0.38;
      const rInner = rOuter * 0.30;
      drawOuterMomentaryRing(ctx, cx, cy, rOuter, w, null);
      drawRadarBackground(ctx, cx, cy, rOuter, rInner);
      drawGridOverlay(ctx, cx, cy, rOuter, rInner);
      drawTargetRing(ctx, cx, cy, rOuter, rInner);
      drawRadarLabels(ctx, cx, cy, rOuter, rInner, w);
    }

    function render(canvas, ctx, history, momentaryLufs, maxSeconds, peakFlag) {
      const w = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
      const h = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, w, h);
      if (!history.length) {
        drawEmptyRadar(ctx, w, h);
        return;
      }
      const cx = w / 2;
      const cy = h / 2;
      const rOuter = Math.min(w, h) * 0.38;  // Större för att fylla canvasen bättre
      const rInner = rOuter * 0.30;  // DONUT: 30% hål i mitten
      const maxAge = maxSeconds * 1000;
      drawOuterMomentaryRing(ctx, cx, cy, rOuter, w, momentaryLufs);  // TC/RTW momentary bargraph
      drawRadarBackground(ctx, cx, cy, rOuter, rInner);
      drawRadarSegments(ctx, cx, cy, rOuter, rInner, history, maxAge);
      drawGridOverlay(ctx, cx, cy, rOuter, rInner);  // Grå ringar + spokes (ovanpå segment)
      drawTargetRing(ctx, cx, cy, rOuter, rInner);   // Target-ring (ovanpå grid)
      drawRadarLabels(ctx, cx, cy, rOuter, rInner, w); // Labels högst upp
      // Peak LED now DOM-based (see .peak-led CSS) - canvas version disabled due to border-radius clipping
      // drawPeakIndicator(ctx, cx, cy, rOuter, w, peakFlag);
    }

    // Peak indicator - LED at upper-right corner of bounding square around outer ring
    function drawPeakIndicator(ctx, cx, cy, rOuter, canvasWidth, peakFlag) {
      ctx.save();

      // Use same outer radius as momentary ring
      const ringOuterRadius = rOuter * 1.16;

      // Position: upper-right corner of imaginary bounding square
      // Square tangent to circle at 12, 3, 6, 9 o'clock → corner at (cx + r, cy - r)
      const peakX = cx + ringOuterRadius;
      const peakY = cy - ringOuterRadius;

      const diodeSize = rOuter * 0.06;

      // Draw LED (filled circle)
      ctx.beginPath();
      ctx.arc(peakX, peakY, diodeSize, 0, Math.PI * 2);

      if (peakFlag) {
        // ON: bright amber-red with glow
        ctx.fillStyle = '#ff4e2d';
        ctx.globalAlpha = 0.95;
        ctx.shadowColor = '#ff4e2d';
        ctx.shadowBlur = 10;
      } else {
        // OFF: dark red, low opacity (unlit faux-LED)
        ctx.fillStyle = '#5a1c1c';
        ctx.globalAlpha = 0.4;
        ctx.shadowBlur = 0;
      }
      ctx.fill();
      ctx.shadowBlur = 0;

      // Label "Peak" - right-aligned, positioned to the LEFT of the LED
      const fontSize = Math.max(8, Math.floor(canvasWidth * 0.020));
      ctx.font = `600 ${fontSize}px system-ui, sans-serif`;
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.globalAlpha = peakFlag ? 0.95 : 0.5;
      ctx.fillStyle = peakFlag ? '#ff6655' : '#8899aa';
      ctx.fillText('Peak', peakX - diodeSize - 4, peakY);

      ctx.restore();
    }

    return { render: render };
  })();
  
  function drawLoudnessRadar(momentaryLufs) {
    // Bind to peakIndicatorOn (current True Peak >= -1.0 dBTP with 500ms hold)
    LoudnessRadar.render(loudnessRadar, loudnessRadarCtx, radarHistory, momentaryLufs, radarMaxSeconds, peakIndicatorOn);

    // Update DOM overlay for accessibility and readability
    const radarLufsValue = document.getElementById('radarLufsValue');
    if (radarLufsValue) {
      radarLufsValue.textContent = isFinite(momentaryLufs) ? formatLufs(momentaryLufs) : '—';
    }
  }

  // ------- DOM -------

  const wrap = document.getElementById('wrap');
  const meters = document.getElementById('meters');
  // --- Loudness Radar ---
  const loudnessCard = document.getElementById('loudnessCard');
  const loudnessModule = loudnessCard.querySelector('.loudnessModule');
  const loudnessRadar = document.getElementById('loudnessRadar');
  const loudnessRadarCtx = loudnessRadar.getContext('2d');
  const radarWrap = loudnessCard.querySelector('.radarWrap');
  const peakLed = document.getElementById('peakLed');
  const r128Panel = loudnessCard.querySelector('.r128-panel');
  // --- Stereo Vectorscope ---
  const xyCard = document.getElementById('xyCard');
  const xyWrap = document.getElementById('xyWrap');
  const xy = document.getElementById('xy'), xyCtx = xy.getContext('2d');
  const corr = document.getElementById('corr'), corrCtx = corr.getContext('2d');
  const corrVal = document.getElementById('corrVal');

  // --- Stereo Analysis Strip (widgets) ---
  const spectrumAnalyzer = document.getElementById('spectrumAnalyzer');
  const spectrumCtx = spectrumAnalyzer ? spectrumAnalyzer.getContext('2d') : null;
  const msFillM = document.getElementById('msFillM');
  const msFillS = document.getElementById('msFillS');
  const msValueM = document.getElementById('msValueM');
  const msValueS = document.getElementById('msValueS');
  const widthMeter = document.getElementById('widthMeter');
  const widthMeterCtx = widthMeter ? widthMeter.getContext('2d') : null;
  const rotationCanvas = document.getElementById('rotationCanvas');
  const rotationCtx = rotationCanvas ? rotationCanvas.getContext('2d') : null;

  // =====================================================
  // STEREO ANALYSIS ENGINE
  // =====================================================
  // TransitionGuard - Blanking during EBU pulse transitions ONLY
  // Prevents visual artifacts from gain-change transients
  //
  // NOTE: Automatic edge detection was REMOVED because RMS jitter
  // caused false triggers → random blanking artifacts.
  // Now only triggers explicitly from EBU pulse logic.
  // =====================================================
  const TransitionGuard = (function() {
    'use strict';

    let blankUntil = 0;
    // Blanking: 60ms covers analyser buffer flush + 1 render frame
    const BLANK_DURATION_MS = 60;

    return {
      // Call when EBU pulse state changes
      trigger() {
        blankUntil = performance.now() + BLANK_DURATION_MS;
      },

      shouldRender() {
        return performance.now() >= blankUntil;
      },

      isBlanking() {
        return performance.now() < blankUntil;
      },

      reset() {
        blankUntil = 0;
      }
    };
  })();

  // Computes: Width, M/S Levels, Rotation
  // =====================================================
  const StereoAnalysisEngine = (function() {
    'use strict';

    // Configuration
    const SMOOTH_ALPHA = 0.15;     // Smoothing for M/S and width
    const PEAK_HOLD_SEC = 3;       // Peak hold for width meter
    const ROTATION_HISTORY_LEN = 25;   // Trail length for rotation (longer for drift)
    const ROTATION_SMOOTH_ALPHA = 0.04; // Much slower smoothing for trend, not transients
    const ROTATION_DEADZONE = 0.05;    // ±5% dead-zone around center

    // State
    let midLevel = -60, sideLevel = -60;
    let width = 0;                 // 0..1+ (S / (M + S))
    let widthPeak = 0;             // Peak hold value
    let widthPeakTime = 0;         // Timestamp for peak hold
    let rotation = 0;              // -1..+1 (stereo centroid angle)
    const rotationHistory = [];    // Trail: recent values

    // Analyze a block of L/R samples
    function analyze(bufL, bufR) {
      const n = Math.min(bufL.length, bufR.length);
      if (n === 0) return;

      let sumM2 = 0, sumS2 = 0;
      let sumLL = 0, sumRR = 0, sumLR = 0;

      for (let i = 0; i < n; i++) {
        const L = bufL[i], R = bufR[i];
        const M = (L + R) * 0.5;
        const S = (R - L) * 0.5;  // +S = more right, -S = more left
        sumM2 += M * M;
        sumS2 += S * S;
        // Covariance for rotation
        sumLL += L * L;
        sumRR += R * R;
        sumLR += L * R;
      }

      const rmsM = Math.sqrt(sumM2 / n);
      const rmsS = Math.sqrt(sumS2 / n);
      const eps = 1e-10;

      // Width: S / (M + S + ε) → 0..1+
      const newWidth = rmsS / (rmsM + rmsS + eps);
      width += SMOOTH_ALPHA * (newWidth - width);

      // Peak hold for width
      const now = performance.now() / 1000;
      if (width > widthPeak) {
        widthPeak = width;
        widthPeakTime = now;
      } else if (now - widthPeakTime > PEAK_HOLD_SEC) {
        widthPeak = width;
        widthPeakTime = now;
      }

      // M/S levels in dB
      const newMidDb = rmsM > eps ? 20 * Math.log10(rmsM) : -60;
      const newSideDb = rmsS > eps ? 20 * Math.log10(rmsS) : -60;
      midLevel += SMOOTH_ALPHA * (newMidDb - midLevel);
      sideLevel += SMOOTH_ALPHA * (newSideDb - sideLevel);

      // Rotation: covariance-based stereo centroid angle
      const angle = 0.5 * Math.atan2(2 * sumLR, sumLL - sumRR);
      let rawRotation = angle / (Math.PI / 4);  // Normalise to -1..+1

      // Clamp to -1..+1 for extreme L/R-dominant signals
      rawRotation = Math.max(-1, Math.min(1, rawRotation));

      // Dead-zone: clamp to 0 if within ±DEADZONE (ignore small fluctuations)
      if (Math.abs(rawRotation) < ROTATION_DEADZONE) {
        rawRotation = 0;
      }

      // Slow smoothing for trend, not transients
      rotation += ROTATION_SMOOTH_ALPHA * (rawRotation - rotation);

      // Trail history
      rotationHistory.push(rotation);
      if (rotationHistory.length > ROTATION_HISTORY_LEN) {
        rotationHistory.shift();
      }
    }

    function getWidth() { return width; }
    function getWidthPeak() { return widthPeak; }
    function getMidLevel() { return midLevel; }
    function getSideLevel() { return sideLevel; }
    function getRotation() { return rotation; }
    function getRotationHistory() { return rotationHistory; }

    return { analyze, getWidth, getWidthPeak, getMidLevel, getSideLevel, getRotation, getRotationHistory };
  })();

  const dbfs = document.getElementById('dbfs'), dbfsScale = document.getElementById('dbfsScale');
  const dbL = document.getElementById('dbL'), dbR = document.getElementById('dbR');
  const tp = document.getElementById('tp'), tpScale = document.getElementById('tpScale');
  const tpL = document.getElementById('tpL'), tpR = document.getElementById('tpR');

  // --- R128 Subpanel ---
  const lufsM = document.getElementById('lufsM');
  const lufsS = document.getElementById('lufsS');
  const lufsI = document.getElementById('lufsI');
  const lraEl = document.getElementById('lra');

  // --- Radar Data Buffer ---
  // Holds the last 60s of short-term loudness (or as much as fits)
  const radarHistory = [];
  // radarMaxSeconds is now a configurable global variable
  // Called from updateR128() - real-time per EBU Tech 3341 (no interpolation)
  function pushRadarLoudness(val) {
    const now = Date.now();

    // Push the actual new point (real-time, no gap-filling per EBU Tech 3341)
    radarHistory.push({ t: now, v: val });

    // Remove old entries outside radar time window
    while (radarHistory.length > 2 && (now - radarHistory[0].t) > radarMaxSeconds*1000) radarHistory.shift();
  }

  // Generator monitor controls
  const btnMonMute = document.getElementById('btnMonMute');
  const muteLeft = document.getElementById('muteLeft');
  const monGainEl = document.getElementById('monGain');
  const monVal = document.getElementById('monVal');

  // Browser source controls
  const btnSysMonMute = document.getElementById('btnSysMonMute');
  const sysMonGainEl = document.getElementById('sysMonGain');
  const sysMonVal = document.getElementById('sysMonVal');
  const sysTrimRange = document.getElementById('sysTrimRange');
  const sysTrimVal = document.getElementById('sysTrimVal');
  const sysTrimReset = document.getElementById('sysTrimReset');
  const info = { srcKind: document.getElementById('srcKind'), cc: document.getElementById('cc'), sr: document.getElementById('sr'), stOK: document.getElementById('stOK') };

  // Input Source mode controls
  const btnModeBrowser = document.getElementById('btnModeBrowser');
  const btnModeExternal = document.getElementById('btnModeExternal');
  const btnModeGenerator = document.getElementById('btnModeGenerator');
  const browserSourcePanel = document.getElementById('browserSourcePanel');
  const externalSourcePanel = document.getElementById('externalSourcePanel');
  const generatorSourcePanel = document.getElementById('generatorSourcePanel');
  const btnStartCapture = document.getElementById('btnStartCapture');
  const btnStopCapture = document.getElementById('btnStopCapture');
  const inputSourceSummary = document.getElementById('inputSourceSummary');

  // External source controls
  const extDeviceSelect = document.getElementById('extDeviceSelect');
  const btnExtRefresh = document.getElementById('btnExtRefresh');
  const extMonGainEl = document.getElementById('extMonGain');
  const extMonVal = document.getElementById('extMonVal');
  const btnExtMonMute = document.getElementById('btnExtMonMute');
  const extTrimRange = document.getElementById('extTrimRange');
  const extTrimVal = document.getElementById('extTrimVal');
  const extTrimReset = document.getElementById('extTrimReset');
  const extInfo = { device: document.getElementById('extDevice'), cc: document.getElementById('extCc'), sr: document.getElementById('extSr'), status: document.getElementById('extStatus') };
  const extWarning = document.getElementById('extWarning');

  const ppmCanvas = document.getElementById('ppmCanvas');
  const ppmScale = document.getElementById('ppmScale');
  const ppmLVal = document.getElementById('ppmLVal');
  const ppmRVal = document.getElementById('ppmRVal');
  const ctxState = document.getElementById('ctxState');
  const dbgGen   = document.getElementById('dbgGen');
  const dbgTab   = document.getElementById('dbgTab');
  const uptimeEl = document.getElementById('uptime');

  // ------- Helpers -------
  function getCss(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
  const dbToGain = dB => Math.pow(10, dB/20);
  const clamp = (v,min,max)=>Math.max(min,Math.min(max, v));

  // ------- dB Formatters (fixed-width, monospace-vänliga) -------
  // Alla formatterare ger konsekvent bredd så siffror inte "hoppar"

  // formatDb: Fixed-width dB (t.ex. "-23.4", " -3.4", "  0.0")
  // width = totalt antal tecken inklusive tecken och decimal
  function formatDb(value, decimals = 1, width = 5) {
    if (!isFinite(value) || value < -99) return '--.-'.padStart(width);
    const str = value.toFixed(decimals);
    return str.padStart(width);
  }

  // formatDbu: Med snap-to-zero för PPM, alltid med +/- tecken
  function formatDbu(value, decimals = 1, snapWindow = 0.25, width = 5) {
    if (!isFinite(value) || value < -99) return '--.-'.padStart(width);
    const snapped = (Math.abs(value) < snapWindow) ? 0 : value;
    const sign = snapped >= 0 ? '+' : '';
    return (sign + snapped.toFixed(decimals)).padStart(width);
  }

  // formatDbSigned: Alltid med +/− tecken, fixed-width
  function formatDbSigned(value, decimals = 1, width = 5) {
    if (!isFinite(value) || Math.abs(value) > 99) return '--.-'.padStart(width);
    const sign = value >= 0 ? '+' : '';
    return (sign + value.toFixed(decimals)).padStart(width);
  }

  // formatLufs: För LUFS-värden (t.ex. "-23.4 LUFS")
  function formatLufs(value, decimals = 1) {
    if (!isFinite(value) || value < -99) return '--.- LUFS';
    return value.toFixed(decimals).padStart(5) + ' LUFS';
  }

  // formatCorr: Korrelation (-1.00 till +1.00)
  function formatCorr(value) {
    if (!isFinite(value)) return '+-.--';
    const sign = value >= 0 ? '+' : '';
    return sign + value.toFixed(2);
  }

  // formatTime: Elapsed time (hh:mm:ss) - fixed width
  function formatTime(ms) {
    if (!isFinite(ms) || ms < 0) return '--:--:--';
    const totalSec = Math.floor(ms / 1000);
    const h = Math.floor(totalSec / 3600);
    const m = Math.floor((totalSec % 3600) / 60);
    const s = totalSec % 60;
    return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
  }

  // ------- Layout -------
  function sizeWrap(){ const headerH = document.querySelector('header').offsetHeight; wrap.style.height = `calc(100dvh - ${headerH}px)`; }
  sizeWrap(); window.addEventListener('resize', sizeWrap);

  function layoutXY(){
    // **DRAG-AWARE LAYOUT: Skip expensive calculations during drag operations**
    if (isDragLayoutFrozen) {
      console.debug('layoutXY: Skipped due to active drag operation');
      return;
    }

    const dpr = window.devicePixelRatio || 1;
    const stereoContainer = xyCard.querySelector('.stereoContainer');
    if (!stereoContainer) return;

    const gap = 10; // Gap mellan kolumner

    // Tillgängligt utrymme
    const availH = stereoContainer.clientHeight;
    const availW = stereoContainer.clientWidth;

    // Goniometer: kvadrat begränsad av 55% av bredd och 85% av höjd
    // Resten av höjden går till correlation-widgeten via flex
    const gonioSize = Math.min(availH * 0.85, availW * 0.55);

    // Sätt goniometer container och canvas
    const gonioSquare = xyCard.querySelector('.gonioSquare');
    if (gonioSquare) {
      gonioSquare.style.width = gonioSize + 'px';
      gonioSquare.style.height = gonioSize + 'px';

      const w = Math.floor(gonioSize * dpr);
      if (xy.width !== w || xy.height !== w) {
        xy.width = w;
        xy.height = w;
      }
    }

    // Vänster kolumn bredd = goniometer bredd
    const leftCol = xyCard.querySelector('.stereoLeftCol');
    if (leftCol) {
      leftCol.style.width = gonioSize + 'px';
    }

    // Phase correlation canvas (under goniometer) - flex tar hand om höjden
    const corrWrapEl = xyCard.querySelector('.corrWrap');
    if (corrWrapEl && corr) {
      const rect = corrWrapEl.getBoundingClientRect();
      const cw = Math.floor(rect.width * dpr);
      const ch = Math.floor(rect.height * dpr);
      if (corr.width !== cw || corr.height !== ch) {
        corr.width = Math.max(10, cw);
        corr.height = Math.max(10, ch);
      }
    }

    // Höger kolumn widgets - CSS flex hanterar layouten
    // Vi behöver bara sätta canvas-storlekar baserat på faktisk storlek

    // L/R Balance (monoDev) canvas - use monoDevCanvas (defined later in script)
    const monoDevWrapEl = xyCard.querySelector('.monoDevWrap');
    const monoDevEl = document.getElementById('monoDev');
    if (monoDevWrapEl && monoDevEl) {
      const rect = monoDevWrapEl.getBoundingClientRect();
      const mdw = Math.floor(rect.width * dpr);
      const mdh = Math.floor(rect.height * dpr);
      if (monoDevEl.width !== mdw || monoDevEl.height !== mdh) {
        monoDevEl.width = Math.max(10, mdw);
        monoDevEl.height = Math.max(10, mdh);
      }
    }

    // Width meter and Spectrum analyser canvas - sizing handled by their draw functions using getBoundingClientRect()
  }

  // Loudness Radar layout - beräkna och sätt storlekar
  function layoutLoudness() {
    if (isDragLayoutFrozen) return;
    if (!loudnessModule || !radarWrap || !loudnessRadar) return;

    const dpr = window.devicePixelRatio || 1;
    const gap = 12;
    const r128MinHeight = 180; // Minst plats för R128-värden

    // Tillgängligt utrymme
    const availH = loudnessModule.clientHeight;
    const availW = loudnessModule.clientWidth;

    // Radar: kvadrat som får plats, men lämnar utrymme för R128
    // Max höjd = tillgänglig höjd - r128 minsta höjd - gap
    const maxRadarH = availH - r128MinHeight - gap;
    // Radar ska vara en cirkel, så begränsa till minsta av bredd och beräknad maxhöjd
    const radarSize = Math.max(100, Math.min(maxRadarH, availW));

    // Sätt radar container och canvas
    radarWrap.style.width = radarSize + 'px';
    radarWrap.style.height = radarSize + 'px';

    const canvasSize = Math.floor(radarSize * dpr);
    if (loudnessRadar.width !== canvasSize || loudnessRadar.height !== canvasSize) {
      loudnessRadar.width = canvasSize;
      loudnessRadar.height = canvasSize;
    }
  }

  // ------- Audio graph -------
  const ac = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
  function updateCtxState() { if(ctxState) ctxState.textContent = ac.state === 'running' ? 'Yes' : 'No'; }
  updateCtxState(); ac.onstatechange = updateCtxState;

  // Analysbuss L/R
  const mixL = ac.createGain(); mixL.gain.value = 1; const mixR = ac.createGain(); mixR.gain.value = 1;

  // CRITICAL: smoothingTimeConstant = 0 for sample-accurate goniometer
  // Default 0.8 causes temporal smearing during transitions → oval artifacts
  const analyserL = ac.createAnalyser();
  analyserL.fftSize = 4096;  // 4096 for better low-frequency resolution in RTA
  analyserL.smoothingTimeConstant = 0; // No smoothing for XY plot

  const analyserR = ac.createAnalyser();
  analyserR.fftSize = 4096;  // Must match L exactly
  analyserR.smoothingTimeConstant = 0; // Must match L exactly

  // CRITICAL: Route mixL/mixR to analysers for XY goniometer, spectrum, and time-domain metering
  // All audio sources (tone generator, tab capture) must flow through mixL/mixR
  mixL.connect(analyserL);
  mixR.connect(analyserR);

  const bufL = new Float32Array(analyserL.fftSize); const bufR = new Float32Array(analyserR.fftSize);

  // K-weighting path (approx) för R128
  const kHP_L = ac.createBiquadFilter(); kHP_L.type='highpass'; kHP_L.frequency.value=38; kHP_L.Q.value=0.5;
  const kHS_L = ac.createBiquadFilter(); kHS_L.type='highshelf'; kHS_L.frequency.value=4000; kHS_L.gain.value=4; kHP_L.connect(kHS_L);
  const kHP_R = ac.createBiquadFilter(); kHP_R.type='highpass'; kHP_R.frequency.value=38; kHP_R.Q.value=0.5;
  const kHS_R = ac.createBiquadFilter(); kHS_R.type='highshelf'; kHS_R.frequency.value=4000; kHS_R.gain.value=4; kHP_R.connect(kHS_R);

  const kAnL = ac.createAnalyser(); kAnL.fftSize = 2048; const kBufL = new Float32Array(kAnL.fftSize);
  const kAnR = ac.createAnalyser(); kAnR.fftSize = 2048; const kBufR = new Float32Array(kAnR.fftSize);
  kHS_L.connect(kAnL); kHS_R.connect(kAnR);

  function connectStereoToMix(node){ const split = ac.createChannelSplitter(2); node.connect(split); split.connect(mixL,0); split.connect(mixR,1); split.connect(kHP_L,0); split.connect(kHP_R,1); return split; }

  // ------- Nordic PPM – IEC Type I, 0 PPM = 0 dBu (−18 dBFS peak) -------
  // Skala: -36 till +9 dBu (dBFS: -54 till -9), PML = +9 dBu = -9 dBFS
  // Ballistik: 5 ms attack (quasi-peak), linjär decay 20 dB / 1.7 s
  let ppmHoldL = -60, ppmHoldR = -60, lastTsPPM = performance.now();
  const PPM_ATTACK_MS = 5;          // 5 ms integration (IEC Type I)
  const PPM_DECAY_DB_PER_S = 20/1.7; // 20 dB på 1.7 s ≈ 11.76 dB/s (linjär)
  const PPM_MIN_DB = -54;           // -36 PPM = -54 dBFS
  const PPM_MAX_DB = -9;            // +9 PPM = -9 dBFS

  // Peak-hold för PPM (RTW broadcast standard: 3 sekunder)
  let ppmPeakHoldL = -60, ppmPeakHoldR = -60, ppmPeakTimeL = 0, ppmPeakTimeR = 0;
  const PPM_PEAK_HOLD_SEC = 3; // 3 sekunder peak-hold (RTW broadcast standard)

  function quasiPeakDb(buf, sampleRate){
    // Quasi-peak: hitta max amplitude med ~5ms integration
    // Vid 48kHz = 240 samples per 5ms fönster
    const windowSamples = Math.max(1, Math.round(sampleRate * PPM_ATTACK_MS / 1000));
    let maxPeak = 0;
    for(let i = 0; i < buf.length; i += windowSamples){
      let windowMax = 0;
      const end = Math.min(i + windowSamples, buf.length);
      for(let j = i; j < end; j++){
        const abs = Math.abs(buf[j]);
        if(abs > windowMax) windowMax = abs;
      }
      if(windowMax > maxPeak) maxPeak = windowMax;
    }
    return 20 * Math.log10(maxPeak + 1e-12);
  }

  function updatePPM(){
    const now = performance.now();
    const dt = Math.max(0.001, (now - lastTsPPM) / 1000);
    lastTsPPM = now;

    // Uses shared bufL/bufR already populated by sampleAnalysers()
    // NO redundant getFloatTimeDomainData here - prevents L/R desync

    // Quasi-peak mätning (dBFS)
    const peakDbL = quasiPeakDb(bufL, ac.sampleRate);
    const peakDbR = quasiPeakDb(bufR, ac.sampleRate);

    // Nordic PPM ballistik:
    // Attack: omedelbart till nytt peak (inom 5ms integration redan i quasiPeakDb)
    // Decay: linjär 20 dB / 1.7 s
    const decayDb = PPM_DECAY_DB_PER_S * dt;

    // L kanal
    if(peakDbL > ppmHoldL){
      ppmHoldL = peakDbL; // Snabb attack
    } else {
      ppmHoldL = Math.max(PPM_MIN_DB, ppmHoldL - decayDb); // Linjär decay
    }

    // R kanal
    if(peakDbR > ppmHoldR){
      ppmHoldR = peakDbR;
    } else {
      ppmHoldR = Math.max(PPM_MIN_DB, ppmHoldR - decayDb);
    }

    // Clamp till skalan
    const dispL = Math.max(PPM_MIN_DB, Math.min(PPM_MAX_DB, ppmHoldL));
    const dispR = Math.max(PPM_MIN_DB, Math.min(PPM_MAX_DB, ppmHoldR));

    // Peak-hold logik (10 sekunder)
    const nowSec = now / 1000;
    if (dispL > ppmPeakHoldL) { ppmPeakHoldL = dispL; ppmPeakTimeL = nowSec; }
    else if (nowSec - ppmPeakTimeL > PPM_PEAK_HOLD_SEC) { ppmPeakHoldL = dispL; ppmPeakTimeL = nowSec; }
    if (dispR > ppmPeakHoldR) { ppmPeakHoldR = dispR; ppmPeakTimeR = nowSec; }
    else if (nowSec - ppmPeakTimeR > PPM_PEAK_HOLD_SEC) { ppmPeakHoldR = dispR; ppmPeakTimeR = nowSec; }

    // Rita med peak-hold
    drawHBar_PPM(ppmCanvas, dispL, dispR, ppmPeakHoldL, ppmPeakHoldR);

    // Visa i PPM (= dBu), RTW-style: L: +2.0 PPM
    const ppmL = dispL + 18; // dBFS -> PPM/dBu
    const ppmR = dispR + 18;
    // Visa "--.-" om signalen är vid botten av skalan (ingen meningsfull signal)
    const ppmFloor = PPM_MIN_DB + 18; // -36 dBu
    const ppmLStr = (dispL <= PPM_MIN_DB + 1) ? '--.-' : formatDbu(ppmL);
    const ppmRStr = (dispR <= PPM_MIN_DB + 1) ? '--.-' : formatDbu(ppmR);
    document.getElementById('ppmLabel').innerHTML = `L: <b>${ppmLStr} PPM</b> · R: <b>${ppmRStr} PPM</b>`;
  }
  // Reset-funktion för PPM peak-hold
  window.resetPPMPeak = function(){ ppmPeakHoldL = -60; ppmPeakHoldR = -60; };

  // ------- XY + Correlation -------
  // Visual gain for vectorscope amplitude (RTW/DK standard: -18 dBFS mono ≈ 65-75% radius)
  const VECTORSCOPE_GAIN = 3.5;

  /**
   * drawXY - M/S Goniometer rendering (DK/RTW style)
   *
   * Coordinate system:
   *   - Vertical axis (Y) = Mid = (L+R)/2 = MONO content
   *   - Horizontal axis (X) = Side = (L-R)/2 = STEREO difference
   *   - Perfect mono signal = vertical line in center
   *   - Out-of-phase signal = horizontal line
   */
  function drawXY(){
    const w=xy.width,h=xy.height; if(!w||!h) return;
    const dpr = window.devicePixelRatio || 1;

    // Clear canvas
    xyCtx.fillStyle = '#0d0f11';
    xyCtx.fillRect(0,0,w,h);

    // Draw samples if TransitionGuard allows
    if (TransitionGuard.shouldRender()) {
      const n = Math.min(bufL.length, bufR.length);

      xyCtx.globalAlpha=0.85;
      xyCtx.globalCompositeOperation='lighter';
      xyCtx.fillStyle='rgba(105,191,255,.85)';
      const px = Math.max(1, Math.floor(dpr));

      // Line settings - thicker with round caps
      xyCtx.lineCap = 'round';
      xyCtx.lineJoin = 'round';

      let prevX=null, prevY=null;
      for(let i=0;i<n;i+=2){
        const L = bufL[i];
        const R = bufR[i];

        // M/S transform (DK/RTW standard)
        const M = 0.5 * (L + R);  // Mid = mono content
        const S = 0.5 * (R - L);  // Side: +S = right, -S = left

        // Map to canvas: X = Side (horizontal), Y = Mid (vertical, inverted)
        const x = (S * VECTORSCOPE_GAIN * w/2) + w/2;
        const y = h/2 - (M * VECTORSCOPE_GAIN * h/2);

        if(prevX!==null){
          // Glow layer first (wider, more transparent)
          xyCtx.globalAlpha=.15;
          xyCtx.strokeStyle='rgba(105,191,255,.5)';
          xyCtx.lineWidth = 3 * dpr;
          xyCtx.beginPath();
          xyCtx.moveTo(prevX,prevY);
          xyCtx.lineTo(x,y);
          xyCtx.stroke();

          // Main line (thicker than before)
          xyCtx.globalAlpha=.35;
          xyCtx.strokeStyle='rgba(105,191,255,.35)';
          xyCtx.lineWidth = 1.5 * dpr;
          xyCtx.beginPath();
          xyCtx.moveTo(prevX,prevY);
          xyCtx.lineTo(x,y);
          xyCtx.stroke();
        }
        xyCtx.globalAlpha=.85;
        xyCtx.fillRect(x,y,px,px);
        prevX=x; prevY=y;
      }
      xyCtx.globalCompositeOperation='source-over';
    }

    // Grid lines: M/S cross + L/R diagonals
    xyCtx.globalAlpha=1;
    xyCtx.strokeStyle = '#3a4855';
    xyCtx.lineWidth = 1;
    xyCtx.beginPath();
    // Vertical center line (MONO axis)
    xyCtx.moveTo(w/2,0); xyCtx.lineTo(w/2,h);
    // Horizontal center line (SIDE axis)
    xyCtx.moveTo(0,h/2); xyCtx.lineTo(w,h/2);
    // Diagonal lines (L and R directions)
    xyCtx.moveTo(0,0); xyCtx.lineTo(w,h);      // L direction (top-left to bottom-right)
    xyCtx.moveTo(w,0); xyCtx.lineTo(0,h);      // R direction (top-right to bottom-left)
    xyCtx.stroke();

    // Axis labels (DK/RTW style)
    const fontSize = Math.round(9 * dpr);
    xyCtx.font = `${fontSize}px ui-sans-serif, system-ui, sans-serif`;
    xyCtx.fillStyle = '#6b7a8a';
    xyCtx.textBaseline = 'middle';

    // Top row: +L / +M / +R
    const margin = 12 * dpr;
    xyCtx.textAlign = 'left';
    xyCtx.fillText('+L', margin, margin);
    xyCtx.textAlign = 'center';
    xyCtx.fillText('+M', w/2, margin);
    xyCtx.textAlign = 'right';
    xyCtx.fillText('+R', w - margin, margin);

    // Middle row: –S / +S
    xyCtx.textAlign = 'left';
    xyCtx.fillText('–S', margin, h/2);
    xyCtx.textAlign = 'right';
    xyCtx.fillText('+S', w - margin, h/2);

    // Bottom row: –L / –M / –R
    xyCtx.textAlign = 'left';
    xyCtx.fillText('–L', margin, h - margin);
    xyCtx.textAlign = 'center';
    xyCtx.fillText('–M', w/2, h - margin);
    xyCtx.textAlign = 'right';
    xyCtx.fillText('–R', w - margin, h - margin);
  }

  function corrNow(l,r){
    let n=Math.min(l.length,r.length), sL=0,sR=0; for(let i=0;i<n;i++){ sL+=l[i]; sR+=r[i] }
    const mL=sL/n, mR=sR/n; let num=0,dL=0,dR=0;
    for(let i=0;i<n;i++){ const L=l[i]-mL, R=r[i]-mR; num+=L*R; dL+=L*L; dR+=R*R }
    return num/(Math.sqrt(dL*dR)+1e-20);
  }
  let corrHold=0, corrUp=.25, corrDn=.06;
  /**
   * drawCorr - Phase Correlation meter
   * Uses shared bufL/bufR - NO redundant getFloatTimeDomainData
   * During blanking: holds previous value, continues rendering smoothly
   */
  function drawCorr(){
    // Update correlation only if TransitionGuard allows
    // Uses shared buffers already populated by sampleAnalysers()
    if (TransitionGuard.shouldRender()) {
      const cRaw = Math.max(-1, Math.min(1, corrNow(bufL,bufR)));
      corrHold = cRaw>corrHold ? corrHold + corrUp*(cRaw-corrHold) : corrHold + corrDn*(cRaw-corrHold);
    }
    // Always render the current held value (smooth during blanking)

    // Uppdatera canvas-storlek baserat på faktisk elementstorlek
    const dpr = window.devicePixelRatio || 1;
    const rect = corr.getBoundingClientRect();
    const w = Math.floor(rect.width * dpr);
    const h = Math.floor(rect.height * dpr);

    if (w < 10 || h < 10) return; // Skip if too small

    if (corr.width !== w || corr.height !== h) {
      corr.width = w;
      corr.height = h;
      corr.style.width = `${rect.width}px`;
      corr.style.height = `${rect.height}px`;
    }

    const ctx = corrCtx;
    ctx.clearRect(0,0,w,h);

    // Horizontal correlation bar layout
    const padding = 8 * dpr;
    const barH = Math.max(12 * dpr, h * 0.4);
    const barY = (h - barH) / 2;
    const barX = padding;
    const barW = w - padding * 2;

    // Background track
    ctx.fillStyle = '#0f1214';
    ctx.fillRect(barX, barY, barW, barH);
    ctx.strokeStyle = '#3a4855';
    ctx.strokeRect(barX, barY, barW, barH);

    // Center line (0 position)
    const centerX = barX + barW / 2;
    ctx.fillStyle = '#4b5563';
    ctx.fillRect(centerX - 1, barY - 4 * dpr, 2, barH + 8 * dpr);

    // RTW-style färgzoner för correlation
    const col = (corrHold < -0.3) ? getCss('--hot') : (corrHold >= 0.3 ? getCss('--ok') : getCss('--warn'));

    // Fill from center based on correlation value
    // -1 = full left, 0 = center, +1 = full right
    const fillX = centerX + (corrHold * barW / 2);
    ctx.fillStyle = col;
    ctx.globalAlpha = 0.85;
    if (corrHold >= 0) {
      ctx.fillRect(centerX, barY + 2, fillX - centerX, barH - 4);
    } else {
      ctx.fillRect(fillX, barY + 2, centerX - fillX, barH - 4);
    }
    ctx.globalAlpha = 1;

    // Scale labels
    ctx.font = `${Math.round(9 * dpr)}px ui-sans-serif`;
    ctx.fillStyle = '#88a3bf';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';

    // -1, 0, +1 labels
    const labelY = barY + barH + 10 * dpr;
    ctx.fillText('-1', barX + 10 * dpr, labelY);
    ctx.fillText('0', centerX, labelY);
    ctx.fillText('+1', barX + barW - 10 * dpr, labelY);

    corrVal.textContent = formatCorr(corrHold);
  }

  // ------- Mono Deviation (L/R Balance) -------
  const monoDevCanvas = document.getElementById('monoDev');
  const monoDevCtx = monoDevCanvas.getContext('2d');
  const monoDevVal = document.getElementById('monoDevVal');
  let monoDevHold = 0;

  function drawMonoDev() {
    analyserL.getFloatTimeDomainData(bufL);
    analyserR.getFloatTimeDomainData(bufR);

    // Beräkna RMS för L och R
    let sumL = 0, sumR = 0;
    for (let i = 0; i < bufL.length; i++) {
      sumL += bufL[i] * bufL[i];
      sumR += bufR[i] * bufR[i];
    }
    const rmsL = Math.sqrt(sumL / bufL.length);
    const rmsR = Math.sqrt(sumR / bufR.length);

    // L/R balance i dB (positiv = L högre, negativ = R högre)
    const balanceDb = 20 * Math.log10((rmsL + 1e-12) / (rmsR + 1e-12));
    const clampedBalance = Math.max(-12, Math.min(12, balanceDb));

    // Smooth
    const a = 0.15;
    monoDevHold = isFinite(clampedBalance) ? monoDevHold + a * (clampedBalance - monoDevHold) : 0;

    // Canvas setup med HiDPI
    const dpr = window.devicePixelRatio || 1;
    const rect = monoDevCanvas.getBoundingClientRect();
    const w = Math.floor(rect.width * dpr);
    const h = Math.floor(rect.height * dpr);

    if (monoDevCanvas.width !== w || monoDevCanvas.height !== h) {
      monoDevCanvas.width = w;
      monoDevCanvas.height = h;
    }

    const ctx = monoDevCtx;
    ctx.clearRect(0, 0, w, h);

    // Rita bakgrund
    const pad = Math.round(8 * dpr);
    const barY = Math.round(h * 0.35);
    const barH = Math.round(h * 0.3);
    const barX = pad;
    const barW = w - 2 * pad;

    ctx.fillStyle = '#0f1214';
    ctx.fillRect(barX, barY, barW, barH);
    ctx.strokeStyle = '#3a4855';
    ctx.strokeRect(barX, barY, barW, barH);

    // Mittstrecket (0 dB)
    const centerX = barX + barW / 2;
    ctx.fillStyle = '#5a6a7a';
    ctx.fillRect(centerX - 1, barY - 4 * dpr, 2, barH + 8 * dpr);

    // Tick marks vid ±3, ±6, ±12 dB
    const ticks = [-12, -6, -3, 3, 6, 12];
    ctx.fillStyle = '#3a4855';
    ctx.font = `${Math.round(8 * dpr)}px ui-monospace, monospace`;
    ctx.textBaseline = 'top';
    ctx.textAlign = 'center';
    for (const t of ticks) {
      const xPos = centerX + (t / 12) * (barW / 2);
      ctx.fillRect(xPos - 0.5, barY - 2 * dpr, 1, barH + 4 * dpr);
    }

    // Rita balance-bar
    const devX = centerX + (monoDevHold / 12) * (barW / 2);
    const devW = Math.abs(devX - centerX);

    // Färg baserat på deviation
    let col;
    const absDev = Math.abs(monoDevHold);
    if (absDev < 1.5) col = getCss('--ok');       // Grön: bra balans
    else if (absDev < 3) col = getCss('--cyan');  // Cyan: lätt deviation
    else if (absDev < 6) col = getCss('--warn');  // Amber: märkbar
    else col = getCss('--hot');                    // Röd: stark obalans

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = col;
    // Positiv balance (L > R) → bar åt VÄNSTER (mot L-etiketten)
    // Negativ balance (R > L) → bar åt HÖGER (mot R-etiketten)
    if (monoDevHold >= 0) {
      ctx.fillRect(centerX - devW, barY + 2, devW, barH - 4);
    } else {
      ctx.fillRect(centerX, barY + 2, devW, barH - 4);
    }
    ctx.globalAlpha = 1;

    // Uppdatera display med L/R istället för +/-
    const absVal = Math.abs(monoDevHold);
    let balanceStr;
    if (absVal < 0.05) {
      balanceStr = 'C 0.0 dB';  // Centrerad
    } else if (monoDevHold > 0) {
      balanceStr = 'L ' + absVal.toFixed(1) + ' dB';
    } else {
      balanceStr = 'R ' + absVal.toFixed(1) + ' dB';
    }
    monoDevVal.textContent = balanceStr;
  }

  // =====================================================
  // STEREO ANALYSIS WIDGETS - Draw Functions
  // =====================================================

  // 1) Spectrum Analyser - 31-band 1/3-octave RTA (ISO 266)
  const SPECTRUM_CENTER_FREQS = [
    20, 25, 31.5, 40, 50, 63, 80, 100,
    125, 160, 200, 250, 315, 400, 500, 630,
    800, 1000, 1250, 1600, 2000, 2500,
    3150, 4000, 5000, 6300, 8000, 10000,
    12500, 16000, 20000
  ];
  const SPECTRUM_NUM_BANDS = SPECTRUM_CENTER_FREQS.length; // 31
  const spectrumFreqBufL = new Float32Array(2048);
  const spectrumFreqBufR = new Float32Array(2048);
  const spectrumSmooth = new Float32Array(SPECTRUM_NUM_BANDS);
  const spectrumPeakHold = new Float32Array(SPECTRUM_NUM_BANDS);
  let spectrumLastTime = 0;

  // 1/3-octave factor: 2^(1/6) ≈ 1.1225
  const THIRD_OCT_FACTOR = Math.pow(2, 1/6);

  // RTW/TC Visual Display State (UI only - does not affect DSP)
  const spectrumDisplayVal = new Float32Array(SPECTRUM_NUM_BANDS);  // Smoothed display values
  const spectrumPeakMarker = new Float32Array(SPECTRUM_NUM_BANDS);  // Peak marker positions
  const spectrumPeakTimer = new Float32Array(SPECTRUM_NUM_BANDS);   // Peak hold timers
  // Initialize to floor
  for (let i = 0; i < SPECTRUM_NUM_BANDS; i++) {
    spectrumDisplayVal[i] = -100;
    spectrumPeakMarker[i] = -100;
    spectrumPeakTimer[i] = 0;
  }

  // RTW/TC Visual Constants (UI only)
  const RTW_VISIBLE_TOP_DB = 9;       // Top of visual range
  const RTW_VISIBLE_BOTTOM_DB = -48;  // Bottom of visual range
  const RTW_RANGE_DB = RTW_VISIBLE_TOP_DB - RTW_VISIBLE_BOTTOM_DB; // 57 dB
  const RTW_VISUAL_BOOST = 18;        // Boost to shift FFT values into visible range
  const RTW_FALL_RATE = 12;          // Bar fall: 12 dB/s
  const RTW_PEAK_HOLD_MS = 750;      // Peak hold: 600-900ms
  const RTW_PEAK_FALL_RATE = 18;     // Peak marker fall: 18 dB/s
  const RTW_DISPLAY_SMOOTH = 0.15;   // Visual smoothing factor (0.85/0.15 blend)

  function drawSpectrum() {
    if (!spectrumCtx || !analyserL || !analyserR) return;
    const canvas = spectrumAnalyzer;
    if (!canvas) return;

    // Use wrapper for dimensions (canvas itself may report 0 in flex)
    const spectrumWrap = xyCard.querySelector('.spectrumWrap');
    if (!spectrumWrap) return;

    const dpr = window.devicePixelRatio || 1;
    const rect = spectrumWrap.getBoundingClientRect();
    const cssW = rect.width;
    const cssH = rect.height;

    if (cssW < 1 || cssH < 1) return;

    const w = Math.floor(cssW * dpr);
    const h = Math.floor(cssH * dpr);

    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }

    const ctx = spectrumCtx;
    ctx.clearRect(0, 0, w, h);

    // Timing for peak falloff
    const now = performance.now();
    const deltaTime = spectrumLastTime > 0 ? (now - spectrumLastTime) / 1000 : 0.016;
    spectrumLastTime = now;

    // Get FFT data
    analyserL.getFloatFrequencyData(spectrumFreqBufL);
    analyserR.getFloatFrequencyData(spectrumFreqBufR);

    const sampleRate = ac.sampleRate || 48000;
    const fftSize = analyserL.fftSize;
    const binHz = sampleRate / fftSize;
    const numBins = spectrumFreqBufL.length;

    // Calculate band values using 1/3-octave boundaries
    for (let b = 0; b < SPECTRUM_NUM_BANDS; b++) {
      const centerFreq = SPECTRUM_CENTER_FREQS[b];
      const lowFreq = centerFreq / THIRD_OCT_FACTOR;
      const highFreq = centerFreq * THIRD_OCT_FACTOR;

      const lowBin = Math.max(1, Math.floor(lowFreq / binHz));
      const highBin = Math.min(numBins - 1, Math.ceil(highFreq / binHz));

      // Sum linear power (not dB - logarithmic values cannot be averaged)
      let powerSum = 0, count = 0;
      for (let i = lowBin; i <= highBin; i++) {
        const powerL = Math.pow(10, spectrumFreqBufL[i] / 10);
        const powerR = Math.pow(10, spectrumFreqBufR[i] / 10);
        powerSum += 0.5 * (powerL + powerR);
        count++;
      }

      const avgPower = count > 0 ? powerSum / count : 0;
      const bandDb = avgPower > 0 ? 10 * Math.log10(avgPower) : -100;

      // Store raw band value (DSP untouched)
      spectrumSmooth[b] = bandDb;
    }

    // =========================================================
    // RTW/TC-GRADE VISUAL RENDERING (UI ONLY - NO DSP CHANGES)
    // =========================================================

    // Layout calculations
    const paddingL = Math.round(28 * dpr);  // Left padding for dB labels
    const paddingR = Math.round(6 * dpr);
    const paddingT = Math.round(6 * dpr);
    const paddingB = Math.round(18 * dpr);  // Bottom padding for freq labels
    const barAreaW = w - paddingL - paddingR;
    const barAreaH = h - paddingT - paddingB;
    const gap = Math.round(1 * dpr);
    const barWidth = Math.max(2 * dpr, (barAreaW - gap * (SPECTRUM_NUM_BANDS - 1)) / SPECTRUM_NUM_BANDS);

    // Y-position helper: maps dB to pixel (top = +9dB, bottom = -36dB)
    function dbToY(db) {
      const clamped = Math.max(RTW_VISIBLE_BOTTOM_DB, Math.min(RTW_VISIBLE_TOP_DB, db));
      return paddingT + ((RTW_VISIBLE_TOP_DB - clamped) / RTW_RANGE_DB) * barAreaH;
    }
    const zeroLineY = dbToY(0);
    const bottomY = paddingT + barAreaH;

    // Draw gridlines first (behind bars)
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    const majorMarks = [6, 0, -6, -12, -18, -24, -30, -36, -42, -48];
    for (const mark of majorMarks) {
      const y = dbToY(mark);
      ctx.beginPath();
      ctx.moveTo(paddingL, y);
      ctx.lineTo(w - paddingR, y);
      ctx.stroke();
    }

    // Draw 0 dB reference line (red, thicker)
    ctx.strokeStyle = '#c5312f';
    ctx.lineWidth = 1.5 * dpr;
    ctx.beginPath();
    ctx.moveTo(paddingL, zeroLineY);
    ctx.lineTo(w - paddingR, zeroLineY);
    ctx.stroke();

    // Process and draw each band
    for (let b = 0; b < SPECTRUM_NUM_BANDS; b++) {
      const actualValue = spectrumSmooth[b];

      // RTW Ballistics: instant rise, 12 dB/s fall
      if (actualValue > spectrumDisplayVal[b]) {
        spectrumDisplayVal[b] = actualValue;  // Instant rise
      } else {
        spectrumDisplayVal[b] = Math.max(spectrumDisplayVal[b] - RTW_FALL_RATE * deltaTime, actualValue);
      }

      // Visual micro-jitter smoothing (0.85/0.15 blend)
      spectrumDisplayVal[b] = spectrumDisplayVal[b] * (1 - RTW_DISPLAY_SMOOTH) + actualValue * RTW_DISPLAY_SMOOTH;

      // Peak marker: hold then fall
      if (actualValue > spectrumPeakMarker[b]) {
        spectrumPeakMarker[b] = actualValue;
        spectrumPeakTimer[b] = RTW_PEAK_HOLD_MS;
      } else if (spectrumPeakTimer[b] > 0) {
        spectrumPeakTimer[b] -= deltaTime * 1000;
      } else {
        spectrumPeakMarker[b] -= RTW_PEAK_FALL_RATE * deltaTime;
      }

      // Calculate bar geometry (apply visual boost for display)
      const displayDb = spectrumDisplayVal[b] + RTW_VISUAL_BOOST;
      const barX = paddingL + b * (barWidth + gap);

      // LED-style rendering: 57 cells (1 dB each, from -48 to +9)
      const LED_CELLS = 57;
      const LED_GAP = Math.max(1, Math.round(1 * dpr));  // Gap between cells
      const cellH = (barAreaH - LED_GAP * (LED_CELLS - 1)) / LED_CELLS;

      // Draw LED cells from bottom to top
      for (let cell = 0; cell < LED_CELLS; cell++) {
        const cellDb = RTW_VISIBLE_BOTTOM_DB + cell;  // -36 + cell = dB value for this cell
        const cellY = bottomY - (cell + 1) * (cellH + LED_GAP) + LED_GAP;

        // Only draw lit cells (up to displayDb)
        if (cellDb < displayDb) {
          // Color based on dB level
          if (cellDb >= 0) {
            ctx.fillStyle = '#ff3b2f';  // Red: above 0 dB
          } else if (cellDb >= -6) {
            ctx.fillStyle = '#ff9500';  // Orange: -6 to 0 dB
          } else {
            ctx.fillStyle = '#f2c74e';  // Yellow: below -6 dB
          }
          ctx.fillRect(barX, cellY, barWidth, cellH);
        }
      }

      // Peak-hold marker (white LED cell at peak position)
      const peakDb = spectrumPeakMarker[b] + RTW_VISUAL_BOOST;
      if (peakDb > RTW_VISIBLE_BOTTOM_DB) {
        const peakCell = Math.floor(peakDb - RTW_VISIBLE_BOTTOM_DB);
        if (peakCell >= 0 && peakCell < LED_CELLS) {
          const peakCellY = bottomY - (peakCell + 1) * (cellH + LED_GAP) + LED_GAP;
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.fillRect(barX, peakCellY, barWidth, cellH);
        }
      }
    }

    // Draw dB scale labels on left side
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = `${Math.round(8 * dpr)}px ui-monospace, monospace`;
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    const dbLabels = [6, 0, -12, -24, -36, -48];
    for (const mark of dbLabels) {
      const y = dbToY(mark);
      const label = mark > 0 ? `+${mark}` : `${mark}`;
      ctx.fillText(label, paddingL - 4 * dpr, y);
    }

    // Draw frequency axis labels (bottom)
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.font = `${Math.round(7 * dpr)}px ui-monospace, monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const freqLabels = [
      { freq: 31.5, label: '31' },
      { freq: 63, label: '63' },
      { freq: 125, label: '125' },
      { freq: 250, label: '250' },
      { freq: 500, label: '500' },
      { freq: 1000, label: '1k' },
      { freq: 2000, label: '2k' },
      { freq: 4000, label: '4k' },
      { freq: 8000, label: '8k' },
      { freq: 16000, label: '16k' }
    ];
    for (const fl of freqLabels) {
      // Find band index for this frequency
      let bandIdx = SPECTRUM_CENTER_FREQS.findIndex(f => Math.abs(f - fl.freq) < fl.freq * 0.1);
      if (bandIdx >= 0) {
        const x = paddingL + bandIdx * (barWidth + gap) + barWidth / 2;
        ctx.fillText(fl.label, x, bottomY + 3 * dpr);
      }
    }
  }

  // 2) Mid/Side Meter (DOM-based, just update values)
  function updateMSMeter() {
    if (!msFillM || !msFillS) return;

    const midDb = StereoAnalysisEngine.getMidLevel();
    const sideDb = StereoAnalysisEngine.getSideLevel();

    // Map dB to percentage (0 = -60dB, 100% = 0dB)
    const midPct = Math.max(0, Math.min(100, (midDb + 60) / 60 * 100));
    const sidePct = Math.max(0, Math.min(100, (sideDb + 60) / 60 * 100));

    msFillM.style.width = midPct + '%';
    msFillS.style.width = sidePct + '%';

    if (msValueM) msValueM.textContent = formatDb(midDb, 1, 6) + ' dB';
    if (msValueS) msValueS.textContent = formatDb(sideDb, 1, 6) + ' dB';
  }

  // 3) Width Meter (replaces Rotation)
  function drawWidthMeter() {
    if (!widthMeterCtx) return;
    const canvas = widthMeter;
    if (!canvas) return;

    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const cssW = rect.width;
    const cssH = rect.height;

    if (cssW < 1 || cssH < 1) return;

    const w = Math.floor(cssW * dpr);
    const h = Math.floor(cssH * dpr);

    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }

    const ctx = widthMeterCtx;
    ctx.clearRect(0, 0, w, h);

    const widthVal = StereoAnalysisEngine.getWidth();     // 0..1+
    const widthPeak = StereoAnalysisEngine.getWidthPeak();
    const padding = w * 0.02;
    const centerY = h / 2;
    const trackW = w - padding * 2;
    const trackH = Math.max(6, h * 0.35);
    const radius = 4 * dpr;

    // Draw track background with rounded corners
    ctx.fillStyle = '#0a0c0e';
    ctx.beginPath();
    ctx.roundRect(padding, centerY - trackH / 2, trackW, trackH, radius);
    ctx.fill();

    // Color zones: 0-30% M-color (blue), 30-60% green, 60-80% yellow, 80-100% orange, >100% red
    function widthColor(w) {
      if (w >= 1.0) return '#ff4444';   // Red: >100%
      if (w >= 0.8) return '#ff9a2d';   // Orange: 80-100%
      if (w >= 0.6) return '#ffd94a';   // Yellow: 60-80%
      if (w >= 0.3) return '#44bb66';   // Green: 30-60%
      return '#3b82f6';                  // M-color (blue): 0-30%
    }

    // Draw fill bar with rounded corners
    const fillW = Math.min(1.0, widthVal) * trackW;
    const fillColor = widthColor(widthVal);
    ctx.fillStyle = fillColor;
    ctx.beginPath();
    ctx.roundRect(padding, centerY - trackH / 2, fillW, trackH, radius);
    ctx.fill();

    // Draw peak hold tick (taller)
    const peakX = padding + Math.min(1.0, widthPeak) * trackW;
    ctx.fillStyle = widthColor(widthPeak);
    ctx.fillRect(peakX - 1.5 * dpr, centerY - trackH * 0.8, 3 * dpr, trackH * 1.6);
  }

  // 4) Rotation Meter - stereo centroid angle with trail
  // Colors: M (center) = #3b82f6 (blue), S (edges) = #22d3ee (cyan)
  function rotationColor(rotationValue) {
    // |rotation| 0 = M color (blue), |rotation| 1 = S color (cyan)
    const t = Math.abs(rotationValue);  // 0..1
    // M color: rgb(59, 130, 246), S color: rgb(34, 211, 238)
    const r = Math.round(59 + t * (34 - 59));
    const g = Math.round(130 + t * (211 - 130));
    const b = Math.round(246 + t * (238 - 246));
    return `rgb(${r}, ${g}, ${b})`;
  }

  function drawRotation() {
    if (!rotationCtx || !rotationCanvas) return;

    // Use wrapper for dimensions
    const rotationWrap = xyCard.querySelector('.rotationWrap');
    if (!rotationWrap) return;

    const dpr = window.devicePixelRatio || 1;
    const rect = rotationWrap.getBoundingClientRect();
    const cssW = rect.width;
    const cssH = rect.height;

    if (cssW < 1 || cssH < 1) return;

    const w = Math.floor(cssW * dpr);
    const h = Math.floor(cssH * dpr);

    if (rotationCanvas.width !== w || rotationCanvas.height !== h) {
      rotationCanvas.width = w;
      rotationCanvas.height = h;
    }

    const ctx = rotationCtx;
    ctx.clearRect(0, 0, w, h);

    const padding = w * 0.04;
    const trackY = h / 2;
    const trackW = w - padding * 2;
    const centerX = w / 2;
    const trackH = Math.max(4, h * 0.12);

    // 1. Draw track background
    ctx.fillStyle = '#1a1f25';
    ctx.fillRect(padding, trackY - trackH / 2, trackW, trackH);

    // 2. Centre tick
    ctx.fillStyle = '#4b5563';
    ctx.fillRect(centerX - 1, trackY - trackH, 2, trackH * 2);

    // 3. Trail (fading opacity) with dynamic color
    const history = StereoAnalysisEngine.getRotationHistory();
    const usableW = trackW / 2 - padding;
    history.forEach((val, i) => {
      const alpha = (i + 1) / history.length * 0.4;
      const x = centerX + val * usableW;
      const radius = Math.max(2, h * 0.06);
      const color = rotationColor(val);

      ctx.beginPath();
      ctx.arc(x, trackY, radius, 0, Math.PI * 2);
      ctx.fillStyle = color.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
      ctx.fill();
    });

    // 4. Main dot with glow - dynamic color based on position
    const rotation = StereoAnalysisEngine.getRotation();
    const dotX = centerX + rotation * usableW;
    const dotRadius = Math.max(3, h * 0.1);
    const dotColor = rotationColor(rotation);

    ctx.shadowColor = dotColor;
    ctx.shadowBlur = 8 * dpr;
    ctx.beginPath();
    ctx.arc(dotX, trackY, dotRadius, 0, Math.PI * 2);
    ctx.fillStyle = dotColor;
    ctx.fill();
    ctx.shadowBlur = 0;

    // 5. Degree scale at bottom (−45° 0° +45°)
    const degreeY = h - 4 * dpr;
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.font = `${Math.round(7 * dpr)}px ui-monospace, monospace`;
    ctx.textBaseline = 'bottom';

    ctx.textAlign = 'left';
    ctx.fillText('−45°', padding, degreeY);

    ctx.textAlign = 'center';
    ctx.fillText('0°', centerX, degreeY);

    ctx.textAlign = 'right';
    ctx.fillText('+45°', w - padding, degreeY);
  }

  // Combined update function for all stereo analysis widgets
  function updateStereoAnalysis() {
    drawSpectrum();
    updateMSMeter();
    drawWidthMeter();
    drawRotation();
  }

  // ------- Digital RMS (dBFS) – Average digital level, 0 dBFS = full-scale sine -------
  const dbfsMarks = [-60,-50,-40,-30,-24,-18,-12,-6,-3,0];
  function layoutDBFSScale(el){
    el.innerHTML='';
    dbfsMarks.forEach(m=>{
      const x = ((m+60)/60)*100;
      const t=document.createElement('div');
      t.style.position='absolute'; t.style.left=`calc(${x}% - 0.5px)`; t.style.top='25%'; t.style.height='50%'; t.style.width='1px'; t.style.background='#2a3642';
      el.appendChild(t);
      const lab=document.createElement('div');
      lab.textContent=m + ' dBFS';
      lab.style.position='absolute'; lab.style.left=`calc(${x}% - 32px)`; lab.style.top='8px'; lab.style.width='64px'; lab.style.textAlign='center'; lab.style.fontSize='10px'; lab.style.color='#88a3bf';
      el.appendChild(lab);
    });
    // TEST -21 dBFS RMS (= 0 dBu = -18 dBFS peak för sinus)
    const x = ((-21+60)/60)*100;
    const ref=document.createElement('div');
    ref.style.position='absolute';
    ref.style.left=`calc(${x}% - 0.5px)`;
    ref.style.top='25%';
    ref.style.height='50%';
    ref.style.width='1px';
    ref.style.background=getCss('--cyan');
    ref.style.opacity='0.95';
    el.appendChild(ref);
    const tag=document.createElement('div');
    tag.innerHTML='<div>TEST</div><div>−21 dBFS RMS</div><div>−18 dBFS peak</div>';
    tag.style.position='absolute';
    tag.style.left=`calc(${x}% - 40px)`;
    tag.style.bottom='4px';
    tag.style.width='80px';
    tag.style.textAlign='center';
    tag.style.fontSize='9px';
    tag.style.color=getCss('--cyan');
    tag.style.fontWeight='bold';
    tag.style.lineHeight='1.15';
    tag.style.background='none';
    tag.style.borderRadius='0';
    tag.style.padding='0';
    el.appendChild(tag);
  }

  // ------- True Peak (dBTP) – 4× oversampling, 0 dBTP = full scale -------
  function layoutTPScale(el){
    el.innerHTML='';
    // Use global scale constants (TP_SCALE_MIN, TP_SCALE_MAX, TP_SCALE_SPAN)
    const marks = [-60,-50,-40,-30,-24,-18,-12,-6,-3,0,3];
    marks.forEach(m=>{
      const x = ((m - TP_SCALE_MIN) / TP_SCALE_SPAN) * 100;
      // Skip gray tick at 0 dBTP (red line drawn in canvas instead)
      if (m !== 0) {
        const t=document.createElement('div');
        t.style.position='absolute'; t.style.left=`calc(${x}% - 1px)`; t.style.top='25%'; t.style.height='50%'; t.style.width='2px'; t.style.background='#2a3642';
        el.appendChild(t);
      }
      const lab=document.createElement('div');
      lab.innerHTML = (m > 0 ? '+' : '') + m + '<br>dBTP';
      lab.style.position='absolute'; lab.style.left=`calc(${x}% - 32px)`; lab.style.top='2px'; lab.style.width='64px'; lab.style.textAlign='center'; lab.style.fontSize='10px'; lab.style.color='#88a3bf'; lab.style.lineHeight='1.1';
      el.appendChild(lab);
    });
    // warn zones (styled like VU Nordic, label at bottom, color-coded)
    const warn=[
      {v:-6,c:'var(--warn)',w:1,label:'−6 dBTP',color:getCss('--warn')},
      {v:-3,c:'var(--caution)',w:1,label:'−3 dBTP',color:getCss('--caution')}
    ];
    for(const mk of warn){
      const x = ((mk.v - TP_SCALE_MIN) / TP_SCALE_SPAN) * 100;
      const col=document.createElement('div');
      col.style.position='absolute'; col.style.left=`calc(${x}% - 0.5px)`; col.style.top='25%'; col.style.height='50%'; col.style.width=`${mk.w}px`; col.style.background=`${mk.c}`; col.style.opacity='0.95';
      el.appendChild(col);
      let dbfsEq = '';
      if(mk.v === -6) dbfsEq = '−9<br>dBFS';
      if(mk.v === -3) dbfsEq = '−6<br>dBFS';
      const tag=document.createElement('div');
      tag.innerHTML = dbfsEq;
      tag.style.position='absolute';
      tag.style.left=`calc(${x}% - 32px)`;
      tag.style.bottom='8px';  // Samma luftiga spacing som blå TEST-text
      tag.style.width='64px';
      tag.style.textAlign='center';
      tag.style.fontSize='10px';
      tag.style.color=mk.color;
      tag.style.fontWeight='bold';
      tag.style.lineHeight='1.2';
      tag.style.background='none';
      tag.style.borderRadius='0';
      tag.style.padding='0';
      el.appendChild(tag);
    }
    // 0 dBTP = 0 dBFS label (red, same style as warn labels)
    const xZero = ((0 - TP_SCALE_MIN) / TP_SCALE_SPAN) * 100;
    const zeroTag = document.createElement('div');
    zeroTag.innerHTML = '0<br>dBFS';
    zeroTag.style.position = 'absolute';
    zeroTag.style.left = `calc(${xZero}% - 32px)`;
    zeroTag.style.bottom = '8px';
    zeroTag.style.width = '64px';
    zeroTag.style.textAlign = 'center';
    zeroTag.style.fontSize = '10px';
    zeroTag.style.color = getCss('--hot');
    zeroTag.style.fontWeight = 'bold';
    zeroTag.style.lineHeight = '1.2';
    zeroTag.style.background = 'none';
    zeroTag.style.borderRadius = '0';
    zeroTag.style.padding = '0';
    el.appendChild(zeroTag);
    // TEST -18 dBTP = -18 dBFS peak (broadcast alignment)
    const xRef = ((-18 - TP_SCALE_MIN) / TP_SCALE_SPAN) * 100;
    const ref=document.createElement('div');
    ref.style.position='absolute';
    ref.style.left=`calc(${xRef}% - 1px)`;
    ref.style.top='25%';
    ref.style.height='50%';
    ref.style.width='2px';
    ref.style.background=getCss('--cyan');
    ref.style.opacity='0.95';
    el.appendChild(ref);
    // TEST label below blue line
    const tag=document.createElement('div');
    tag.innerHTML='<div>TEST</div><div>−18 dBTP</div><div>−18 dBFS peak</div>';
    tag.style.position='absolute';
    tag.style.left=`calc(${xRef}% - 40px)`;
    tag.style.bottom='4px';
    tag.style.width='80px';
    tag.style.textAlign='center';
    tag.style.fontSize='9px';
    tag.style.color=getCss('--cyan');
    tag.style.fontWeight='bold';
    tag.style.lineHeight='1.2';
    tag.style.background='none';
    tag.style.borderRadius='0';
    tag.style.padding='0';
    el.appendChild(tag);

    // TP LIMIT reference line (same style as TEST line)
    const xLimit = ((TP_LIMIT - TP_SCALE_MIN) / TP_SCALE_SPAN) * 100;
    const limitRef = document.createElement('div');
    limitRef.id = 'tpLimitLine';
    limitRef.style.position = 'absolute';
    limitRef.style.left = `calc(${xLimit}% - 1px)`;
    limitRef.style.top = '25%';
    limitRef.style.height = '50%';
    limitRef.style.width = '2px';
    limitRef.style.background = getCss('--cyan');
    limitRef.style.opacity = '0.95';
    el.appendChild(limitRef);
    // LIMIT label
    const limitTag = document.createElement('div');
    limitTag.id = 'tpLimitTag';
    limitTag.innerHTML = `<div>LIMIT</div><div>${TP_LIMIT} dBTP</div>`;
    limitTag.style.position = 'absolute';
    limitTag.style.left = `calc(${xLimit}% - 40px)`;
    limitTag.style.bottom = '4px';
    limitTag.style.width = '80px';
    limitTag.style.textAlign = 'center';
    limitTag.style.fontSize = '9px';
    limitTag.style.color = getCss('--cyan');
    limitTag.style.fontWeight = 'bold';
    limitTag.style.lineHeight = '1.2';
    limitTag.style.background = 'none';
    limitTag.style.borderRadius = '0';
    limitTag.style.padding = '0';
    el.appendChild(limitTag);
  }

  // Update TP Limit line and label position when setting changes
  function updateTpLimitDisplay() {
    const xLimit = ((TP_LIMIT - TP_SCALE_MIN) / TP_SCALE_SPAN) * 100;
    const limitLine = document.getElementById('tpLimitLine');
    const limitTag = document.getElementById('tpLimitTag');
    if (limitLine) {
      limitLine.style.left = `calc(${xLimit}% - 1px)`;
    }
    if (limitTag) {
      limitTag.style.left = `calc(${xLimit}% - 40px)`;
      limitTag.innerHTML = `<div>LIMIT</div><div>${TP_LIMIT} dBTP</div>`;
    }
  }

  // Nordic PPM – klassisk Nordic N9 skala
  // PPM-skala: -36 till +9 där 0 PPM = 0 dBu = -18 dBFS peak
  const ppmMarks = [
    { ppm: -36, label: '−36' },
    { ppm: -30, label: '−30' },
    { ppm: -24, label: '−24' },
    { ppm: -18, label: '−18' },
    { ppm: -12, label: '−12' },
    { ppm:  -6, label: '−6'  },
    { ppm:   0, label: 'TEST' },  // 0 PPM / 0 dBu
    { ppm:   6, label: '+6'  },
    { ppm:   9, label: '+9'  }    // PML
  ];
  function layoutPPMScale(el){
    el.innerHTML='';
    const dbMin=-54, dbMax=-9, dbSpan=dbMax-dbMin; // 45 dB i dBFS
    // PPM = dBu, dBFS = dBu - 18
    ppmMarks.forEach(m=>{
      const dBFS = m.ppm - 18;
      const x = ((dBFS-dbMin)/dbSpan)*100;
      const t=document.createElement('div');
      t.style.position='absolute'; t.style.left=`calc(${x}% - 0.5px)`; t.style.top='25%'; t.style.height='50%'; t.style.width='1px'; t.style.background='#2a3642';
      el.appendChild(t);
      const lab=document.createElement('div');
      lab.textContent = m.label;
      lab.style.position='absolute'; lab.style.left=`calc(${x}% - 20px)`; lab.style.top='6px'; lab.style.width='40px'; lab.style.textAlign='center'; lab.style.fontSize='10px'; lab.style.color='#88a3bf';
      el.appendChild(lab);
    });
    // TEST = 0 PPM = 0 dBu = -18 dBFS (cyan linje)
    const xTest = ((-18-dbMin)/dbSpan)*100;
    const ref=document.createElement('div');
    ref.style.position='absolute';
    ref.style.left=`calc(${xTest}% - 1px)`;
    ref.style.top='25%';
    ref.style.height='50%';
    ref.style.width='2px';
    ref.style.background=getCss('--cyan');
    ref.style.opacity='0.95';
    el.appendChild(ref);
    const tag=document.createElement('div');
    tag.innerHTML='<div>TEST</div><div>0 PPM (0 dBu)</div><div>−18 dBFS peak</div>';
    tag.style.position='absolute';
    tag.style.left=`calc(${xTest}% - 44px)`;
    tag.style.bottom='4px';
    tag.style.width='88px';
    tag.style.textAlign='center';
    tag.style.fontSize='9px';
    tag.style.color=getCss('--cyan');
    tag.style.fontWeight='bold';
    tag.style.lineHeight='1.15';
    tag.style.background='none';
    tag.style.borderRadius='0';
    tag.style.padding='0';
    el.appendChild(tag);
    // PML = +9 PPM = +9 dBu = -9 dBFS (röd markering)
    const xPML = ((-9-dbMin)/dbSpan)*100;
    const pmlLine=document.createElement('div');
    pmlLine.style.position='absolute';
    pmlLine.style.left=`calc(${xPML}% - 1px)`;
    pmlLine.style.top='25%';
    pmlLine.style.height='50%';
    pmlLine.style.width='2px';
    pmlLine.style.background=getCss('--hot');
    pmlLine.style.opacity='0.95';
    el.appendChild(pmlLine);
    const pmlTag=document.createElement('div');
    pmlTag.innerHTML='<div>PML</div><div>+9 PPM</div>';
    pmlTag.style.position='absolute';
    pmlTag.style.left=`calc(${xPML}% - 32px)`;
    pmlTag.style.bottom='8px';
    pmlTag.style.width='64px';
    pmlTag.style.textAlign='center';
    pmlTag.style.fontSize='10px';
    pmlTag.style.color=getCss('--hot');
    pmlTag.style.fontWeight='bold';
    pmlTag.style.lineHeight='1.2';
    pmlTag.style.background='none';
    pmlTag.style.borderRadius='0';
    pmlTag.style.padding='0';
    el.appendChild(pmlTag);
  }

  function drawHBar_DBFS(canvas, valueL, valueR){
    const dpr=window.devicePixelRatio||1;
    const w=Math.floor(canvas.clientWidth*dpr), h=Math.floor(canvas.height);
    if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h }
    const ctx = canvas.getContext('2d');
    function xFromDb(db){ const c=Math.max(-60,Math.min(0,db)); return Math.round((c+60)/60*w) }
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#0e151a'; ctx.fillRect(0,0,w,h);
    const step=0.5;  // 0.5 dB resolution → 120 "dioder"
    function drawChannel(yTop, val){
      for(let d=-60; d<0; d+=step){ const x0=xFromDb(d), x1=xFromDb(d+step); if(x1<=x0) continue; ctx.globalAlpha=.14; ctx.fillStyle=getCss('--ok'); ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12); }
      const tEnd = Math.min(0, val);
      for(let d=-60; d<tEnd; d+=step){ const x0=xFromDb(d), x1=xFromDb(Math.min(d+step,tEnd)); if(x1<=x0) continue; ctx.globalAlpha=.9; ctx.fillStyle=getCss('--ok'); ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12); }
    }
    drawChannel(h*0.35, valueL); drawChannel(h*0.55, valueR);
    ctx.globalAlpha=1; ctx.fillStyle='#2a3642'; ctx.fillRect(w-2,0,2,h); // 0 dBFS fence
  }

  // True Peak (dBTP) – LED-style rendering med peak-hold markör
  // Range: -60 dBTP till +3 dBTP = 126 LED cells (0.5 dB per cell)
  function drawDiodeBar_TP(canvas, valueL, valueR, peakHoldL, peakHoldR){
    const dpr=window.devicePixelRatio||1; const w=Math.floor(canvas.clientWidth*dpr), h=Math.floor(canvas.height);
    if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h }
    const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,w,h); ctx.fillStyle='#0e151a'; ctx.fillRect(0,0,w,h);

    // LED cell constants - 126 cells for 63 dB range (-60 to +3), 0.5 dB per cell
    const LED_CELLS = 126;
    const LED_GAP = Math.max(1, Math.round(1 * dpr));  // 1px gap between cells
    const cellW = (w - LED_GAP * (LED_CELLS - 1)) / LED_CELLS;
    const barH = Math.round(h * 0.12);

    function segColor(db){
      if(db >= 0) return '#ff2020';   // Above 0 dBTP: aggressive bright red
      if(db>=-1) return getCss('--hot');
      if(db>=-3) return getCss('--caution');
      if(db>=-6) return getCss('--warn');
      return getCss('--ok');
    }
    // Brighter version for peak-hold
    function peakColor(db){
      if(db >= 0) return '#ff4040';   // Above 0 dBTP: extra bright red with glow
      if(db>=-1) return '#ff6b5b';
      if(db>=-3) return '#ffb74d';
      if(db>=-6) return '#ffe066';
      return '#7dff7d';
    }

    function drawChannel(yTop, val, peakHold){
      const displayDb = Math.max(-60, Math.min(3, val));
      const peakDbRaw = (peakHold !== undefined) ? peakHold : -61;
      const peakDb = Math.max(-60, Math.min(3, peakDbRaw));
      const peakCell = Math.max(
        0,
        Math.min(LED_CELLS - 1, Math.round((peakDb + 60) * 2))  // 0.5 dB per cell över 63 dB
      );

      for (let cell = 0; cell < LED_CELLS; cell++) {
        const cellDb = -60 + cell * 0.5;  // 0.5 dB per cell, 126 celler → −60…+3 täcks
        const cellX = cell * (cellW + LED_GAP);
        const col = segColor(cellDb + 0.25);  // Color based on cell center

        // Background (dimmed) - all cells
        ctx.globalAlpha = 0.14;
        ctx.fillStyle = col;
        ctx.fillRect(cellX, yTop, cellW, barH);

        // Active cell - lit if below current value
        if (cellDb < displayDb) {
          // Extra aggressive for cells above 0 dBTP
          if (cellDb >= 0) {
            ctx.globalAlpha = 1.0;
            ctx.shadowColor = '#ff2020';
            ctx.shadowBlur = 6 * dpr;
          } else {
            ctx.globalAlpha = 0.9;
            ctx.shadowBlur = 0;
          }
          ctx.fillStyle = col;
          ctx.fillRect(cellX, yTop, cellW, barH);
          ctx.shadowBlur = 0;
        }
      }

      // Peak-hold cell - brighter same-zone color with subtle glow
      if (peakCell >= 0 && peakCell < LED_CELLS && peakHold > -60) {
        const peakCellDb = -60 + peakCell * 0.5;
        const cellX = peakCell * (cellW + LED_GAP);
        const pCol = peakColor(peakCellDb);
        ctx.globalAlpha = 1;
        ctx.shadowColor = pCol;
        ctx.shadowBlur = (peakCellDb >= 0) ? 8 * dpr : 4 * dpr;  // Extra glow above 0
        ctx.fillStyle = pCol;
        ctx.fillRect(cellX, yTop, cellW, barH);
        ctx.shadowBlur = 0;
      }
    }
    drawChannel(h*0.35, valueL, peakHoldL); drawChannel(h*0.55, valueR, peakHoldR);
    // 0 dBTP fence at correct position in -60..+3 range (red line, same style as warn zones)
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = getCss('--hot');
    const zeroX = ((0 + 60) / 63) * w;  // 0 dBTP position i -60..+3
    ctx.fillRect(Math.round(zeroX) - 1, h * 0.25, 2, h * 0.5);  // 25% top, 50% height
  }

  // Nordic PPM – horisontell canvas rendering med RTW-style färgzoner
  // Range: -54 dBFS till -9 dBFS (45 dB span) = -36 PPM till +9 PPM
  // 0 PPM = 0 dBu = -18 dBFS peak, PML = +9 PPM = -9 dBFS
  function drawHBar_PPM(canvas, dBfsL, dBfsR, peakHoldL, peakHoldR){
    const dpr=window.devicePixelRatio||1;
    const rect = canvas.getBoundingClientRect();
    const w=Math.floor(rect.width*dpr), h=Math.floor(rect.height*dpr);
    if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h }
    const ctx = canvas.getContext('2d');
    const dbMin=-54, dbMax=-9, dbSpan=dbMax-dbMin; // 45 dB
    function xFromDb(db){ const c=Math.max(dbMin,Math.min(dbMax,db)); return Math.round((c-dbMin)/dbSpan*w) }
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#0e151a'; ctx.fillRect(0,0,w,h);
    const step=0.5;  // 0.5 dB resolution → 90 "dioder"
    // Nordic PPM färgzoner (PPM = dBu = dBFS + 18)
    function segColor(db){
      const ppm = db + 18; // dBFS -> PPM/dBu
      if (ppm >= 6)  return getCss('--hot');      // +6..+9: rött (över PML)
      if (ppm >= 0)  return getCss('--caution');  // 0..+6: amber (nominal / varning)
      return getCss('--ok');                      // <0: grönt (allt under line-up)
    }
    function drawChannel(yTop, val, peakHold){
      // Bakgrund (dimmat)
      for(let d=dbMin; d<dbMax; d+=step){
        const x0=xFromDb(d), x1=xFromDb(d+step);
        if(x1<=x0) continue;  // aliasing protection
        ctx.globalAlpha=.14;
        ctx.fillStyle=segColor(d+step/2);
        ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12);
      }
      // Aktiv bar
      const tEnd = Math.min(dbMax, val);
      for(let d=dbMin; d<tEnd; d+=step){
        const x0=xFromDb(d), x1=xFromDb(Math.min(d+step,tEnd));
        if(x1<=x0) continue;  // aliasing protection
        ctx.globalAlpha=.9;
        ctx.fillStyle=segColor(d+step/2);
        ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12);
      }
      // Peak-hold markör (RTW-style: tunn linje)
      if (peakHold !== undefined && peakHold > dbMin) {
        const xPeak = xFromDb(peakHold);
        const peakColor = segColor(peakHold);
        ctx.globalAlpha = 1;
        ctx.fillStyle = peakColor;
        ctx.fillRect(xPeak - 1, yTop - 2, 2, h*0.12 + 4);
        ctx.fillRect(xPeak - 3, yTop - 2, 6, 2);
      }
    }
    drawChannel(h*0.35, dBfsL, peakHoldL); drawChannel(h*0.55, dBfsR, peakHoldR);
    ctx.globalAlpha=1; ctx.fillStyle='#2a3642'; ctx.fillRect(w-2,0,2,h); // +9 PPM fence
  }

  let rmsHoldL=0, rmsHoldR=0; let lastTsDB=performance.now();
  function drawDBFS(){
    analyserL.getFloatTimeDomainData(bufL); analyserR.getFloatTimeDomainData(bufR);
    let sL=0,sR=0; for(let i=0;i<bufL.length;i++){ sL+=bufL[i]*bufL[i]; sR+=bufR[i]*bufR[i] }
    const rmsL=Math.sqrt(sL/bufL.length), rmsR=Math.sqrt(sR/bufR.length);
    const now=performance.now(); const dt=Math.max(0.001,(now-lastTsDB)/1000); lastTsDB=now; const tau=.3, a=1-Math.exp(-dt/tau);
    rmsHoldL += a*(rmsL - rmsHoldL); rmsHoldR += a*(rmsR - rmsHoldR);
    const dBL = 20*Math.log10(rmsHoldL+1e-12); const dBR = 20*Math.log10(rmsHoldR+1e-12);
    // Visa "--.-" om signalen är under botten av skalan (-60 dBFS)
    const dbfsLStr = (dBL <= -59) ? '--.-' : formatDb(dBL);
    const dbfsRStr = (dBR <= -59) ? '--.-' : formatDb(dBR);
    document.getElementById('dbfsLabel').innerHTML = `L: <b>${dbfsLStr}</b> · R: <b>${dbfsRStr}</b> dBFS`;
    drawHBar_DBFS(dbfs, dBL, dBR);
  }
  layoutDBFSScale(dbfsScale);
  layoutPPMScale(ppmScale);

  function hermite(p0,p1,p2,p3,t){ const a= (-0.5*p0)+(1.5*p1)+(-1.5*p2)+(0.5*p3); const b=(p0*(-1))+ (2.5*p1)+(-2*p2)+ (0.5*p3); const c=(-0.5*p0)+(0.5*p2); const d=p1; return ((a*t+b)*t+c)*t+d; }
  function truePeakDb(buf){
    let maxAbs=0; const n=buf.length;
    for(let i=1;i<n-2;i++){
      const p0=buf[i-1], p1=buf[i], p2=buf[i+1], p3=buf[i+2];
      const a=Math.abs(p1); if(a>maxAbs) maxAbs=a;
      const t1=Math.abs(hermite(p0,p1,p2,p3,0.25)); if(t1>maxAbs) maxAbs=t1;
      const t2=Math.abs(hermite(p0,p1,p2,p3,0.50)); if(t2>maxAbs) maxAbs=t2;
      const t3=Math.abs(hermite(p0,p1,p2,p3,0.75)); if(t3>maxAbs) maxAbs=t3;
    }
    return 20*Math.log10(maxAbs + 1e-9);
  }
  let tpSmoothL=-60, tpSmoothR=-60;
  // Peak-hold för True Peak (RTW-style): 3 sekunders hold
  let tpPeakHoldL=-60, tpPeakHoldR=-60, tpPeakTimeL=0, tpPeakTimeR=0;
  const TP_PEAK_HOLD_SEC = 3; // 3 sekunder peak-hold
  let tpOverFlag = false; // OVER-indikator

  // Peak indicator state (for radar diode) - current TP with short hold
  // PEAK_INDICATOR_THRESHOLD now uses TP_LIMIT (configurable global)
  const PEAK_INDICATOR_HOLD_MS = 500;     // 500ms hold to avoid flicker
  let peakIndicatorOn = false;
  let peakIndicatorLastTrigger = 0;

  function drawTruePeak(){
    analyserL.getFloatTimeDomainData(bufL); analyserR.getFloatTimeDomainData(bufR);
    // No clamp here - let drawDiodeBar_TP handle the -60..+3 range
    const rawL = truePeakDb(bufL); const rawR = truePeakDb(bufR);
    const a = 0.25; tpSmoothL = tpSmoothL + a*(rawL - tpSmoothL); tpSmoothR = tpSmoothR + a*(rawR - tpSmoothR);

    // Peak-hold logik
    const now = performance.now() / 1000;
    if (tpSmoothL > tpPeakHoldL) { tpPeakHoldL = tpSmoothL; tpPeakTimeL = now; }
    else if (now - tpPeakTimeL > TP_PEAK_HOLD_SEC) { tpPeakHoldL = tpSmoothL; tpPeakTimeL = now; }
    if (tpSmoothR > tpPeakHoldR) { tpPeakHoldR = tpSmoothR; tpPeakTimeR = now; }
    else if (now - tpPeakTimeR > TP_PEAK_HOLD_SEC) { tpPeakHoldR = tpSmoothR; tpPeakTimeR = now; }

    // OVER-indikator om TP >= TP_LIMIT
    const maxPeak = Math.max(tpPeakHoldL, tpPeakHoldR);
    if (maxPeak >= TP_LIMIT) tpOverFlag = true;

    // Peak indicator for radar (current True Peak with short hold)
    const currentTruePeak = Math.max(tpSmoothL, tpSmoothR);
    const nowMs = performance.now();
    if (currentTruePeak >= TP_LIMIT) {
      peakIndicatorOn = true;
      peakIndicatorLastTrigger = nowMs;
    } else if (nowMs - peakIndicatorLastTrigger > PEAK_INDICATOR_HOLD_MS) {
      peakIndicatorOn = false;
    }

    // Update DOM-based peak LED
    if (peakLed) peakLed.classList.toggle('on', peakIndicatorOn);

    // Label med peak-hold max och OVER-indikator
    // Alltid samma bredd för att undvika "hopp" - använder visibility istället för att ta bort
    const overVisible = tpOverFlag;
    const overHtml = `<span style="color:var(--hot);font-weight:bold;margin-left:8px;visibility:${overVisible ? 'visible' : 'hidden'}">OVER</span>`;
    const peakMaxVal = Math.max(tpPeakHoldL, tpPeakHoldR);
    // Alltid visa Max med fixed-width placeholder
    const peakMaxStr = peakMaxVal > -59
      ? `Max: <b>${formatDb(peakMaxVal)}</b>`
      : `Max: <b style="opacity:0.3">--.-</b>`;
    // Visa "--.-" om signalen är under botten av skalan (-60 dBTP)
    const tpLStr = (tpSmoothL <= -59) ? '--.-' : formatDb(tpSmoothL);
    const tpRStr = (tpSmoothR <= -59) ? '--.-' : formatDb(tpSmoothR);
    document.getElementById('tpLabel').innerHTML = `L: <b>${tpLStr}</b> · R: <b>${tpRStr}</b> dBTP · ${peakMaxStr} dBTP${overHtml}`;

    drawDiodeBar_TP(tp, tpSmoothL, tpSmoothR, tpPeakHoldL, tpPeakHoldR);
  }
  // Reset-funktion för OVER-indikator (kan kopplas till en knapp)
  window.resetTPOver = function(){ tpOverFlag = false; tpPeakHoldL = -60; tpPeakHoldR = -60; peakIndicatorOn = false; };
  layoutTPScale(tpScale);

  // ------- R128 – EBU R128 Loudness med broadcast target −23 LUFS -------
  // LOUDNESS_TARGET is now a configurable global variable (defined at top)
  const frameDur = 2048 / 48000; const mLen = Math.max(1, Math.round(0.4 / frameDur)); const sLen = Math.max(1, Math.round(3.0 / frameDur));
  const mQ = []; const sQ = []; let intEnergy = 0, intCount = 0; let stHistory = [];

  // R128 panel: TPmax och elapsed time
  let r128TpMax = -Infinity;
  let r128StartTime = performance.now();
  const r128TpMaxEl = document.getElementById('r128TpMax');
  const r128CrestEl = document.getElementById('r128Crest');
  const r128TimeEl = document.getElementById('r128Time');
  const r128ResetBtn = document.getElementById('r128Reset');

  function resetR128() {
    // Reset integrated loudness
    intEnergy = 0; intCount = 0;
    mQ.length = 0; sQ.length = 0; stHistory = [];
    // Reset TPmax
    r128TpMax = -Infinity;
    tpOverFlag = false;
    tpPeakHoldL = -60; tpPeakHoldR = -60;
    // Reset time
    r128StartTime = performance.now();
    // Reset radar
    radarHistory.length = 0;
    lastRadarTime = 0;
    lastRadarValue = -Infinity;
    // Update display (fixed-width placeholders)
    lufsM.textContent = '--.- LUFS'; lufsS.textContent = '--.- LUFS'; lufsI.textContent = '--.- LUFS';
    lraEl.textContent = '--.- LU';
    r128TpMaxEl.textContent = '--.- dBTP';
    r128CrestEl.textContent = '--.- dB';
    r128TimeEl.textContent = '--:--:--';
  }
  r128ResetBtn.addEventListener('click', resetR128);

  // Färg baserat på avstånd från target
  function loudnessColor(lufs) {
    if (!isFinite(lufs)) return 'var(--muted)';
    const offset = lufs - LOUDNESS_TARGET;
    if (offset >= -1 && offset <= 1) return getCss('--ok');      // −24 till −22: grönt (on target)
    if (offset < -1) return getCss('--cyan');                     // Under −24: cyan (too quiet)
    if (offset <= 3) return getCss('--warn');                     // −22 till −20: amber (bit loud)
    return getCss('--hot');                                        // Över −20: rött (too loud)
  }
  function energyFromK(){
    kAnL.getFloatTimeDomainData(kBufL); kAnR.getFloatTimeDomainData(kBufR);
    let eL=0,eR=0; for(let i=0;i<kBufL.length;i++){ eL+=kBufL[i]*kBufL[i]; eR+=kBufR[i]*kBufR[i]; }
    const rmsL = eL/kBufL.length; const rmsR = eR/kBufR.length; return (rmsL + rmsR)/2;
  }
  function lufsFromEnergy(e){ return 10*Math.log10(e + 1e-12); }
  let lastText=0;
  function updateR128(){
    const e = energyFromK(); mQ.push(e); sQ.push(e);
    if(mQ.length>mLen) mQ.shift(); if(sQ.length>sLen){ stHistory.push(sQ.shift()); if(stHistory.length>Math.round(60/3)) stHistory.shift(); }
    const mE=mQ.reduce((a,b)=>a+b,0)/mQ.length; const sE=sQ.reduce((a,b)=>a+b,0)/sQ.length;
    const mLUFS=lufsFromEnergy(mE); const sLUFS=lufsFromEnergy(sE);
    let gate=-70; if(intCount>0){ const iLU=lufsFromEnergy(intEnergy/intCount); gate=Math.max(-70, iLU-10); }
    if(sLUFS>=gate){ intEnergy+=e; intCount++; }
    const iLUFS=(intCount>0)? lufsFromEnergy(intEnergy/intCount): -Infinity;
    const stVals=stHistory.map(v=>10*Math.log10(v+1e-12)).filter(v=>v>(iLUFS-20));
    // EBU R128: LRA requires sufficient data (~60s). Require at least 15 short-term blocks.
    let LRA='--.- LU'; if(stVals.length >= 15){
      const sorted=[...stVals].sort((a,b)=>a-b);
      const p95=sorted[Math.floor(sorted.length*0.95)]; const p10=sorted[Math.floor(sorted.length*0.10)];
      LRA = (p95-p10).toFixed(1).padStart(4) + ' LU';
    }
    const now=performance.now(); if(now-lastText>100){
      const a=.35;
      const prevM=parseFloat(lufsM.dataset.v||'-999'); const prevS=parseFloat(lufsS.dataset.v||'-999'); const prevI=parseFloat(lufsI.dataset.v||'-999');
      const mDisp=isFinite(prevM)? prevM + a*(mLUFS-prevM): mLUFS; const sDisp=isFinite(prevS)? prevS + a*(sLUFS-prevS): sLUFS; const iDisp=isFinite(prevI)? prevI + a*(iLUFS-prevI): iLUFS;
      lufsM.dataset.v=mDisp; lufsS.dataset.v=sDisp; lufsI.dataset.v=iDisp;
      // Momentary
      lufsM.textContent = formatLufs(mDisp);
      lufsM.style.color = loudnessColor(mDisp);
      // Short-term
      lufsS.textContent = formatLufs(sDisp);
      lufsS.style.color = loudnessColor(sDisp);
      // Integrated med offset från target
      if (isFinite(iDisp)) {
        const offsetLU = iDisp - LOUDNESS_TARGET;
        const offsetStr = formatDbSigned(offsetLU, 1, 5);
        lufsI.innerHTML = `${formatLufs(iDisp)} <span style="opacity:0.7;font-size:0.85em">(${offsetStr})</span>`;
        lufsI.style.color = loudnessColor(iDisp);
      } else {
        lufsI.textContent = '--.- LUFS';
        lufsI.style.color = '';
      }
      lraEl.textContent = LRA; lastText=now;

      // --- TPmax: spåra max true peak sedan reset ---
      const currentTpMax = Math.max(tpPeakHoldL, tpPeakHoldR);
      if (currentTpMax > r128TpMax) r128TpMax = currentTpMax;
      if (isFinite(r128TpMax) && r128TpMax > -60) {
        r128TpMaxEl.textContent = formatDb(r128TpMax, 1, 5) + ' dBTP';
        r128TpMaxEl.style.color = r128TpMax >= TP_LIMIT ? getCss('--hot') : getCss('--ok');
      } else {
        r128TpMaxEl.textContent = '--.- dBTP';
        r128TpMaxEl.style.color = '';
      }

      // --- Crest: TP(dBTP) - RMS(dBFS) using 300ms smoothed values ---
      const currentTp = Math.max(tpSmoothL, tpSmoothR);
      const rmsDbL = 20 * Math.log10(rmsHoldL + 1e-12);
      const rmsDbR = 20 * Math.log10(rmsHoldR + 1e-12);
      const currentRms = Math.max(rmsDbL, rmsDbR);
      const crest = currentTp - currentRms;
      if (isFinite(crest) && currentTp > -60 && currentRms > -60) {
        r128CrestEl.textContent = crest.toFixed(1) + ' dB';
      } else {
        r128CrestEl.textContent = '--.- dB';
      }

      // --- Elapsed time ---
      const elapsed = now - r128StartTime;
      r128TimeEl.textContent = formatTime(elapsed);

      // --- Update radar buffer with short-term loudness ---
      pushRadarLoudness(sDisp);
    }
  }

  // ------- Capture -------
  let sysStream=null, sysSrc=null, sysSplit=null, sysMonGain=null, sysMonitorMuted=true, sysTrimNode=null; let sysTrimDb = 0;
  const SYS_TRIM_DEFAULT = -12; // Browser tab default line-up
  const SYS_TRIM_STORAGE_KEY = 'tsg_sysTrimDb';

  function setSysTrim(dB, save = true) {
    sysTrimDb = clamp(parseFloat(dB) || SYS_TRIM_DEFAULT, -48, 24);
    sysTrimRange.value = sysTrimDb;
    sysTrimVal.value = Math.round(sysTrimDb);
    if (sysTrimNode) { sysTrimNode.gain.value = dbToGain(sysTrimDb); }
    if (save) { try { localStorage.setItem(SYS_TRIM_STORAGE_KEY, sysTrimDb.toFixed(1)); } catch(e) {} }
  }

  // Load from localStorage or use default (-12 dB)
  const storedSysTrim = localStorage.getItem(SYS_TRIM_STORAGE_KEY);
  setSysTrim(storedSysTrim !== null ? parseFloat(storedSysTrim) : SYS_TRIM_DEFAULT, false);

  sysTrimRange.addEventListener('input', e => setSysTrim(e.target.value));
  sysTrimVal.addEventListener('change', e => setSysTrim(e.target.value));
  sysTrimVal.addEventListener('keydown', e => { if (e.key === 'Enter') { setSysTrim(e.target.value); e.target.blur(); } });
  sysTrimReset.addEventListener('click', () => setSysTrim(SYS_TRIM_DEFAULT));

  // Helper: Build monitor status text based on actual state
  // Defaults: Tab monitor OFF, External monitor OFF, Generator monitor ON
  function updateMonitorStatusDisplay() {
    const monitorStatus = document.getElementById('monitorStatus');
    if (!monitorStatus) return;

    // Tab monitor: OFF is default
    const tabActive = sysMonGain && !sysMonitorMuted;
    const tabStatus = tabActive ? '<b>ON</b>' : '<b>OFF</b>';

    // External monitor: OFF is default
    const extActive = extMonGain && !extMonitorMuted;
    const extStatus = extActive ? '<b>ON</b>' : '<b>OFF</b>';

    // Generator monitor: ON is default
    const genActive = genMonGain && !monitorMuted;
    const genStatus = genActive ? '<b>ON</b>' : '<b>OFF</b>';

    monitorStatus.innerHTML = `Tab: ${tabStatus} · External: ${extStatus} · Generator: ${genStatus}`;
  }

  function toggleSysMonitorMute(){
    if(!sysMonGain) return;
    sysMonitorMuted = !sysMonitorMuted; sysMonGain.gain.value = sysMonitorMuted ? 0 : parseFloat(sysMonGainEl.value) / 100;
    sysMonVal.value = Math.round(sysMonGainEl.value);
    // RED when muted, neutral when not muted
    if (sysMonitorMuted){ btnSysMonMute.classList.add('btn-muted'); btnSysMonMute.classList.remove('btn-ghost'); }
    else { btnSysMonMute.classList.remove('btn-muted'); btnSysMonMute.classList.add('btn-ghost'); }

    updateMonitorStatusDisplay();
  }
  sysMonGainEl.addEventListener('input', ()=>{ sysMonVal.value=Math.round(sysMonGainEl.value); if(sysMonGain && !sysMonitorMuted){ sysMonGain.gain.value=parseFloat(sysMonGainEl.value)/100 } });
  sysMonVal.addEventListener('change', e => { sysMonGainEl.value = clamp(parseFloat(e.target.value) || 0, 0, 100); sysMonVal.value = Math.round(sysMonGainEl.value); if(sysMonGain && !sysMonitorMuted){ sysMonGain.gain.value=parseFloat(sysMonGainEl.value)/100 } });
  sysMonVal.addEventListener('keydown', e => { if (e.key === 'Enter') { sysMonGainEl.value = clamp(parseFloat(e.target.value) || 0, 0, 100); sysMonVal.value = Math.round(sysMonGainEl.value); if(sysMonGain && !sysMonitorMuted){ sysMonGain.gain.value=parseFloat(sysMonGainEl.value)/100 } e.target.blur(); } });

  // =====================================================
  // UNIFIED INPUT SOURCE SYSTEM
  // =====================================================

  // State: selectedMode = UI selection, activeCapture = currently running source
  let selectedInputMode = 'browser'; // 'browser', 'external', 'generator'
  let activeCapture = null; // null, 'browser', 'external', 'generator'

  // External source state
  let extStream = null, extSrc = null, extSplit = null, extMonGain = null, extTrimNode = null;
  let extMonitorMuted = true;
  let extTrimDb = 0;
  let extWorkletNode = null;
  let extWorkletLoaded = false;
  let extAvailable = true;

  const EXT_TRIM_DEFAULT = 0;
  const EXT_TRIM_STORAGE_KEY = 'tsg_extTrimDb';
  const EXT_DEVICE_STORAGE_KEY = 'tsg_extDeviceId';
  const PANEL_COLLAPSE_STORAGE_KEY = 'tsg_panelCollapseState';

  // --- Update Input Source Summary (for collapsed panel) ---
  function updateInputSourceSummary() {
    if (!inputSourceSummary) return;
    if (!activeCapture) {
      inputSourceSummary.textContent = '–';
    } else if (activeCapture === 'browser') {
      inputSourceSummary.textContent = 'Browser Tab';
    } else if (activeCapture === 'external') {
      const opt = extDeviceSelect.options[extDeviceSelect.selectedIndex];
      const name = opt && opt.value ? opt.textContent.slice(0, 20) : 'External';
      inputSourceSummary.textContent = name;
    } else if (activeCapture === 'generator') {
      inputSourceSummary.textContent = 'Internal Generator';
    }
  }

  // --- Input Mode Switching (UI only, does NOT stop/start capture) ---
  function setInputMode(mode) {
    selectedInputMode = mode;

    // Update button states
    [btnModeBrowser, btnModeExternal, btnModeGenerator].forEach(btn => {
      btn.classList.remove('btn-active');
      btn.classList.add('btn-ghost');
    });
    if (mode === 'browser') btnModeBrowser.classList.add('btn-active'), btnModeBrowser.classList.remove('btn-ghost');
    else if (mode === 'external') btnModeExternal.classList.add('btn-active'), btnModeExternal.classList.remove('btn-ghost');
    else if (mode === 'generator') btnModeGenerator.classList.add('btn-active'), btnModeGenerator.classList.remove('btn-ghost');

    // Show/hide panels with animation
    browserSourcePanel.classList.toggle('source-panel-hidden', mode !== 'browser');
    externalSourcePanel.classList.toggle('source-panel-hidden', mode !== 'external');
    generatorSourcePanel.classList.toggle('source-panel-hidden', mode !== 'generator');

    // Enumerate devices when switching to external mode
    if (mode === 'external') enumerateAudioDevices();

    // Update start/stop button state based on whether THIS mode is capturing
    updateCaptureButtons();
  }

  function updateCaptureButtons() {
    const isActiveMode = activeCapture === selectedInputMode;
    const isAnyCapture = activeCapture !== null;

    if (isActiveMode) {
      btnStartCapture.disabled = true;
      btnStopCapture.disabled = false;
    } else {
      btnStartCapture.disabled = false;
      btnStopCapture.disabled = !isAnyCapture || activeCapture !== selectedInputMode;
    }
    // If viewing a different mode than active, show stop as disabled
    if (activeCapture && activeCapture !== selectedInputMode) {
      btnStopCapture.disabled = true;
    }
  }

  btnModeBrowser.addEventListener('click', () => setInputMode('browser'));
  btnModeExternal.addEventListener('click', () => setInputMode('external'));
  btnModeGenerator.addEventListener('click', () => setInputMode('generator'));

  // --- Unified Start Capture ---
  async function startCapture() {
    // Stop any existing capture from OTHER sources first
    if (activeCapture && activeCapture !== selectedInputMode) {
      await stopActiveCapture();
    }

    // Start capture for selected mode
    if (selectedInputMode === 'browser') {
      await startBrowserCapture();
    } else if (selectedInputMode === 'external') {
      await startExternalCapture();
    } else if (selectedInputMode === 'generator') {
      await startGeneratorCapture();
    }
  }

  async function stopActiveCapture() {
    if (activeCapture === 'browser') {
      stopBrowserCapture();
    } else if (activeCapture === 'external') {
      stopExternalCapture();
    } else if (activeCapture === 'generator') {
      await stopGeneratorCapture();
    }
    activeCapture = null;
    updateCaptureButtons();
    updateInputSourceSummary();
  }

  btnStartCapture.addEventListener('click', startCapture);
  btnStopCapture.addEventListener('click', stopActiveCapture);

  // --- Browser Capture ---
  async function startBrowserCapture() {
    try {
      await ac.resume();
      sysStream = await navigator.mediaDevices.getDisplayMedia({
        audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false, channelCount: 2 },
        video: true
      });
      sysStream.getVideoTracks().forEach(t => t.stop());
      const track = sysStream.getAudioTracks()[0];
      if (!track) throw new Error('No audio track available.');
      try { track.applyConstraints({ advanced: [{ channelCount: 2 }] }); } catch {}
      track.contentHint = 'music';
      sysSrc = ac.createMediaStreamSource(sysStream);
      sysTrimNode = ac.createGain();
      sysTrimNode.gain.value = dbToGain(sysTrimDb);
      sysSrc.connect(sysTrimNode);
      sysSplit = connectStereoToMix(sysTrimNode);
      sysMonGain = ac.createGain();
      sysMonGain.gain.value = 0;
      sysTrimNode.connect(sysMonGain).connect(ac.destination);
      // Default: muted (RED button)
      btnSysMonMute.classList.add('btn-muted');
      btnSysMonMute.classList.remove('btn-ghost');
      sysMonitorMuted = true;
      const set = track.getSettings ? track.getSettings() : {};
      info.srcKind.textContent = (track.kind || 'audio').charAt(0).toUpperCase() + (track.kind || 'audio').slice(1);
      info.cc.textContent = set.channelCount ?? 'Unknown';
      info.sr.textContent = ac.sampleRate + ' Hz';
      info.stOK.textContent = (set.channelCount >= 2 ? 'Yes' : 'Uncertain/Mono?');
      activeCapture = 'browser';
      dbgTab.textContent = 'Yes';
      updateCaptureButtons();
      updateInputSourceSummary();
    } catch (e) {
      alert(e.message || e);
    }
  }

  function stopBrowserCapture() {
    try { sysStream && sysStream.getTracks().forEach(t => t.stop()); } catch {}
    try { sysSrc && sysSrc.disconnect(); } catch {}
    try { sysTrimNode && sysTrimNode.disconnect(); } catch {}
    try { sysSplit && sysSplit.disconnect(); } catch {}
    try { sysMonGain && sysMonGain.disconnect(); } catch {}
    sysStream = null; sysSrc = null; sysTrimNode = null; sysSplit = null; sysMonGain = null;
    sysMonitorMuted = true;
    btnSysMonMute.classList.add('btn-muted');
    btnSysMonMute.classList.remove('btn-ghost');
    dbgTab.textContent = 'No';
    if (activeCapture === 'browser') activeCapture = null;
    updateCaptureButtons();
    updateInputSourceSummary();
  }

  // --- Device Enumeration ---
  async function enumerateAudioDevices() {
    try {
      try {
        const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        tempStream.getTracks().forEach(t => t.stop());
      } catch (e) {
        console.warn('Could not get initial audio permission:', e);
      }
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter(d => d.kind === 'audioinput');
      extDeviceSelect.innerHTML = '<option value="">– Select audio input –</option>';
      audioInputs.forEach(device => {
        const option = document.createElement('option');
        option.value = device.deviceId;
        option.textContent = device.label || `Audio Input (${device.deviceId.slice(0, 8)}...)`;
        extDeviceSelect.appendChild(option);
      });
      const storedDeviceId = localStorage.getItem(EXT_DEVICE_STORAGE_KEY);
      if (storedDeviceId) {
        const exists = audioInputs.some(d => d.deviceId === storedDeviceId);
        if (exists) extDeviceSelect.value = storedDeviceId;
      }
      extAvailable = audioInputs.length > 0;
      extWarning.style.display = extAvailable ? 'none' : 'block';
    } catch (e) {
      console.error('Device enumeration failed:', e);
      extAvailable = false;
      extWarning.style.display = 'block';
      extWarning.textContent = '⚠ Cannot enumerate devices: ' + e.message;
    }
  }

  btnExtRefresh.addEventListener('click', enumerateAudioDevices);

  // --- External Trim Control ---
  function setExtTrim(dB, save = true) {
    extTrimDb = clamp(parseFloat(dB) || EXT_TRIM_DEFAULT, -48, 24);
    extTrimRange.value = extTrimDb;
    extTrimVal.value = Math.round(extTrimDb);
    if (extTrimNode) extTrimNode.gain.value = dbToGain(extTrimDb);
    if (save) try { localStorage.setItem(EXT_TRIM_STORAGE_KEY, extTrimDb.toFixed(1)); } catch (e) {}
  }

  const storedExtTrim = localStorage.getItem(EXT_TRIM_STORAGE_KEY);
  setExtTrim(storedExtTrim !== null ? parseFloat(storedExtTrim) : EXT_TRIM_DEFAULT, false);

  extTrimRange.addEventListener('input', e => setExtTrim(e.target.value));
  extTrimVal.addEventListener('change', e => setExtTrim(e.target.value));
  extTrimVal.addEventListener('keydown', e => { if (e.key === 'Enter') { setExtTrim(e.target.value); e.target.blur(); } });
  extTrimReset.addEventListener('click', () => setExtTrim(EXT_TRIM_DEFAULT));

  // --- AudioWorklet Loading ---
  async function loadExternalWorklet() {
    if (extWorkletLoaded) return true;
    try {
      await ac.audioWorklet.addModule('external-meter-processor.js');
      extWorkletLoaded = true;
      return true;
    } catch (e) {
      console.error('Failed to load external meter processor:', e);
      extWarning.style.display = 'block';
      extWarning.textContent = '⚠ AudioWorklet unavailable: ' + e.message;
      return false;
    }
  }

  // --- External Capture ---
  async function startExternalCapture() {
    const deviceId = extDeviceSelect.value;
    if (!deviceId) {
      alert('Please select an audio input device.');
      return;
    }
    try {
      await ac.resume();
      const workletReady = await loadExternalWorklet();
      const constraints = {
        audio: {
          deviceId: { exact: deviceId },
          channelCount: 2,
          sampleRate: 48000,
          autoGainControl: false,
          noiseSuppression: false,
          echoCancellation: false
        }
      };
      extStream = await navigator.mediaDevices.getUserMedia(constraints);
      const track = extStream.getAudioTracks()[0];
      if (!track) throw new Error('No audio track available.');
      try {
        await track.applyConstraints({ autoGainControl: false, noiseSuppression: false, echoCancellation: false, channelCount: 2 });
      } catch (e) { console.warn('Could not apply all constraints:', e); }
      track.contentHint = 'music';
      extSrc = ac.createMediaStreamSource(extStream);
      extTrimNode = ac.createGain();
      extTrimNode.gain.value = dbToGain(extTrimDb);
      if (workletReady) {
        extWorkletNode = new AudioWorkletNode(ac, 'external-meter-processor', {
          numberOfInputs: 1, numberOfOutputs: 1, channelCount: 2, channelCountMode: 'explicit', processorOptions: { sendPCM: false }
        });
        extSrc.connect(extWorkletNode);
        extWorkletNode.connect(extTrimNode);
      } else {
        extSrc.connect(extTrimNode);
      }
      extSplit = connectStereoToMix(extTrimNode);
      extMonGain = ac.createGain();
      extMonGain.gain.value = 0;
      extTrimNode.connect(extMonGain).connect(ac.destination);
      // Default: muted (RED button)
      btnExtMonMute.classList.add('btn-muted');
      btnExtMonMute.classList.remove('btn-ghost');
      extMonitorMuted = true;
      const settings = track.getSettings ? track.getSettings() : {};
      const selectedOption = extDeviceSelect.options[extDeviceSelect.selectedIndex];
      extInfo.device.textContent = selectedOption ? selectedOption.textContent.slice(0, 30) : 'Unknown';
      extInfo.cc.textContent = settings.channelCount ?? 'Unknown';
      extInfo.sr.textContent = ac.sampleRate + ' Hz';
      extInfo.status.textContent = 'Active';
      document.getElementById('dbgExt').textContent = 'Yes';
      extDeviceSelect.disabled = true;
      try { localStorage.setItem(EXT_DEVICE_STORAGE_KEY, deviceId); } catch (e) {}
      activeCapture = 'external';
      updateCaptureButtons();
      updateInputSourceSummary();
    } catch (e) {
      console.error('External capture failed:', e);
      alert('Failed to start external capture: ' + e.message);
      extInfo.status.textContent = 'Error';
    }
  }

  function stopExternalCapture() {
    try { extStream && extStream.getTracks().forEach(t => t.stop()); } catch {}
    try { extSrc && extSrc.disconnect(); } catch {}
    try { extWorkletNode && extWorkletNode.disconnect(); } catch {}
    try { extTrimNode && extTrimNode.disconnect(); } catch {}
    try { extSplit && extSplit.disconnect(); } catch {}
    try { extMonGain && extMonGain.disconnect(); } catch {}
    extStream = null; extSrc = null; extWorkletNode = null; extTrimNode = null; extSplit = null; extMonGain = null;
    extMonitorMuted = true;
    btnExtMonMute.classList.add('btn-muted');
    btnExtMonMute.classList.remove('btn-ghost');
    extDeviceSelect.disabled = false;
    extInfo.device.textContent = '–';
    extInfo.cc.textContent = '–';
    extInfo.sr.textContent = '–';
    extInfo.status.textContent = '–';
    document.getElementById('dbgExt').textContent = 'No';
    if (activeCapture === 'external') activeCapture = null;
    updateCaptureButtons();
    updateInputSourceSummary();
  }

  // --- External Monitor Control ---
  function toggleExtMonitorMute() {
    if (!extMonGain) return;
    extMonitorMuted = !extMonitorMuted;
    extMonGain.gain.value = extMonitorMuted ? 0 : parseFloat(extMonGainEl.value) / 100;
    extMonVal.value = Math.round(extMonGainEl.value);
    // RED when muted, neutral when not muted
    if (extMonitorMuted) {
      btnExtMonMute.classList.add('btn-muted');
      btnExtMonMute.classList.remove('btn-ghost');
    } else {
      btnExtMonMute.classList.remove('btn-muted');
      btnExtMonMute.classList.add('btn-ghost');
    }
    updateMonitorStatusDisplay();
  }

  btnExtMonMute.addEventListener('click', toggleExtMonitorMute);
  extMonGainEl.addEventListener('input', () => {
    extMonVal.value = Math.round(extMonGainEl.value);
    if (extMonGain && !extMonitorMuted) extMonGain.gain.value = parseFloat(extMonGainEl.value) / 100;
  });
  extMonVal.addEventListener('change', e => { extMonGainEl.value = clamp(parseFloat(e.target.value) || 0, 0, 100); extMonVal.value = Math.round(extMonGainEl.value); if(extMonGain && !extMonitorMuted){ extMonGain.gain.value=parseFloat(extMonGainEl.value)/100 } });
  extMonVal.addEventListener('keydown', e => { if (e.key === 'Enter') { extMonGainEl.value = clamp(parseFloat(e.target.value) || 0, 0, 100); extMonVal.value = Math.round(extMonGainEl.value); if(extMonGain && !extMonitorMuted){ extMonGain.gain.value=parseFloat(extMonGainEl.value)/100 } e.target.blur(); } });

  navigator.mediaDevices.addEventListener('devicechange', () => {
    if (selectedInputMode === 'external') enumerateAudioDevices();
  });

  // --- Generator Capture ---
  async function startGeneratorCapture() {
    await startGenerator();
    activeCapture = 'generator';
    updateCaptureButtons();
    updateInputSourceSummary();
  }

  async function stopGeneratorCapture() {
    await stopGenerator();
    if (activeCapture === 'generator') activeCapture = null;
    updateCaptureButtons();
    updateInputSourceSummary();
  }

  // =====================================================
  // COLLAPSIBLE PANELS
  // =====================================================

  function initCollapsiblePanels() {
    const panels = document.querySelectorAll('.card.collapsible');
    const savedState = JSON.parse(localStorage.getItem(PANEL_COLLAPSE_STORAGE_KEY) || '{}');

    panels.forEach(panel => {
      const panelId = panel.dataset.panel;
      const header = panel.querySelector('h2');

      // Restore saved state (except inputSources which defaults to expanded)
      if (panelId && savedState[panelId] !== undefined) {
        if (savedState[panelId]) {
          panel.classList.add('collapsed');
        } else {
          panel.classList.remove('collapsed');
        }
      }

      // Add click handler to header
      header.addEventListener('click', () => {
        panel.classList.toggle('collapsed');
        savePanelCollapseState();
      });
    });
  }

  function savePanelCollapseState() {
    const panels = document.querySelectorAll('.card.collapsible');
    const state = {};
    panels.forEach(panel => {
      const panelId = panel.dataset.panel;
      if (panelId) {
        state[panelId] = panel.classList.contains('collapsed');
      }
    });
    try { localStorage.setItem(PANEL_COLLAPSE_STORAGE_KEY, JSON.stringify(state)); } catch (e) {}
  }

  // Initialize collapsible panels
  initCollapsiblePanels();

  // =====================================================
  // END UNIFIED INPUT SOURCE SYSTEM
  // =====================================================

  // ------- Generator -------
  // Broadcast-alignment: −18 dBFS betyder PEAK/quasi-peak nivå (EBU R68)
  // För sinus: Amplitude = 10^(-18/20) ≈ 0.126 → Peak = -18 dBFS
  // RMS blir då -21 dBFS (3 dB lägre pga crest factor √2)
  const SINE_A_FOR_MINUS18_PEAK = Math.pow(10, -18/20); // ≈ 0.126

  // Single-oscillator architecture with gain-based EBU Stereo-ID control
  // L and R come from SAME oscillator → guaranteed phase sync
  // TransitionGuard blanking hides gain-switching artifacts
  let genOsc=null, genGain=null, leftGain=null, rightGain=null, merger=null, genMonGain=null, genSplit=null;
  let monitorMuted=false;
  let ebuModeActive=false; // Track if EBU Stereo-ID is running

  // Generator presets (frekvens → badge-text)
  const genPresets = {
    '400':  '400 Hz · −18 dBFS peak (0 dBu / 0 PPM · EBU alignment)',
    '1000': '1 kHz · −18 dBFS peak (digital test tone · AES-style)',
    '997':  '997 Hz · −18 dBFS peak (FFT-optimised test tone)',
    '440':  '440 Hz · −18 dBFS peak (musical A · non-broadcast)'
  };
  const genPresetEl = document.getElementById('genPreset');
  const genBadgeEl = document.getElementById('genBadge');
  let currentGenFreq = 400; // Standard: 400 Hz (EBU broadcast line-up)

  // Uppdatera badge och frekvens vid preset-ändring
  genPresetEl.addEventListener('change', () => {
    const freq = parseInt(genPresetEl.value);
    currentGenFreq = freq;
    genBadgeEl.textContent = genPresets[freq] || genPresets['400'];
    // Om generatorn redan kör, uppdatera frekvensen live
    if (genOsc) genOsc.frequency.value = freq;
  });

  async function startGenerator(){
    await ac.resume();
    if(genOsc) return; // Already running

    // Single oscillator → split to L/R with individual gain control
    // This guarantees L and R are always phase-aligned
    genOsc = ac.createOscillator();
    genOsc.type = 'sine';
    genOsc.frequency.value = currentGenFreq;

    genGain = ac.createGain();
    genGain.gain.value = SINE_A_FOR_MINUS18_PEAK;

    // Per-channel gain for EBU Stereo-ID pulse control
    leftGain = ac.createGain();
    leftGain.gain.value = 1;
    rightGain = ac.createGain();
    rightGain.gain.value = 1;

    merger = ac.createChannelMerger(2);
    genOsc.connect(genGain);
    genGain.connect(leftGain);
    genGain.connect(rightGain);
    leftGain.connect(merger, 0, 0);
    rightGain.connect(merger, 0, 1);

    genMonGain = ac.createGain();
    genMonGain.gain.value = 0; // monitor muted default
    merger.connect(genMonGain).connect(ac.destination);

    genSplit = ac.createChannelSplitter(2);
    merger.connect(genSplit);
    genSplit.connect(mixL, 0); genSplit.connect(mixR, 1);
    genSplit.connect(kHP_L, 0); genSplit.connect(kHP_R, 1);

    genOsc.start();
    ebuModeActive = false;
    dbgGen.textContent='Yes';
    // Generator monitor ON by default (neutral button)
    btnMonMute.classList.remove('btn-muted');
    btnMonMute.classList.add('btn-ghost');
    monitorMuted = false;
  }

  async function stopGenerator(){
    try { genOsc && genOsc.stop(); } catch {}
    [genGain, leftGain, rightGain, merger, genMonGain, genSplit].forEach(n => {
      try { n && n.disconnect && n.disconnect(); } catch {}
    });
    genOsc = null; genGain = null; leftGain = null; rightGain = null;
    merger = null; genMonGain = null; genSplit = null;
    ebuModeActive = false;
    TransitionGuard.reset();
    dbgGen.textContent = 'No';
  }
  function toggleGenMonitorMute(){
    if(!genMonGain) return;
    monitorMuted = !monitorMuted; genMonGain.gain.value = monitorMuted ? 0 : parseFloat(monGainEl.value) / 100;
    monVal.value = Math.round(monGainEl.value);
    // RED when muted, neutral when not muted
    if (monitorMuted){ btnMonMute.classList.add('btn-muted'); btnMonMute.classList.remove('btn-ghost'); }
    else { btnMonMute.classList.remove('btn-muted'); btnMonMute.classList.add('btn-ghost'); }

    updateMonitorStatusDisplay();
  }
  monGainEl.addEventListener('input', ()=>{ monVal.value=Math.round(monGainEl.value); if(genMonGain && !monitorMuted){ genMonGain.gain.value=parseFloat(monGainEl.value)/100 } });
  monVal.addEventListener('change', e => { monGainEl.value = clamp(parseFloat(e.target.value) || 0, 0, 100); monVal.value = Math.round(monGainEl.value); if(genMonGain && !monitorMuted){ genMonGain.gain.value=parseFloat(monGainEl.value)/100 } });
  monVal.addEventListener('keydown', e => { if (e.key === 'Enter') { monGainEl.value = clamp(parseFloat(e.target.value) || 0, 0, 100); monVal.value = Math.round(monGainEl.value); if(genMonGain && !monitorMuted){ genMonGain.gain.value=parseFloat(monGainEl.value)/100 } e.target.blur(); } });

  // ------- Meter Mode Switcher -------
  const METER_MODE_KEY = 'tsg-meter-mode';
  const METER_BADGES = {
    tp: 'True Peak Level (dBTP)',
    rms: 'Root Mean Square Level (dBFS)',
    ppm: 'Nordic PPM Level (IEC Type I Units)'
  };

  function initMeterSwitcher() {
    const switcher = document.getElementById('meterSwitcher');
    if (!switcher) return;

    const tabs = switcher.querySelectorAll('.meter-tab');
    const panels = switcher.querySelectorAll('.meter-panel');
    const badge = document.getElementById('meterBadge');

    // Återställ sparad mode (default: tp)
    const savedMode = localStorage.getItem(METER_MODE_KEY) || 'tp';
    setMeterMode(savedMode);

    // Tab click handlers
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const mode = tab.dataset.meter;
        setMeterMode(mode);
        localStorage.setItem(METER_MODE_KEY, mode);
      });
    });

    function setMeterMode(mode) {
      // Uppdatera tabs
      tabs.forEach(tab => {
        tab.classList.toggle('active', tab.dataset.meter === mode);
      });
      // Uppdatera panels
      panels.forEach(panel => {
        panel.classList.toggle('active', panel.dataset.meter === mode);
      });
      // Uppdatera badge
      if (badge && METER_BADGES[mode]) {
        badge.textContent = METER_BADGES[mode];
      }
    }
  }

  // ------- Sidebar Collapse System -------
  const SIDEBAR_STATE_KEY = 'tsg-sidebar-collapsed';

  function initSidebarToggle() {
    const sidebarToggle = document.getElementById('sidebarToggle');
    const wrap = document.getElementById('wrap');
    const html = document.documentElement;

    // Kolla initial state (satt av inline script i <head>)
    let isCollapsed = html.classList.contains('sidebar-start-collapsed');

    // Synka wrap class med initial state
    if (isCollapsed) {
      wrap.classList.add('sidebar-collapsed');
    }

    // Aktivera transitions EFTER första renderingen (förhindrar flash)
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        html.classList.add('sidebar-ready');
        // Ta bort initial-klassen nu när wrap har rätt class
        html.classList.remove('sidebar-start-collapsed');
      });
    });

    sidebarToggle.addEventListener('click', () => {
      isCollapsed = !isCollapsed;

      // Spara state till localStorage
      localStorage.setItem(SIDEBAR_STATE_KEY, isCollapsed);

      if (isCollapsed) {
        wrap.classList.add('sidebar-collapsed');
      } else {
        wrap.classList.remove('sidebar-collapsed');
      }

      // Trigger resize event for responsive canvas elements after animation
      setTimeout(() => {
        scheduleLayoutUpdate(xyCard, layoutXY);
        scheduleLayoutUpdate(loudnessCard, layoutLoudness);
        window.dispatchEvent(new Event('resize'));
      }, 400);
    });
    
    // Keyboard shortcut: Ctrl/Cmd + B to toggle sidebar
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
        e.preventDefault();
        sidebarToggle.click();
      }
    });

    // Visa toggle vid musrörelse, göm efter 2s inaktivitet
    let hideToggleTimeout;
    const showToggle = () => {
      sidebarToggle.style.opacity = '1';
      clearTimeout(hideToggleTimeout);
      hideToggleTimeout = setTimeout(() => {
        sidebarToggle.style.opacity = '0';
      }, 2000);
    };
    document.addEventListener('mousemove', showToggle);
    document.addEventListener('mouseenter', showToggle);
  }

  // ------- Drag & Drop System -------
  let draggedElement = null;
  let dragOffset = { x: 0, y: 0 };
  let isDragging = false;
  
  // **BEST PRACTICE 2025: Drag-Aware Layout Management**
  // Prevents layout thrashing during drag operations by freezing expensive calculations
  let isDragLayoutFrozen = false;
  
  // **BEST PRACTICE 2025: Debounced ResizeObserver Pattern**
  // Prevents cascade resize events and ensures smooth performance during layout changes
  const resizeDebouncer = new Map();
  
  /**
   * Schedules layout updates using requestAnimationFrame to prevent blocking the main thread
   * @param {Element} element - The element being observed for resize
   * @param {Function} callback - The layout function to execute
   */
  function scheduleLayoutUpdate(element, callback) {
    // Cancel any pending layout update for this element
    if (resizeDebouncer.has(element)) {
      cancelAnimationFrame(resizeDebouncer.get(element));
    }
    
    // Schedule new update on next available frame
    const rafId = requestAnimationFrame(() => {
      try {
        resizeDebouncer.delete(element);
        
        // **BEST PRACTICE 2025: Performance monitoring for layout operations**
        const startTime = performance.now();
        callback();
        const endTime = performance.now();
        
        // Log performance warnings for slow layout operations (>16ms = missing 60fps)
        if (endTime - startTime > 16) {
          console.warn(`Layout operation took ${(endTime - startTime).toFixed(2)}ms - may affect 60fps performance`);
        }
        
      } catch (error) {
        console.error('Layout update failed:', error);
        // Remove failed element from debouncer to prevent stuck states
        resizeDebouncer.delete(element);
      }
    });
    
    resizeDebouncer.set(element, rafId);
  }
  
  /**
   * Canvas State Preservation Pattern for Vectorscope
   * Prevents visual "zoom-in" effects during drag operations by preserving canvas content
   */
  function preserveCanvasState() {
    // Skip if canvas isn't properly initialised
    if (!xy || !xy.width || !xy.height || !xyCtx) {
      console.debug('Canvas preservation skipped - canvas not ready');
      return () => {};
    }
    
    try {
      const canvasState = {
        width: xy.width,
        height: xy.height,
        imageData: xyCtx.getImageData(0, 0, xy.width, xy.height)
      };
      
      // **BEST PRACTICE 2025: Memory-conscious canvas handling**
      // Return restoration function with cleanup capabilities
      return () => {
        try {
          if (xy.width === canvasState.width && xy.height === canvasState.height) {
            xyCtx.putImageData(canvasState.imageData, 0, 0);
          } else {
            console.debug('Canvas dimensions changed, skipping restoration');
          }
        } catch (error) {
          console.warn('Canvas restoration failed:', error);
        }
      };
      
    } catch (error) {
      console.warn('Canvas state preservation failed:', error);
      return () => {};
    }
  }

  function initDragAndDrop() {
    const meterPanels = document.querySelectorAll('.meter');
    
    meterPanels.forEach(panel => {
      // Mouse events
      panel.addEventListener('mousedown', handleDragStart);
      panel.addEventListener('dragover', handleDragOver);
      panel.addEventListener('drop', handleDrop);
      
      // Touch events for mobile
      panel.addEventListener('touchstart', handleTouchStart);
      
      // Make draggable
      panel.draggable = true;
      panel.addEventListener('dragstart', handleDragStartNative);
    });

    // Global events
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('touchmove', handleTouchMove);
    document.addEventListener('touchend', handleTouchEnd);
  }

  function handleDragStart(e) {
    // **FIX: Only start drag on actual mouse movement, not on click**
    // Store mouse position but don't activate visual drag state yet
    const rect = e.currentTarget.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    // Store potential drag element but don't activate drag state
    draggedElement = e.currentTarget;
    
    // Don't add dragging class or freeze layout until actual movement occurs
    // This prevents static blue highlighting on simple clicks
  }

  function handleDragStartNative(e) {
    // **FIX: Clear any previous dragging states (only one panel at a time)**
    document.querySelectorAll('.meter.dragging').forEach(el => {
      el.classList.remove('dragging');
    });
    
    draggedElement = e.currentTarget;
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', e.currentTarget.outerHTML);
    
    // **BEST PRACTICE 2025: Preserve vectorscope canvas state before potential layout changes**
    const restoreCanvas = preserveCanvasState();
    
    // **BEST PRACTICE 2025: Freeze layout system to prevent visual glitches**
    isDragLayoutFrozen = true;
    
    // **FIX: Immediately activate drag state for native drag-and-drop**
    // Native drag-and-drop needs immediate visual feedback
    isDragging = true;
    
    // Delay to allow visual state to update
    setTimeout(() => {
      if (draggedElement) {
        draggedElement.classList.add('dragging');
        // Restore canvas if it was affected by the visual state change
        restoreCanvas();
      }
    }, 0);
  }

  function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    // Remove drag-over from all elements first
    document.querySelectorAll('.meter').forEach(el => {
      el.classList.remove('drag-over');
    });
    
    // Only add to current target if it's valid
    if (e.currentTarget !== draggedElement && e.currentTarget.classList.contains('meter')) {
      e.currentTarget.classList.add('drag-over');
    }
  }

  function handleDrop(e) {
    e.preventDefault();
    
    const dropTarget = e.currentTarget;
    dropTarget.classList.remove('drag-over');
    
    if (draggedElement && dropTarget !== draggedElement && dropTarget.classList.contains('meter')) {
      // Swap positions
      swapElements(draggedElement, dropTarget);
    }
    
    // **BEST PRACTICE 2025: Restore layout system after drag operation**
    isDragLayoutFrozen = false;
    
    // **FIX: Properly clean up all drag state**
    if (draggedElement) {
      draggedElement.classList.remove('dragging');
      draggedElement = null;
    }
    
    // Reset drag state
    isDragging = false;
    
    // Remove drag-over from all elements
    document.querySelectorAll('.meter').forEach(el => {
      el.classList.remove('drag-over');
    });
    
    // **BEST PRACTICE 2025: Schedule vectorscope layout update after drag completion**
    scheduleLayoutUpdate(xyCard, layoutXY);
  }

  function handleTouchStart(e) {
    const touch = e.touches[0];
    const rect = e.currentTarget.getBoundingClientRect();
    dragOffset.x = touch.clientX - rect.left;
    dragOffset.y = touch.clientY - rect.top;
    
    draggedElement = e.currentTarget;
    draggedElement.classList.add('dragging');
    isDragging = true;
    
    // **BEST PRACTICE 2025: Freeze layout during touch drag operations**
    isDragLayoutFrozen = true;
    
    e.preventDefault();
  }

  function handleDragMove(e) {
    // **FIX: Only activate drag state when actual movement occurs**
    if (!draggedElement) return;
    
    // Calculate movement distance from initial mouse position
    const rect = draggedElement.getBoundingClientRect();
    const currentX = e.clientX;
    const currentY = e.clientY;
    const initialX = rect.left + dragOffset.x;
    const initialY = rect.top + dragOffset.y;
    
    const distance = Math.sqrt(
      Math.pow(currentX - initialX, 2) + Math.pow(currentY - initialY, 2)
    );
    
    // Only activate drag state if mouse moved more than 5 pixels
    // This prevents accidental drag activation on clicks
    if (distance > 5 && !isDragging) {
      isDragging = true;
      isDragLayoutFrozen = true;
      
      // Clear any other dragging panels (only one at a time)
      document.querySelectorAll('.meter.dragging').forEach(el => {
        if (el !== draggedElement) {
          el.classList.remove('dragging');
        }
      });
      
      // Now activate visual drag state
      draggedElement.classList.add('dragging');
    }
  }

  function handleTouchMove(e) {
    if (!isDragging || !draggedElement) return;
    
    const touch = e.touches[0];
    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
    
    // Remove previous drag-over
    document.querySelectorAll('.meter').forEach(el => {
      el.classList.remove('drag-over');
    });
    
    // Add drag-over to current target
    if (elementUnderTouch && elementUnderTouch.classList.contains('meter') && elementUnderTouch !== draggedElement) {
      elementUnderTouch.classList.add('drag-over');
    }
    
    e.preventDefault();
  }

  function handleDragEnd(e) {
    // **FIX: Clean up drag state properly**
    if (draggedElement) {
      draggedElement.classList.remove('dragging');
    }
    
    // Reset all drag state variables
    draggedElement = null;
    isDragging = false;
    
    // **BEST PRACTICE 2025: Restore layout system after mouse drag**
    isDragLayoutFrozen = false;
    scheduleLayoutUpdate(xyCard, layoutXY);
  }

  function handleTouchEnd(e) {
    if (!isDragging || !draggedElement) return;
    
    const touch = e.changedTouches[0];
    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
    
    if (elementUnderTouch && elementUnderTouch.classList.contains('meter') && elementUnderTouch !== draggedElement) {
      swapElements(draggedElement, elementUnderTouch);
    }
    
    // Clean up
    draggedElement.classList.remove('dragging');
    document.querySelectorAll('.meter').forEach(el => {
      el.classList.remove('drag-over');
    });
    
    draggedElement = null;
    isDragging = false;
    
    // **BEST PRACTICE 2025: Restore layout system after touch drag**
    isDragLayoutFrozen = false;
    scheduleLayoutUpdate(xyCard, layoutXY);
  }

  function swapElements(el1, el2) {
    // Add transition class for smooth animation
    el1.classList.add('transitioning');
    el2.classList.add('transitioning');
    
    // Create temporary placeholder
    const temp = document.createElement('div');
    temp.style.display = 'none';
    
    // Insert temp before el1
    el1.parentNode.insertBefore(temp, el1);
    
    // Move el1 to where el2 is
    el2.parentNode.insertBefore(el1, el2);
    
    // Move el2 to where el1 was (temp position)
    temp.parentNode.insertBefore(el2, temp);
    
    // Remove temp
    temp.remove();
    
    // Remove transition class after animation
    setTimeout(() => {
      el1.classList.remove('transitioning');
      el2.classList.remove('transitioning');
    }, 400);
  }

  // ------- SEPARATED MEASUREMENT & RENDERING LOOPS -------
  // Best Practice 2025: Measurement runs on setInterval (not throttled by Chrome)
  // Rendering runs on requestAnimationFrame (GPU-efficient, pauses when hidden)

  let startTs = performance.now();
  let leftMuteTimer = 0;
  let lastMeasureTime = 0;
  let ebuPrevState = true; // Track previous L state for transition detection
  const MEASURE_INTERVAL_MS = 50; // 20 Hz measurement rate (sufficient for 400ms LUFS window)

  /**
   * Sample analysers into shared buffers
   * Called by measureLoop to ensure fresh data for DSP calculations
   */
  function sampleAnalysers() {
    analyserL.getFloatTimeDomainData(bufL);
    analyserR.getFloatTimeDomainData(bufR);
  }

  /**
   * Measurement Loop - Runs via setInterval, NOT throttled by Chrome in background tabs
   * Critical for: LUFS accumulation, radar history, stereo analysis
   */
  function measureLoop() {
    const now = performance.now();
    const dt = now - lastMeasureTime;
    lastMeasureTime = now;

    // EBU Stereo-ID pulse timing - gain-based control with TransitionGuard blanking
    // Single oscillator ensures L/R phase sync; blanking hides gain-switch artifacts
    if (muteLeft.checked && leftGain) {
      ebuModeActive = true;
      leftMuteTimer += dt;
      const EBU_PERIOD_MS = 3000;
      const EBU_MUTE_MS = 250;
      const shouldBeOn = (leftMuteTimer % EBU_PERIOD_MS) >= EBU_MUTE_MS;

      // Detect state transition and trigger blanking
      if (shouldBeOn !== ebuPrevState) {
        TransitionGuard.trigger();
        // Use setValueAtTime for immediate gain change (block-aligned)
        const target = shouldBeOn ? 1 : 0;
        leftGain.gain.setValueAtTime(target, ac.currentTime);
        ebuPrevState = shouldBeOn;
      }
    } else if (ebuModeActive && !muteLeft.checked) {
      // EBU mode was just disabled - ensure L is full volume
      ebuModeActive = false;
      if (leftGain) {
        leftGain.gain.setValueAtTime(1, ac.currentTime);
      }
    }

    // Critical measurements that must run continuously:
    // NOTE: bufL/bufR are sampled by renderLoop. StereoAnalysisEngine uses
    // slightly stale data when in background, which is acceptable for slow
    // statistics like width/M/S/rotation.
    updateR128();  // Uses separate K-weighted buffers (kBufL/kBufR)
    StereoAnalysisEngine.analyze(bufL, bufR);  // Uses renderLoop's buffers
  }

  /**
   * Render Loop - Runs via requestAnimationFrame, pauses in background (saves GPU)
   * Handles all visual updates and layout calculations
   *
   * CRITICAL: Sample L/R analysers ONCE at the start of each frame.
   * All rendering functions use these shared buffers (bufL/bufR).
   * This ensures L and R are always from the SAME audio block → no oval artifacts.
   */
  function renderLoop() {
    // Layout calculations (only when visible)
    layoutXY();
    layoutLoudness();

    // CRITICAL: Sample analysers ONCE per frame into shared buffers
    // L and R are read back-to-back with NO intervening code → sample-synced
    sampleAnalysers();

    // Visual meter updates - all use shared bufL/bufR, no redundant reads
    updatePPM();
    drawXY();
    drawCorr();
    drawMonoDev();
    drawDBFS();
    drawTruePeak();

    // Stereo analysis visualization (uses cached values from measureLoop)
    updateStereoAnalysis();

    // Loudness radar visualization
    const mVal = parseFloat(lufsM && lufsM.dataset.v);
    drawLoudnessRadar(isFinite(mVal) ? mVal : undefined);

    // Uptime display (HH:MM:SS.M format)
    const uptimeSec = (performance.now() - startTs) / 1000;
    const h = Math.floor(uptimeSec / 3600);
    const m = Math.floor((uptimeSec % 3600) / 60);
    const s = Math.floor(uptimeSec % 60);
    const ms = Math.floor((uptimeSec * 10) % 10);
    uptimeEl.textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${ms}`;

    requestAnimationFrame(renderLoop);
  }

  // Start both loops
  lastMeasureTime = performance.now();
  setInterval(measureLoop, MEASURE_INTERVAL_MS);  // Measurement: 20 Hz, runs in background
  requestAnimationFrame(renderLoop);               // Rendering: 60 Hz, pauses in background

  // **BEST PRACTICE 2025: Modern ResizeObserver Implementation**
  // Replaces multiple observers with debounced, scheduled updates to prevent cascade resize events
  
  /**
   * Intersection Observer for Visibility-Based Updates
   * Only triggers layout updates when elements are actually visible to user
   */
  const visibilityObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting && !isDragLayoutFrozen) {
        if (entry.target === xyCard) {
          scheduleLayoutUpdate(entry.target, layoutXY);
        }
        if (entry.target === loudnessCard) {
          scheduleLayoutUpdate(entry.target, layoutLoudness);
        }
      }
    });
  }, {
    // Trigger when at least 10% of the element is visible
    threshold: 0.1
  });
  
  /**
   * Modern ResizeObserver with Debouncing
   * Prevents layout thrashing by using scheduled updates
   */
  const modernResizeObserver = new ResizeObserver((entries) => {
    entries.forEach(entry => {
      // Only process if not currently dragging
      if (!isDragLayoutFrozen) {
        // Call appropriate layout function based on target
        if (entry.target === xyCard || entry.target === meters) {
          scheduleLayoutUpdate(entry.target, layoutXY);
        }
        if (entry.target === loudnessCard || entry.target === meters) {
          scheduleLayoutUpdate(entry.target, layoutLoudness);
        }
      }
    });
  });

  // Observe key elements with modern pattern
  modernResizeObserver.observe(meters);
  modernResizeObserver.observe(xyCard);
  modernResizeObserver.observe(loudnessCard);
  visibilityObserver.observe(xyCard);
  visibilityObserver.observe(loudnessCard);

  // ------- Bind -------
  btnMonMute.onclick = toggleGenMonitorMute; btnSysMonMute.onclick = toggleSysMonitorMute;

  // ------- Boot: ingen auto-ton, allt muted default -------
  let booted=false; async function boot(){ if(booted) return; booted=true; await ac.resume(); }
  ['pointerdown','click','keydown','touchstart'].forEach(evt=>window.addEventListener(evt, boot, { once:true, passive:true }));
  
  // Initialize systems
  initSidebarToggle();
  initDragAndDrop();
  initMeterSwitcher();

  // --- Metering Settings ---
  const targetPresetEl = document.getElementById('targetPreset');
  const tpLimitEl = document.getElementById('tpLimit');
  const radarSweepEl = document.getElementById('radarSweep');

  const SETTINGS_KEYS = {
    target: 'tsg-loudness-target',
    tpLimit: 'tsg-tp-limit',
    sweep: 'tsg-radar-sweep'
  };

  function loadSettings() {
    const savedTarget = localStorage.getItem(SETTINGS_KEYS.target);
    const savedTpLimit = localStorage.getItem(SETTINGS_KEYS.tpLimit);
    const savedSweep = localStorage.getItem(SETTINGS_KEYS.sweep);

    if (savedTarget) {
      LOUDNESS_TARGET = parseFloat(savedTarget);
      targetPresetEl.value = savedTarget;
    }
    if (savedTpLimit) {
      TP_LIMIT = parseFloat(savedTpLimit);
      tpLimitEl.value = savedTpLimit;
      updateTpLimitDisplay();
    }
    if (savedSweep) {
      radarMaxSeconds = parseInt(savedSweep);
      radarSweepEl.value = savedSweep;
    }
  }

  targetPresetEl.addEventListener('change', () => {
    LOUDNESS_TARGET = parseFloat(targetPresetEl.value);
    localStorage.setItem(SETTINGS_KEYS.target, targetPresetEl.value);
    resetR128();
  });

  tpLimitEl.addEventListener('change', () => {
    TP_LIMIT = parseFloat(tpLimitEl.value);
    localStorage.setItem(SETTINGS_KEYS.tpLimit, tpLimitEl.value);
    tpOverFlag = false;
    updateTpLimitDisplay();
  });

  radarSweepEl.addEventListener('change', () => {
    radarMaxSeconds = parseInt(radarSweepEl.value);
    localStorage.setItem(SETTINGS_KEYS.sweep, radarSweepEl.value);
    radarHistory.length = 0;
    lastRadarTime = 0;
    lastRadarValue = -Infinity;
  });

  loadSettings();
  
  // **BEST PRACTICE 2025: Cleanup Functions for Memory Management**
  // Proper cleanup prevents memory leaks in long-running applications
  
  /**
   * Cleanup function for when the application is unloaded
   * Cancels all pending animations and disconnects observers
   */
  function cleanup() {
    // Cancel all pending layout updates
    resizeDebouncer.forEach((rafId) => {
      cancelAnimationFrame(rafId);
    });
    resizeDebouncer.clear();
    
    // Disconnect observers
    if (modernResizeObserver) {
      modernResizeObserver.disconnect();
    }
    if (visibilityObserver) {
      visibilityObserver.disconnect();
    }
    
    console.debug('TSG Audio Meters: Cleanup completed');
  }
  
  // Register cleanup for page unload
  window.addEventListener('beforeunload', cleanup);
  
  // **DEVELOPMENT MODE: Performance monitoring and debugging**
  if (typeof window !== 'undefined' && window.location?.hostname === 'localhost') {
    // Enable performance monitoring in development
    console.log('TSG Audio Meters: Development mode active');
    console.log('- Drag-aware layout system: ✓');
    console.log('- Modern ResizeObserver pattern: ✓');
    console.log('- CSS Container Queries: ✓');
    console.log('- Canvas state preservation: ✓');
    console.log('- Memory cleanup handlers: ✓');
  }
})();
</script>
</body>
</html>          