<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TSG Suite | VEROBAAMBI</title>
  <style>
    :root{
      --bg:#141618; --panel:#1b1f23; --ink:#e8eef9; --muted:#a9b2c7; --outline:#2a2f36; --grid:#29323b;
      --ok:#58d38c; --warn:#ffde58; --caution:#ff9a2d; --hot:#ff5a63; --cyan:#69bfff;
      --btn:#2d6bff; --btn-dark:#1e4edd; --btn-ghost:#0b1222;
      --meter-gap: 1.2em;
      /* **BEST PRACTICE 2025: Modern CSS Custom Properties for Performance** */
      /* Centralised values for consistent theming and easy maintenance */
      --drag-transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --canvas-border-radius: 10px;
      --vectorscope-min-size: 160px;
      --resize-debounce-delay: 16ms; /* ~60fps */
      --visibility-threshold: 0.1; /* 10% visibility for intersection observer */
    }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
    header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,rgba(20,22,24,.95),rgba(20,22,24,.6));backdrop-filter:saturate(140%) blur(8px);border-bottom:1px solid var(--outline)}
    h1{margin:0;padding:16px 20px;font-size:16px;letter-spacing:.3px}
    /* Loudness Radar Panel (RTW/TC style) */
    .loudnessRadarModule {
  display: flex;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  height: 100%;
  gap: 2.5vw;
  min-height: 0;
  position: relative;
  min-width: 0;
    }
    .loudnessRadarModule .canvasPad {
  flex: 1 1 0;
  min-width: 180px;
  max-width: 420px;
  aspect-ratio: 1/1;
  margin: 0;
  background: none;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
    }
    #loudnessRadar {
      width: 100%;
      height: auto;
      aspect-ratio: 1/1;
      background: #181c20;
      border-radius: 50%;
      border: 2px solid var(--outline);
      box-shadow: 0 4px 24px rgba(0,0,0,0.25);
      display: block;
      max-width: 340px;
      min-width: 120px;
      min-height: 120px;
    }
    .r128-subpanel {
  flex: 1 1 220px;
  min-width: 200px;
  max-width: 320px;
  background: rgba(20,22,24,0.92);
  border-radius: 10px;
  border: 1px solid var(--outline);
  box-shadow: 0 2px 8px rgba(0,0,0,0.10);
  padding: 12px 16px 10px 16px;
  margin-top: 0;
  font-size: 15px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  justify-content: flex-start;
    }
    .r128-subpanel header {
  font-size: 13px;
  color: var(--muted);
  margin-bottom: 4px;
  font-weight: 700;
  letter-spacing: .2px;
  display: flex;
  align-items: center;
  gap: 8px;
    }

    @container (max-width: 420px) {
      .loudnessRadarModule {
        flex-direction: column;
        align-items: center;
          /* LUFS value in radar center */
        }
        .loudnessRadarModule .canvasPad .radar-lufs-value {
          position: absolute;
          left: 0; right: 0; top: 0; bottom: 0;
          display: flex;
          align-items: center;
          justify-content: center;
          pointer-events: none;
          font-size: clamp(2.2rem, 6vw, 4.5rem);
          font-weight: 800;
          color: var(--cyan);
          text-shadow: 0 2px 12px #000, 0 0 2px #69bfff;
          letter-spacing: 0.5px;
          z-index: 2;
      }
      .loudnessRadarModule .canvasPad { max-width: 180px; }
      #loudnessRadar { max-width: 180px; min-width: 80px; min-height: 80px; }
      .r128-subpanel { width: 100%; }
    }

    .wrap{
      box-sizing:border-box;
      padding:20px;
      display:grid;
      gap:16px;
      grid-template-columns: var(--sidebar-width, 360px) 1fr;
      grid-template-rows: 1fr; 
      height:calc(100dvh - 56px);
      transition: grid-template-columns 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    .wrap.sidebar-collapsed {
      grid-template-columns: 0 1fr;
      gap: 0;
      padding: 20px;
    }
    
    .wrap.sidebar-collapsed .visning {
      margin: 0;
    }
    
    .wrap.sidebar-collapsed .sidebar-container {
      position: absolute;
      left: 0;
      top: 0;
      width: 48px;
      height: 100%;
      z-index: 50;
    }
    
    /* Sidebar Collapse System */
    .sidebar-container {
      position: relative;
      overflow: hidden;
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    .sidebar-content {
      display: grid;
      gap: 16px;
      grid-template-rows: 2fr 1fr 1fr;
      height: 100%;
      transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.3s ease;
    }
    
    .sidebar-collapsed .sidebar-content {
      transform: translateX(-100%);
      opacity: 0;
      pointer-events: none;
    }
    
    .collapse-toggle {
      position: fixed;
      left: calc(var(--sidebar-width, 360px) + 20px - 24px);
      transform: translateY(-50%);
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--panel), rgba(147, 197, 253, 0.1));
      border: 1px solid var(--outline);
      border-radius: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 4px 16px rgba(0,0,0,.25);
    }
    
    .sidebar-collapsed .collapse-toggle {
      left: calc(0px + 20px - 24px);
    }
    
    .collapse-toggle:hover {
      background: linear-gradient(135deg, rgba(147, 197, 253, 0.2), rgba(34, 211, 238, 0.1));
      box-shadow: 0 6px 24px rgba(0,0,0,.35), 0 0 16px rgba(147, 197, 253, 0.3);
      transform: translateY(-50%) scale(1.05);
      border-color: rgba(147, 197, 253, 0.5);
    }
    
    .collapse-toggle svg {
      width: 20px;
      height: 20px;
      fill: var(--ink);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .sidebar-collapsed .collapse-toggle svg {
      transform: rotate(180deg);
    }
    
    .collapse-toggle:hover svg {
      fill: rgba(147, 197, 253, 0.9);
    }
    .card{background:var(--panel);border:1px solid var(--outline);border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.25);padding:14px;min-height:0;overflow:hidden}
    .card h2{margin:0 0 10px;font-size:13px;color:var(--muted);letter-spacing:.35px;font-weight:700;text-transform:uppercase}

    .visning{
      grid-column:2;
      grid-row:1;
      display:grid;
      grid-template-rows:auto 1fr;
      gap:12px;
      min-height:0;
      transition: margin 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      margin-right: 0;
    }

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{background:var(--btn);border:0;color:white;padding:9px 12px;border-radius:11px;font-weight:700;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    .btn-ghost{background:var(--btn-ghost);color:var(--ink);border:1px solid #2a3a5f}
    .btn-active{background:var(--btn-dark)}

    label{font-size:12px;color:var(--muted)}
    code.small{font-size:12px;color:var(--muted)}

    /* Visning */
    .meters{display:grid;grid-template-columns:7fr 3fr;grid-template-rows:1fr;height:100%;gap:12px;min-height:0;overflow:hidden}
    .stack-left{
      display: grid;
      grid-template-rows: 2fr 1fr 1fr 1fr;  /* Loudness 2fr, RMS/TP/VU 1fr vardera */
      gap: 12px;
      min-height: 0;
      align-items: stretch;
      grid-auto-rows: 1fr;
      height: 100%;
    }
    .stack-right{display:grid;grid-template-rows:1fr;gap:12px;min-height:0}
    .meter{
      background: #111416;
      border: 1px solid var(--outline);
      border-radius: 12px;
      padding: var(--meter-gap) 2vw;
      position: relative;
      min-height: 0;
      display: flex;
      flex-direction: column;
      flex: 1 1 0;
      height: 100%;
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }
    .meter header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--meter-gap);
    }
    .badge{font-size:11px;padding:3px 8px;border-radius:999px;border:1px solid var(--outline);background:#0f1214;color:#cfe1ff}
    .tiny{opacity:.85;font-size:12px}

    canvas{display:block;width:100%;height:160px;background:#0d0f11;border-radius:10px;border:1px solid var(--outline)}

/* XY + Corr (vertikal layout: goniometer ovan, correlation under) */
.xyGrid {
  display: flex;
  flex-direction: column;
  gap: 12px;
  align-items: center;
  justify-content: flex-start;
  width: 100%;
  height: 100%;
}

.xySquare, .corrWrap {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-width: 0;
}

/* Goniometer: kvadratisk, tar mesta utrymmet */
.xySquare {
  flex: 3 1 0;
  aspect-ratio: 1;
  width: 100%;
  max-width: 100%;
  min-height: 160px;
  margin: 0 auto;
}

/* Correlation: horisontell bar under goniometern */
.corrWrap {
  flex: 1 1 0;
  width: 100%;
  min-height: 80px;
  max-height: 120px;
  aspect-ratio: auto;
}

.corrWrap .canvasPad {
  height: 100%;
  width: 100%;
  display: flex;
  align-items: stretch;
  justify-content: stretch;
}

#corr {
  height: 100% !important;
  width: 100% !important;
  display: block;
}

.xySquare .overlay {
  position: absolute;
  left: 50%;
  bottom: 8px;
  transform: translateX(-50%);
  z-index: 2;
  pointer-events: none;
}

.corrWrap .overlay {
  position: absolute;
  left: 50%;
  bottom: 8px;
  transform: translateX(-50%);
  z-index: 2;
  pointer-events: none;
}    
    /* **BEST PRACTICE 2025: CSS Container Queries for Responsive Design** */
    /* Modern approach to responsive layouts that responds to container size, not viewport */
    .xyModule {
      container-type: inline-size;
      container-name: vectorscope;
    }
    
    /* Responsive layout adjustments based on container width */
    @container vectorscope (min-width: 400px) {
      .xyGrid {
        grid-template-columns: 2fr 1fr;
        gap: 12px;
      }
    }

    .xySquare {
      position: relative;
      aspect-ratio: 1;
      height: 100%;
      max-height: 100%;
      min-height: 0;
      margin: 0 auto;
    }
    .canvasPad {
      width: 100%;
      height: 100%;
      position: relative;
    }
    .canvasPad > canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      border: 1px solid var(--outline);
      background: #0d0f11;
      box-sizing: border-box;
    }

    /* Horisontella stapel-metrar */
    .hMeter{position:relative;height:100%;min-height:80px;margin-bottom: var(--meter-gap);}
    .hMeter canvas{position:absolute;inset:0;width:100%;height:100%}
    .hScale{position:absolute;inset:0;pointer-events:none}
    .hLabel{position:absolute;bottom:4px;left:8px;font-size:11px;color:#cfe1ff;background:rgba(0,0,0,.25);padding:2px 6px;border-radius:8px;border:1px solid #2a2f36}

    .overlay{position:absolute;left:10px;bottom:8px;background:rgba(0,0,0,.25);padding:2px 6px;border-radius:8px;font-size:12px;color:#cfe1ff;border:1px solid #2a2f36;text-align:left}
    .gonio-overlay{left:auto;right:10px}

    /* R128 – sifferpanel */
    .r128{display:grid;grid-template-columns:1fr;gap:8px}
    .r128 .row{justify-content:space-between}
    .r128 .big{font-size:26px;font-weight:800;letter-spacing:.3px}
    .r128 small{color:#a9b2c7}

    .kv{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:8px}
    .kv div{background:#0f1214;border:1px solid var(--outline);border-radius:9px;padding:6px 8px}
    .kv small{display:block;font-size:11px;color:#a9b2c7}
    .kv .wide{grid-column:span 2}

    input[type="number"]{width:78px;background:#0f1214;border:1px solid #2a2f36;border-radius:8px;color:var(--ink);padding:6px}
    .hdr{display:flex;align-items:center;justify-content:space-between;padding:6px 20px}
    .brand{flex:1 1 60%;min-width:480px}
    .brand svg{display:block;height:64px;width:100%}
    .status{color:var(--muted);font-weight:600;margin-left:8px;white-space:nowrap}
    .brand svg{display:block;height:60px;width:auto}
    .status{color:var(--muted);font-weight:600;margin-left:8px;white-space:nowrap}

    .canvasPad {
      width: 100%;
      height: 100%;
      padding-top: 16px;
      padding-bottom: 16px;
      box-sizing: border-box;
      position: relative;
    }
    .canvasPad > canvas {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 10px;
      border: 1px solid var(--outline);
      background: #0d0f11;
    }

    /* Divider/linje under rubrik */
    .meter .divider {
      border: none;
      border-top: 1px solid var(--outline);
      margin: 0 0 var(--meter-gap) 0;
      width: 100%;
      background: none;
    }
    /* Modul styles */
    .xyModule {
      height: 100%;
      display: flex;
      align-items: center;
      background: none;
      min-height: 0;
      padding: var(--meter-gap);
    }
    .hMeter {
      position: relative;
      height: 160px;
      margin-bottom: var(--meter-gap);
    }

    /* Drag & Drop Responsive Panels */
    .meter {
      cursor: grab;
    }

    .meter.dragging {
      cursor: grabbing;
        transition: var(--drag-transition);
        position: relative;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      .meter:hover {
        box-shadow: 0 8px 32px rgba(0,0,0,.4), 0 0 20px rgba(147, 197, 253, 0.3);
        border-color: rgba(147, 197, 253, 0.5);
        background: linear-gradient(135deg, var(--panel), rgba(147, 197, 253, 0.03));
      }

      .meter:hover h2 {
        color: rgba(147, 197, 253, 0.9);
        text-shadow: 0 0 8px rgba(147, 197, 253, 0.3);
      }

      .meter.dragging {
        cursor: grabbing;
        transform: scale(0.95);
        box-shadow: 0 16px 48px rgba(0,0,0,.6), 0 0 32px rgba(147, 197, 253, 0.2);
        border: 2px solid rgba(147, 197, 253, 0.3);
        z-index: 1000;
        background: linear-gradient(135deg, var(--panel), rgba(147, 197, 253, 0.02));
      }

      .meter.dragging::before {
        content: '';
        position: absolute;
        inset: -2px;
        border-radius: 16px;
        background: linear-gradient(45deg, rgba(147, 197, 253, 0.3), rgba(34, 211, 238, 0.3));
        z-index: -1;
        filter: blur(8px);
      }

      .meter.drag-over {
        border: 2px dashed rgba(147, 197, 253, 0.6);
        background: rgba(147, 197, 253, 0.05);
        animation: pulse-glow 1s ease-in-out infinite alternate;
      }

      .meter.transitioning {
        transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }

      @keyframes pulse-glow {
        0% { box-shadow: 0 0 16px rgba(147, 197, 253, 0.3); }
        100% { box-shadow: 0 0 24px rgba(147, 197, 253, 0.5); }
      }
  </style>
</head>
<body>
<header>
  <div class="hdr">
    <div class="brand">
      <!-- Vector logotyp: VEROBAAMBI utan mellanrum, BAAMBI tätare -->
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 4000 200"
     width="100%" height="auto"
     preserveAspectRatio="xMidYMid meet"
     role="img"
     aria-label="TSG Suite | VEROBAAMBI | Broadcast Audio Alignment & Meter Bridge Interface">
  <defs>
    <linearGradient id="lock-cyan" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="#38BDF8"/>
      <stop offset="1" stop-color="#22D3EE"/>
    </linearGradient>
  </defs>

  <text x="2%" y="50%" dominant-baseline="middle"
        font-family="Inter, Segoe UI, system-ui, -apple-system, Roboto, sans-serif"
        font-size="100">

    <!-- TSG Suite i samma cyan som tagline -->
    <tspan fill="#93C5FD" font-weight="800" letter-spacing="0.75">TSG Suite</tspan>

    <!-- separator -->
    <tspan fill="#6B7280" font-weight="300" dx="1.2em">|</tspan>

    <!-- VERO = extra bold -->
    <tspan fill="#E5E7EB" font-weight="950" letter-spacing="4" dx="1.2em">VERO</tspan>
    <!-- BAAMBI = väldigt tunn och tight -->
    <tspan fill="#E5E7EB" font-weight="200" letter-spacing="-3">BAAMBI</tspan>

    <!-- separator -->
    <tspan fill="#6B7280" font-weight="300" dx="1.2em">|</tspan>

    <!-- Tagline i samma cyan som TSG Suite -->
    <tspan fill="#93C5FD" font-weight="600" font-size="75" letter-spacing="2.5" dx="1.2em">
      Broadcast Audio Alignment &amp; Meter Bridge Interface
    </tspan>
  </text>
</svg>
    </div>
  </div>
</header>

<div id="wrap" class="wrap">
  <div class="sidebar-container">
    <div class="sidebar-content">
      <section class="card leftTop">
        <h2>System / Chrome tab</h2>
        <div class="row">
          <button id="btnTab">Start capture</button>
          <button id="btnStop" class="btn-ghost" disabled>Stop capture</button>
        </div>
        <p class="tiny">Captures via <code class="small">getDisplayMedia({audio:true})</code>. <b>Default:</b> monitoring OFF.</p>
        <div class="row" style="margin-top:6px;align-items:center">
          <label>System monitor:</label>
          <input type="range" id="sysMonGain" min="0" max="1" step="0.01" value="0.20" />
          <span id="sysMonVal" class="tiny">0.20</span>
          <button id="btnSysMonMute" class="btn-ghost">Unmute system monitor</button>
          <span id="sysMonState" class="tiny">(muted)</span>
        </div>
        <div class="row" style="align-items:center">
          <label>Line-up (Chrome, dB):</label>
          <input type="range" id="sysTrimRange" min="-48" max="24" step="0.1" value="0" />
          <input type="number" id="sysTrimInput" min="-48" max="24" step="0.1" value="0.0" />
          <span class="tiny" id="sysTrimOut">0.0 dB</span>
          <button id="sysTrimReset" class="btn-ghost" style="white-space:nowrap">Reset 0 dB</button>
        </div>
        <div class="kv" id="info">
          <div><small>Source</small><span id="srcKind">–</span></div>
          <div><small>Channel count</small><span id="cc">–</span></div>
          <div><small>Sample rate</small><span id="sr">–</span></div>
          <div><small>Stereo OK?</small><span id="stOK">–</span></div>
        </div>
        <p class="tiny">Tip: avoid feedback. Do <i>not</i> share this tab if you intend to enable the system monitor.</p>
      </section>

      <section class="card leftBottom">
        <h2>Internal test tone generator</h2>
        <div class="row" style="align-items:center">
          <button id="btnTone">Start/Stop tone</button>
          <label><input type="checkbox" id="muteLeft"> Mute left 0.5 s every 1.5 s</label>
          <span class="badge">440 Hz · −18 dBFS RMS (0 VU)</span>
        </div>
        <div class="row" style="margin-top:6px;align-items:center">
          <label>Generator monitor:</label>
          <input type="range" id="monGain" min="0" max="1" step="0.01" value="0.20" />
          <span id="monVal" class="tiny">0.20</span>
          <button id="btnMonMute" class="btn-ghost">Unmute generator monitor</button>
          <span id="monState" class="tiny">(muted)</span>
        </div>
      </section>

      <section class="card leftFooter">
        <h2>Status & live data</h2>
        <div class="kv">
          <div><small>Uptime (s)</small><span id="uptime">0.0</span></div>
          <div><small>AudioContext</small><span id="ctxState">–</span></div>
          <div><small>Tone running</small><span id="dbgGen">no</span></div>
          <div><small>Tab capture running</small><span id="dbgTab">no</span></div>
          <div class="wide"><small>Monitor status</small><span id="monitorStatus" class="tiny">System monitor: <b>OFF</b> (default)<br>Generator monitor: <b>ON</b> (default)</span></div>
        </div>
      </section>
    </div>
    
    <div class="collapse-toggle" id="sidebarToggle">
      <svg viewBox="0 0 24 24">
        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
      </svg>
    </div>
  </div>

  <section class="card visning">
    <h2>Meters</h2>
    <div class="meters" id="meters">
      <div class="stack-left">
        <div class="meter" id="loudnessRadarCard">
<header><label>Loudness</label><span class="badge">Radar + EBU R128</span></header>
          <div class="loudnessRadarModule">
            <!-- Radar canvas will be implemented here -->
            <div class="canvasPad">
              <canvas id="loudnessRadar"></canvas>
              <div class="radar-lufs-value" id="radarLufsValue">—</div>
            </div>
            <!-- Sub-panel: existing R128 loudness panel -->
            <div class="r128-subpanel">
              <header><label>Loudness (EBU R128, Integrated LUFS)</label><span class="badge">M/S/I + LRA</span></header>
              <div class="r128">
                <div class="row"><small>Momentary (400 ms)</small><span class="big" id="lufsM">—</span></div>
                <div class="row"><small>Short-term (3 s)</small><span class="big" id="lufsS">—</span></div>
                <div class="row"><small>Integrated (gated)</small><span class="big" id="lufsI">—</span></div>
                <div class="row"><small>LRA (last ~60 s)</small><span class="big" id="lra">—</span></div>
              </div>
            </div>
          </div>
        </div>
        <div class="meter" id="dbfsCard">
          <header><label>RMS (dBFS)</label><span class="badge">Ref TEST −18 dBFS</span></header>
          <div class="hMeter">
            <canvas id="dbfs" height="160"></canvas>
            <div class="hScale" id="dbfsScale"></div>
            <span class="hLabel" id="dbfsLabel">L: <b id="dbL">—</b> · R: <b id="dbR">—</b> dBFS</span>
          </div>
        </div>
        <div class="meter" id="tpCard">
          <header><label>True Peak (dBTP)</label><span class="badge">4× oversample · TEST −15 dBTP</span></header>
          <div class="hMeter">
            <canvas id="tp" height="160"></canvas>
            <div class="hScale" id="tpScale"></div>
            <span class="hLabel" id="tpLabel">L: <b id="tpL">—</b> · R: <b id="tpR">—</b> dBTP</span>
          </div>
        </div>
        <div class="meter" id="ppmCard">
          <header><label>Nordic PPM</label><span class="badge">IEC Type I · TEST = 0 dBu = −18 dBFS</span></header>
          <div class="hMeter">
            <canvas id="ppmCanvas" height="160"></canvas>
            <div class="hScale" id="ppmScale"></div>
            <span class="hLabel" id="ppmLabel">L: <b id="ppmLVal">—</b> · R: <b id="ppmRVal">—</b> dB</span>
          </div>
        </div>
      </div>
      <div class="stack-right">
        <div class="meter" id="xyCard">
          <header><label>Stereo Vectorscope (Goniometer + Phase Correlation)</label></header>
          <div class="xyModule">
            <div class="xyGrid">
              <div class="xySquare" id="xyWrap">
                <div class="canvasPad"><canvas id="xy"></canvas></div>
                <div class="overlay gonio-overlay">Mono = 45°</div>
              </div>
              <div class="corrWrap">
                <div class="canvasPad"><canvas id="corr"></canvas></div>
                <div class="overlay">ρ = <b id="corrVal">0.00</b></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
</div>

<script>
(async function(){

  // =====================================================
  // LOUDNESS RADAR MODULE (RTW/TC Electronic Style)
  // =====================================================
  const LoudnessRadar = (function() {
    'use strict';
    
    function lufsToRadius(lufs, rOuter, rInner) {
      const minLufs = -60;
      const maxLufs = -9;
      const clamped = Math.max(minLufs, Math.min(maxLufs, lufs));
      const normalized = (clamped - minLufs) / (maxLufs - minLufs);
      return rInner + (rOuter - rInner) * normalized;
    }
    
    function getLoudnessColor(lufs) {
      if (lufs >= -9)  return '#ff5a63';
      if (lufs >= -14) return '#ff9a2d';
      if (lufs >= -18) return '#ffde58';
      if (lufs >= -23) return '#58d38c';
      if (lufs >= -30) return '#69bfff';
      if (lufs >= -42) return '#5a7a9a';
      return '#3a4855';
    }
    
    function drawRadarBackground(ctx, cx, cy, rOuter, rInner) {
      ctx.save();
      const gradient = ctx.createRadialGradient(cx, cy, rInner, cx, cy, rOuter);
      gradient.addColorStop(0, '#0a0c0e');
      gradient.addColorStop(1, '#181c20');
      ctx.beginPath();
      ctx.arc(cx, cy, rOuter, 0, 2 * Math.PI);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.strokeStyle = '#2a2f36';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, cy, rInner, 0, 2 * Math.PI);
      ctx.fillStyle = '#0d0f11';
      ctx.fill();
      ctx.strokeStyle = '#1a1e22';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }
    
    function drawRadarGrid(ctx, cx, cy, rOuter, rInner) {
      ctx.save();
      const refLevels = [
        { lufs: -9,  color: '#ff9a2d', alpha: 0.5 },
        { lufs: -18, color: '#69bfff', alpha: 0.7 },
        { lufs: -23, color: '#58d38c', alpha: 0.6 },
        { lufs: -30, color: '#6b7280', alpha: 0.4 }
      ];
      refLevels.forEach(ref => {
        const r = lufsToRadius(ref.lufs, rOuter, rInner);
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, 2 * Math.PI);
        ctx.strokeStyle = ref.color;
        ctx.lineWidth = (ref.lufs === -23) ? 2 : 1;
        ctx.globalAlpha = ref.alpha;
        ctx.stroke();
      });
      ctx.globalAlpha = 0.2;
      ctx.strokeStyle = '#3a4855';
      ctx.lineWidth = 1;
      for (let i = 0; i < 12; i++) {
        const angle = (i * 30) * Math.PI / 180;
        ctx.beginPath();
        ctx.moveTo(cx + rInner * Math.cos(angle), cy + rInner * Math.sin(angle));
        ctx.lineTo(cx + rOuter * Math.cos(angle), cy + rOuter * Math.sin(angle));
        ctx.stroke();
      }
      ctx.restore();
    }
    
    function drawRadarSegments(ctx, cx, cy, rOuter, rInner, history, maxAge) {
      ctx.save();
      const now = Date.now();
      const segmentCount = history.length;
      const anglePerSegment = (2 * Math.PI) / segmentCount;
      history.forEach((point, index) => {
        const age = now - point.t;
        if (age < 0 || age > maxAge) return;
        const normalizedAge = age / maxAge;
        const startAngle = (2 * Math.PI * (1 - normalizedAge)) - Math.PI / 2;
        const endAngle = startAngle + anglePerSegment;
        const lufs = Math.max(-60, Math.min(-9, point.v));
        const r = lufsToRadius(lufs, rOuter, rInner);
        const color = getLoudnessColor(lufs);
        const opacity = 0.85 * (1 - normalizedAge * 0.3);
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, r, startAngle, endAngle);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.globalAlpha = opacity;
        ctx.fill();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 0.5;
        ctx.stroke();
      });
      if (history.length > 0) {
        const sweepAngle = -Math.PI / 2;
        ctx.globalAlpha = 0.9;
        ctx.strokeStyle = '#69bfff';
        ctx.lineWidth = 2;
        ctx.shadowColor = '#69bfff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + rOuter * Math.cos(sweepAngle), cy + rOuter * Math.sin(sweepAngle));
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
      ctx.restore();
    }
    
    function drawRadarLabels(ctx, cx, cy, rOuter, rInner, canvasWidth) {
      ctx.save();
      const fontSize = Math.max(10, Math.floor(canvasWidth * 0.028));
      ctx.font = `600 ${fontSize}px ui-sans-serif, Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const labels = [
        { lufs: -9,  angle: 45,  color: '#ff9a2d' },
        { lufs: -18, angle: 0,   color: '#69bfff' },
        { lufs: -23, angle: 315, color: '#58d38c' },
        { lufs: -30, angle: 225, color: '#a9b2c7' },
        { lufs: -42, angle: 180, color: '#6b7280' }
      ];
      labels.forEach(label => {
        const angleRad = (label.angle - 90) * Math.PI / 180;
        const labelRadius = rOuter + fontSize * 1.5;
        const x = cx + labelRadius * Math.cos(angleRad);
        const y = cy + labelRadius * Math.sin(angleRad);
        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
        ctx.shadowBlur = 4;
        ctx.fillStyle = label.color;
        ctx.fillText(`${label.lufs}`, x, y);
      });
      ctx.shadowBlur = 0;
      ctx.font = `700 ${fontSize * 1.2}px ui-sans-serif, Arial`;
      ctx.fillStyle = '#e8eef9';
      ctx.fillText('LUFS', cx, cy + rOuter + fontSize * 3);
      ctx.restore();
    }
    
    function drawCenterLUFS(ctx, cx, cy, rInner, momentaryLufs) {
      ctx.save();
      const fontSize = Math.max(16, rInner * 0.4);
      ctx.font = `800 ${fontSize}px ui-sans-serif, Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if (typeof momentaryLufs === 'number' && isFinite(momentaryLufs)) {
        const color = getLoudnessColor(momentaryLufs);
        ctx.shadowColor = color;
        ctx.shadowBlur = 12;
        ctx.fillStyle = color;
        ctx.fillText(momentaryLufs.toFixed(1), cx, cy);
      } else {
        ctx.fillStyle = '#6b7280';
        ctx.fillText('—', cx, cy);
      }
      ctx.restore();
    }
    
    function drawEmptyRadar(ctx, w, h) {
      const cx = w / 2;
      const cy = h / 2;
      const rOuter = Math.min(w, h) * 0.46;
      const rInner = rOuter * 0.15;
      drawRadarBackground(ctx, cx, cy, rOuter, rInner);
      drawRadarGrid(ctx, cx, cy, rOuter, rInner);
      drawRadarLabels(ctx, cx, cy, rOuter, rInner, w);
      ctx.save();
      ctx.font = '600 14px ui-sans-serif, Arial';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#6b7280';
      ctx.fillText('Waiting for audio...', cx, cy);
      ctx.restore();
    }
    
    function render(canvas, ctx, history, momentaryLufs, maxSeconds) {
      const w = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
      const h = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, w, h);
      if (!history.length) {
        drawEmptyRadar(ctx, w, h);
        return;
      }
      const cx = w / 2;
      const cy = h / 2;
      const rOuter = Math.min(w, h) * 0.46;
      const rInner = rOuter * 0.15;
      const maxAge = maxSeconds * 1000;
      drawRadarBackground(ctx, cx, cy, rOuter, rInner);
      drawRadarGrid(ctx, cx, cy, rOuter, rInner);
      drawRadarSegments(ctx, cx, cy, rOuter, rInner, history, maxAge);
      drawRadarLabels(ctx, cx, cy, rOuter, rInner, w);
      drawCenterLUFS(ctx, cx, cy, rInner, momentaryLufs);
    }
    
    return { render: render };
  })();
  
  function drawLoudnessRadar(momentaryLufs) {
    LoudnessRadar.render(loudnessRadar, loudnessRadarCtx, radarHistory, momentaryLufs, radarMaxSeconds);
  }

  // ------- DOM -------

  const wrap = document.getElementById('wrap');
  const meters = document.getElementById('meters');
  // --- Loudness Radar ---
  const loudnessRadar = document.getElementById('loudnessRadar');
  const loudnessRadarCtx = loudnessRadar.getContext('2d');
  // --- Stereo Vectorscope ---
  const xyCard = document.getElementById('xyCard');
  const xyWrap = document.getElementById('xyWrap');
  const xy = document.getElementById('xy'), xyCtx = xy.getContext('2d');
  const corr = document.getElementById('corr'), corrCtx = corr.getContext('2d');
  const corrVal = document.getElementById('corrVal');

  const dbfs = document.getElementById('dbfs'), dbfsScale = document.getElementById('dbfsScale');
  const dbL = document.getElementById('dbL'), dbR = document.getElementById('dbR');
  const tp = document.getElementById('tp'), tpScale = document.getElementById('tpScale');
  const tpL = document.getElementById('tpL'), tpR = document.getElementById('tpR');

  // --- R128 Subpanel ---
  const lufsM = document.getElementById('lufsM');
  const lufsS = document.getElementById('lufsS');
  const lufsI = document.getElementById('lufsI');
  const lraEl = document.getElementById('lra');

  // --- Radar Data Buffer ---
  // Holds the last 60s of short-term loudness (or as much as fits)
  const radarHistory = [];
  const radarMaxSeconds = 60;
  // Called from updateR128()
  function pushRadarLoudness(val) {
    const now = Date.now();
    radarHistory.push({ t: now, v: val });
    // Remove old
    while (radarHistory.length > 2 && (now - radarHistory[0].t) > radarMaxSeconds*1000) radarHistory.shift();
  }

  const btnTab  = document.getElementById('btnTab');
  const btnStop = document.getElementById('btnStop');
  const btnTone = document.getElementById('btnTone');
  const btnMonMute = document.getElementById('btnMonMute');
  const monState = document.getElementById('monState');
  const muteLeft = document.getElementById('muteLeft');
  const monGainEl = document.getElementById('monGain');
  const monVal = document.getElementById('monVal');

  const btnSysMonMute = document.getElementById('btnSysMonMute');
  const sysMonState = document.getElementById('sysMonState');
  const sysMonGainEl = document.getElementById('sysMonGain');
  const sysMonVal = document.getElementById('sysMonVal');

  const sysTrimRange = document.getElementById('sysTrimRange');
  const sysTrimInput = document.getElementById('sysTrimInput');
  const sysTrimOut = document.getElementById('sysTrimOut');
  const sysTrimReset = document.getElementById('sysTrimReset');

  const info = { srcKind: document.getElementById('srcKind'), cc: document.getElementById('cc'), sr: document.getElementById('sr'), stOK: document.getElementById('stOK') };

  const ppmCanvas = document.getElementById('ppmCanvas');
  const ppmScale = document.getElementById('ppmScale');
  const ppmLVal = document.getElementById('ppmLVal');
  const ppmRVal = document.getElementById('ppmRVal');
  const ctxState = document.getElementById('ctxState');
  const dbgGen   = document.getElementById('dbgGen');
  const dbgTab   = document.getElementById('dbgTab');
  const uptimeEl = document.getElementById('uptime');

  // ------- Helpers -------
  function getCss(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
  const dbToGain = dB => Math.pow(10, dB/20);
  const clamp = (v,min,max)=>Math.max(min,Math.min(max, v));

  // ------- Layout -------
  function sizeWrap(){ const headerH = document.querySelector('header').offsetHeight; wrap.style.height = `calc(100dvh - ${headerH}px)`; }
  sizeWrap(); window.addEventListener('resize', sizeWrap);

  function layoutXY(){
    // **DRAG-AWARE LAYOUT: Skip expensive calculations during drag operations**
    if (isDragLayoutFrozen) {
      console.debug('layoutXY: Skipped due to active drag operation');
      return;
    }

    const dpr = window.devicePixelRatio || 1;
    const xyModule = xyCard.querySelector('.xyModule');
    if (!xyModule) return;

    const moduleH = xyModule.clientHeight;
    const moduleW = xyModule.clientWidth;
    const corrH = 100; // Fast höjd för correlation
    const gap = 12;

    // Goniometer: kvadratisk, anpassas till tillgängligt utrymme
    const availableH = moduleH - corrH - gap;
    const side = Math.max(160, Math.min(availableH, moduleW));

    xyWrap.style.width = side + 'px';
    xyWrap.style.height = side + 'px';

    const w = Math.floor(side * dpr), h = Math.floor(side * dpr);
    if (xy.width !== w || xy.height !== h) {
      xy.width = w;
      xy.height = h;
    }

    // Correlation: full bredd, fast höjd
    const corrWrapEl = document.querySelector('.corrWrap');
    if (corrWrapEl) {
      corrWrapEl.style.height = corrH + 'px';
      corrWrapEl.style.width = '100%';
    }
    const cw = Math.floor(moduleW * dpr), ch = Math.floor(corrH * dpr);
    if (corr.width !== cw || corr.height !== ch) {
      corr.width = cw;
      corr.height = ch;
    }
  }

  // ------- Audio graph -------
  const ac = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
  ctxState && (ctxState.textContent = ac.state); ac.onstatechange = () => { if(ctxState) ctxState.textContent = ac.state };

  // Analysbuss L/R
  const mixL = ac.createGain(); mixL.gain.value = 1; const mixR = ac.createGain(); mixR.gain.value = 1;
  const analyserL = ac.createAnalyser(); analyserL.fftSize = 2048; const analyserR = ac.createAnalyser(); analyserR.fftSize = 2048;
  mixL.connect(analyserL); mixR.connect(analyserR);
  const bufL = new Float32Array(analyserL.fftSize); const bufR = new Float32Array(analyserR.fftSize);

  // K-weighting path (approx) för R128
  const kHP_L = ac.createBiquadFilter(); kHP_L.type='highpass'; kHP_L.frequency.value=38; kHP_L.Q.value=0.5;
  const kHS_L = ac.createBiquadFilter(); kHS_L.type='highshelf'; kHS_L.frequency.value=4000; kHS_L.gain.value=4; kHP_L.connect(kHS_L);
  const kHP_R = ac.createBiquadFilter(); kHP_R.type='highpass'; kHP_R.frequency.value=38; kHP_R.Q.value=0.5;
  const kHS_R = ac.createBiquadFilter(); kHS_R.type='highshelf'; kHS_R.frequency.value=4000; kHS_R.gain.value=4; kHP_R.connect(kHS_R);

  const kAnL = ac.createAnalyser(); kAnL.fftSize = 2048; const kBufL = new Float32Array(kAnL.fftSize);
  const kAnR = ac.createAnalyser(); kAnR.fftSize = 2048; const kBufR = new Float32Array(kAnR.fftSize);
  kHS_L.connect(kAnL); kHS_R.connect(kAnR);

  function connectStereoToMix(node){ const split = ac.createChannelSplitter(2); node.connect(split); split.connect(mixL,0); split.connect(mixR,1); split.connect(kHP_L,0); split.connect(kHP_R,1); return split; }

  // ------- Nordic PPM (IEC 60268-10 Type I) -------
  // Skala: -36 till +9 dBu, TEST = 0 dBu = -18 dBFS, PML = +9 dBu = -9 dBFS
  // Ballistik: 5 ms attack (quasi-peak), linjär decay 20 dB / 1.7 s
  let ppmHoldL = -60, ppmHoldR = -60, lastTsPPM = performance.now();
  const PPM_ATTACK_MS = 5;          // 5 ms integration (IEC Type I)
  const PPM_DECAY_DB_PER_S = 20/1.7; // 20 dB på 1.7 s ≈ 11.76 dB/s (linjär)
  const PPM_MIN_DB = -54;           // -36 dBu = -54 dBFS
  const PPM_MAX_DB = -9;            // +9 dBu = -9 dBFS

  function quasiPeakDb(buf, sampleRate){
    // Quasi-peak: hitta max amplitude med ~5ms integration
    // Vid 48kHz = 240 samples per 5ms fönster
    const windowSamples = Math.max(1, Math.round(sampleRate * PPM_ATTACK_MS / 1000));
    let maxPeak = 0;
    for(let i = 0; i < buf.length; i += windowSamples){
      let windowMax = 0;
      const end = Math.min(i + windowSamples, buf.length);
      for(let j = i; j < end; j++){
        const abs = Math.abs(buf[j]);
        if(abs > windowMax) windowMax = abs;
      }
      if(windowMax > maxPeak) maxPeak = windowMax;
    }
    return 20 * Math.log10(maxPeak + 1e-12);
  }

  function updatePPM(){
    const now = performance.now();
    const dt = Math.max(0.001, (now - lastTsPPM) / 1000);
    lastTsPPM = now;

    // Hämta samples
    analyserL.getFloatTimeDomainData(bufL);
    analyserR.getFloatTimeDomainData(bufR);

    // Quasi-peak mätning (dBFS)
    const peakDbL = quasiPeakDb(bufL, ac.sampleRate);
    const peakDbR = quasiPeakDb(bufR, ac.sampleRate);

    // Nordic PPM ballistik:
    // Attack: omedelbart till nytt peak (inom 5ms integration redan i quasiPeakDb)
    // Decay: linjär 20 dB / 1.7 s
    const decayDb = PPM_DECAY_DB_PER_S * dt;

    // L kanal
    if(peakDbL > ppmHoldL){
      ppmHoldL = peakDbL; // Snabb attack
    } else {
      ppmHoldL = Math.max(PPM_MIN_DB, ppmHoldL - decayDb); // Linjär decay
    }

    // R kanal
    if(peakDbR > ppmHoldR){
      ppmHoldR = peakDbR;
    } else {
      ppmHoldR = Math.max(PPM_MIN_DB, ppmHoldR - decayDb);
    }

    // Clamp till skalan
    const dispL = Math.max(PPM_MIN_DB, Math.min(PPM_MAX_DB, ppmHoldL));
    const dispR = Math.max(PPM_MIN_DB, Math.min(PPM_MAX_DB, ppmHoldR));

    // Rita
    drawHBar_PPM(ppmCanvas, dispL, dispR);

    // Visa i dBu (0 dBu = -18 dBFS)
    const dBuL = dispL + 18; // -18 dBFS → 0 dBu
    const dBuR = dispR + 18;
    const fmtdBu = (v) => (v > 0 ? '+' : '') + v.toFixed(0);
    ppmLVal.textContent = fmtdBu(dBuL);
    ppmRVal.textContent = fmtdBu(dBuR);
  }

  // ------- XY + Correlation -------
  function drawXY(){
    const w=xy.width,h=xy.height; if(!w||!h) return;
    const fade = 0.10; xyCtx.fillStyle = `rgba(13,15,17,${fade})`; xyCtx.fillRect(0,0,w,h);
    analyserL.getFloatTimeDomainData(bufL); analyserR.getFloatTimeDomainData(bufR);
    let n=Math.min(bufL.length,bufR.length), mL=0,mR=0; for(let i=0;i<n;i++){ mL+=bufL[i]; mR+=bufR[i]; } mL/=n; mR/=n;
    xyCtx.globalAlpha=0.85; xyCtx.globalCompositeOperation='lighter'; xyCtx.fillStyle='rgba(105,191,255,.85)'; const px = Math.max(1, Math.floor((window.devicePixelRatio||1)));
    let prevX=null, prevY=null;
    for(let i=0;i<n;i+=2){
      const L=bufL[i]-mL, R=bufR[i]-mR;
      // Centrera och skala korrekt för -18 dBFS
      const x = (L * w/2) + w/2;  // Skala -1..1 till 0..w
      const y = h - ((R * h/2) + h/2);  // Skala -1..1 till 0..h, invertera för y
      if(prevX!==null){ xyCtx.globalAlpha=.35; xyCtx.strokeStyle='rgba(105,191,255,.35)'; xyCtx.beginPath(); xyCtx.moveTo(prevX,prevY); xyCtx.lineTo(x,y); xyCtx.stroke(); }
      xyCtx.globalAlpha=.85; xyCtx.fillRect(x,y,px,px); prevX=x; prevY=y;
    }
    xyCtx.globalCompositeOperation='source-over'; xyCtx.globalAlpha=1; xyCtx.strokeStyle = '#3a4855'; xyCtx.lineWidth = 1;
    xyCtx.beginPath();
    xyCtx.moveTo(w/2,0); xyCtx.lineTo(w/2,h);
    xyCtx.moveTo(0,h/2); xyCtx.lineTo(w,h/2);
    xyCtx.moveTo(0,h); xyCtx.lineTo(w,0);
    xyCtx.moveTo(0,0); xyCtx.lineTo(w,h);
    xyCtx.stroke();
  }

  function corrNow(l,r){
    let n=Math.min(l.length,r.length), sL=0,sR=0; for(let i=0;i<n;i++){ sL+=l[i]; sR+=r[i] }
    const mL=sL/n, mR=sR/n; let num=0,dL=0,dR=0;
    for(let i=0;i<n;i++){ const L=l[i]-mL, R=r[i]-mR; num+=L*R; dL+=L*L; dR+=R*R }
    return num/(Math.sqrt(dL*dR)+1e-20);
  }
  let corrHold=0, corrUp=.25, corrDn=.06;
  function drawCorr(){
    analyserL.getFloatTimeDomainData(bufL); analyserR.getFloatTimeDomainData(bufR);
    const cRaw = Math.max(-1, Math.min(1, corrNow(bufL,bufR)));
    corrHold = cRaw>corrHold ? corrHold + corrUp*(cRaw-corrHold) : corrHold + corrDn*(cRaw-corrHold);
    
    // Uppdatera canvas-storlek baserat på faktisk elementstorlek
    const dpr = window.devicePixelRatio || 1;
    const rect = corr.getBoundingClientRect();
    const w = Math.floor(rect.width * dpr);
    const h = Math.floor(rect.height * dpr);
    
    if (corr.width !== w || corr.height !== h) {
      corr.width = w;
      corr.height = h;
      // Sätt CSS-storlek för att matcha element
      corr.style.width = `${rect.width}px`;
      corr.style.height = `${rect.height}px`;
    }
    
    const ctx = corrCtx;
    ctx.clearRect(0,0,w,h);
    const box = { x: Math.floor(w*0.18), y: Math.floor(16*dpr), w: Math.floor(w*0.64), h: h-(32*dpr) };
    const yFromV = v => Math.round(box.y + (1 - (v+1)/2) * box.h);
    ctx.strokeStyle='#3a4855'; ctx.strokeRect(box.x, box.y, box.w, box.h);
    ctx.fillStyle='#88a3bf'; const ticksV=[-1,-0.5,0,0.5,1];
    
    // Anpassa font och streck för HiDPI
    const tickWidth = Math.ceil(6 * dpr);
    const tickHeight = Math.ceil(1 * dpr);
    ctx.font = `${Math.round(10*dpr)}px ui-sans-serif`;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'left';
    
    for(const tv of ticksV){
      const y = yFromV(tv);
      // Rita skalstreck med rätt DPR-storlek
      ctx.fillRect(box.x-tickWidth, y, tickWidth, tickHeight);
      ctx.fillRect(box.x+box.w, y, tickWidth, tickHeight);
      // Rita text
      ctx.fillText(tv.toString(), box.x+box.w+Math.round(8*dpr), y);
    }
    const y0 = yFromV(0); const yc = yFromV(corrHold);
    const col = (corrHold<-0.2)?getCss('--hot'):(corrHold>0.9?getCss('--ok'):getCss('--warn'));
    ctx.globalAlpha=.18; ctx.fillStyle='#0f1214'; ctx.fillRect(box.x, box.y, box.w, box.h);
    ctx.globalAlpha=.85; ctx.fillStyle=col;
    if (yc < y0) { ctx.fillRect(box.x+2, yc, box.w-4, (y0 - yc)); }
    else { ctx.fillRect(box.x+2, y0, box.w-4, (yc - y0)); }
    ctx.globalAlpha=1; ctx.fillStyle='#2a3642'; ctx.fillRect(box.x+1, y0, box.w-2, 1);
    corrVal.textContent = corrHold.toFixed(2);
  }

  // ------- dBFS (RMS) -------
  const dbfsMarks = [-60,-50,-40,-30,-24,-18,-12,-6,-3,0];
  function layoutDBFSScale(el){
    el.innerHTML='';
    dbfsMarks.forEach(m=>{
      const x = ((m+60)/60)*100;
      const t=document.createElement('div');
      t.style.position='absolute'; t.style.left=`calc(${x}% - 0.5px)`; t.style.top='25%'; t.style.height='50%'; t.style.width='1px'; t.style.background='#2a3642';
      el.appendChild(t);
      const lab=document.createElement('div');
      lab.textContent=m + ' dBFS';
      lab.style.position='absolute'; lab.style.left=`calc(${x}% - 32px)`; lab.style.top='8px'; lab.style.width='64px'; lab.style.textAlign='center'; lab.style.fontSize='10px'; lab.style.color='#88a3bf';
      el.appendChild(lab);
    });
    // TEST -18 dBFS (blue line, same as gray tick marks)
    const x = ((-18+60)/60)*100;
    const ref=document.createElement('div');
    ref.style.position='absolute';
    ref.style.left=`calc(${x}% - 0.5px)`;
    ref.style.top='25%';
    ref.style.height='50%';
    ref.style.width='1px';
    ref.style.background=getCss('--cyan');
    ref.style.opacity='0.95';
    el.appendChild(ref);
    const tag=document.createElement('div');
    tag.innerHTML='<div>TEST</div><div>-18 dBFS</div>';
    tag.style.position='absolute';
    tag.style.left=`calc(${x}% - 32px)`;
    tag.style.bottom='8px';  // Samma spacing som top labels
    tag.style.width='64px';
    tag.style.textAlign='center';
    tag.style.fontSize='10px';
    tag.style.color=getCss('--cyan');
    tag.style.fontWeight='bold';
    tag.style.lineHeight='1.2';
    tag.style.background='none';
    tag.style.borderRadius='0';
    tag.style.padding='0';
    el.appendChild(tag);
  }

  // TRUE PEAK scale in dBTP + TEST -15 dBTP
  function layoutTPScale(el){
    el.innerHTML='';
    const marks = [-60,-50,-40,-30,-24,-18,-12,-6,-3,0];
    marks.forEach(m=>{
      const x = ((m+60)/60)*100;
      const t=document.createElement('div');
      t.style.position='absolute'; t.style.left=`calc(${x}% - 1px)`; t.style.top='25%'; t.style.height='50%'; t.style.width='2px'; t.style.background='#2a3642';
      el.appendChild(t);
      const lab=document.createElement('div');
      lab.textContent = m + ' dBTP';
      lab.style.position='absolute'; lab.style.left=`calc(${x}% - 32px)`; lab.style.top='6px'; lab.style.width='64px'; lab.style.textAlign='center'; lab.style.fontSize='10px'; lab.style.color='#88a3bf';
      el.appendChild(lab);
    });
    // warn zones (styled like VU Nordic, label at bottom, color-coded)
    const warn=[
      {v:-6,c:'var(--warn)',w:1,label:'−6 dBTP',color:getCss('--warn')},
      {v:-3,c:'var(--caution)',w:1,label:'−3 dBTP',color:getCss('--caution')},
      {v:-1,c:'var(--hot)',w:1,label:'−1 dBTP',color:getCss('--hot')}
    ];
    for(const mk of warn){
      const x=((mk.v+60)/60)*100;
      const col=document.createElement('div');
      col.style.position='absolute'; col.style.left=`calc(${x}% - 0.5px)`; col.style.top='25%'; col.style.height='50%'; col.style.width=`${mk.w}px`; col.style.background=`${mk.c}`; col.style.opacity='0.95';
      el.appendChild(col);
      let dbfsEq = '';
      if(mk.v === -6) dbfsEq = '-9 dBFS';
      if(mk.v === -3) dbfsEq = '-6 dBFS';
      if(mk.v === -1) dbfsEq = '-4 dBFS';
      const tag=document.createElement('div');
      tag.innerHTML = `<div>${dbfsEq}</div>`;
      tag.style.position='absolute';
      tag.style.left=`calc(${x}% - 32px)`;
      tag.style.bottom='8px';  // Samma luftiga spacing som blå TEST-text
      tag.style.width='64px';
      tag.style.textAlign='center';
      tag.style.fontSize='10px';
      tag.style.color=mk.color;
      tag.style.fontWeight='bold';
      tag.style.lineHeight='1.2';
      tag.style.background='none';
      tag.style.borderRadius='0';
      tag.style.padding='0';
      el.appendChild(tag);
    }
    // TEST -15 dBTP (blue line, same as gray tick marks)
    const xRef = ((-15+60)/60)*100;
    const ref=document.createElement('div');
    ref.style.position='absolute';
    ref.style.left=`calc(${xRef}% - 1px)`;
    ref.style.top='25%';
    ref.style.height='50%';
    ref.style.width='2px';
    ref.style.background=getCss('--cyan');
    ref.style.opacity='0.95';
    el.appendChild(ref);
    // TEST label below blue line
    const tag=document.createElement('div');
    tag.innerHTML='<div>TEST</div><div>-18 dBFS</div>';
    tag.style.position='absolute';
    tag.style.left=`calc(${xRef}% - 32px)`;
    tag.style.bottom='8px';  // Samma spacing som top labels
    tag.style.width='64px';
    tag.style.textAlign='center';
    tag.style.fontSize='10px';
    tag.style.color=getCss('--cyan');
    tag.style.fontWeight='bold';
    tag.style.lineHeight='1.2';
    tag.style.background='none';
    tag.style.borderRadius='0';
    tag.style.padding='0';
    el.appendChild(tag);
  }

  // Nordic PPM – horisontell skala: -36 dBu till +9 dBu (dBFS: -54 till -9)
  // Skalmarkeringar i dBu (traditionell Nordic)
  const ppmMarks_dBu = [-36, -30, -24, -18, -12, -6, 0, 6, 9]; // dBu
  function layoutPPMScale(el){
    el.innerHTML='';
    const dbMin=-54, dbMax=-9, dbSpan=dbMax-dbMin; // 45 dB i dBFS
    ppmMarks_dBu.forEach(dBu=>{
      const dBFS = dBu - 18; // Konvertera dBu till dBFS
      const x = ((dBFS-dbMin)/dbSpan)*100;
      const t=document.createElement('div');
      t.style.position='absolute'; t.style.left=`calc(${x}% - 0.5px)`; t.style.top='25%'; t.style.height='50%'; t.style.width='1px'; t.style.background='#2a3642';
      el.appendChild(t);
      const lab=document.createElement('div');
      // Visa dBu-värde (traditionell Nordic-visning)
      lab.textContent = (dBu>0?'+':'') + dBu;
      lab.style.position='absolute'; lab.style.left=`calc(${x}% - 20px)`; lab.style.top='6px'; lab.style.width='40px'; lab.style.textAlign='center'; lab.style.fontSize='10px'; lab.style.color='#88a3bf';
      el.appendChild(lab);
    });
    // TEST = 0 dBu = -18 dBFS (cyan linje)
    const xTest = ((-18-dbMin)/dbSpan)*100; // 0 dBu = -18 dBFS
    const ref=document.createElement('div');
    ref.style.position='absolute';
    ref.style.left=`calc(${xTest}% - 1px)`;
    ref.style.top='25%';
    ref.style.height='50%';
    ref.style.width='2px';
    ref.style.background=getCss('--cyan');
    ref.style.opacity='0.95';
    el.appendChild(ref);
    const tag=document.createElement('div');
    tag.innerHTML='<div>TEST</div><div>0 dBu</div>';
    tag.style.position='absolute';
    tag.style.left=`calc(${xTest}% - 32px)`;
    tag.style.bottom='8px';
    tag.style.width='64px';
    tag.style.textAlign='center';
    tag.style.fontSize='10px';
    tag.style.color=getCss('--cyan');
    tag.style.fontWeight='bold';
    tag.style.lineHeight='1.2';
    tag.style.background='none';
    tag.style.borderRadius='0';
    tag.style.padding='0';
    el.appendChild(tag);
    // PML = +9 dBu = -9 dBFS (röd markering)
    const xPML = ((-9-dbMin)/dbSpan)*100; // +9 dBu = -9 dBFS
    const pmlLine=document.createElement('div');
    pmlLine.style.position='absolute';
    pmlLine.style.left=`calc(${xPML}% - 1px)`;
    pmlLine.style.top='25%';
    pmlLine.style.height='50%';
    pmlLine.style.width='2px';
    pmlLine.style.background=getCss('--hot');
    pmlLine.style.opacity='0.95';
    el.appendChild(pmlLine);
    const pmlTag=document.createElement('div');
    pmlTag.innerHTML='<div>PML</div><div>+9 dBu</div>';
    pmlTag.style.position='absolute';
    pmlTag.style.left=`calc(${xPML}% - 32px)`;
    pmlTag.style.bottom='8px';
    pmlTag.style.width='64px';
    pmlTag.style.textAlign='center';
    pmlTag.style.fontSize='10px';
    pmlTag.style.color=getCss('--hot');
    pmlTag.style.fontWeight='bold';
    pmlTag.style.lineHeight='1.2';
    pmlTag.style.background='none';
    pmlTag.style.borderRadius='0';
    pmlTag.style.padding='0';
    el.appendChild(pmlTag);
  }

  function drawHBar_DBFS(canvas, valueL, valueR){
    const dpr=window.devicePixelRatio||1;
    const w=Math.floor(canvas.clientWidth*dpr), h=Math.floor(canvas.height);
    if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h }
    const ctx = canvas.getContext('2d');
    function xFromDb(db){ const c=Math.max(-60,Math.min(0,db)); return Math.round((c+60)/60*w) }
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#0e151a'; ctx.fillRect(0,0,w,h);
    const step=1;
    function drawChannel(yTop, val){
      for(let d=-60; d<0; d+=step){ const x0=xFromDb(d), x1=xFromDb(d+step); ctx.globalAlpha=.14; ctx.fillStyle=getCss('--ok'); ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12); }
      const tEnd = Math.min(0, val);
      for(let d=-60; d<tEnd; d+=step){ const x0=xFromDb(d), x1=xFromDb(Math.min(d+step,tEnd)); ctx.globalAlpha=.9; ctx.fillStyle=getCss('--ok'); ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12); }
    }
    drawChannel(h*0.35, valueL); drawChannel(h*0.55, valueR);
    ctx.globalAlpha=1; ctx.fillStyle='#2a3642'; ctx.fillRect(w-2,0,2,h); // 0 dBFS fence
  }

  // TRUE PEAK – diode style
  function drawDiodeBar_TP(canvas, valueL, valueR){
    const dpr=window.devicePixelRatio||1; const w=Math.floor(canvas.clientWidth*dpr), h=Math.floor(canvas.height);
    if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h }
    const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,w,h); ctx.fillStyle='#0e151a'; ctx.fillRect(0,0,w,h);
    const step=1; const xFromDb = db => Math.round((Math.max(-60,Math.min(0,db))+60)/60*w);
    function segColor(db){ if(db>=-1) return getCss('--hot'); if(db>=-3) return getCss('--caution'); if(db>=-6) return getCss('--warn'); return getCss('--ok'); }
    function drawChannel(yTop, val){
      for(let d=-60; d<0; d+=step){ const x0=xFromDb(d), x1=xFromDb(d+step); const col=segColor(d+step/2); ctx.globalAlpha=.14; ctx.fillStyle=col; ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12); }
      const tEnd = Math.min(0, val);
      for(let d=-60; d<tEnd; d+=step){
        const x0=xFromDb(d), x1=xFromDb(Math.min(d+step,tEnd));
        let col=segColor(tEnd); if(tEnd<-1){ col=segColor(d+step/2); }
        ctx.globalAlpha=.9; ctx.fillStyle=col; ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12);
      }
    }
    drawChannel(h*0.35, valueL); drawChannel(h*0.55, valueR);
    ctx.globalAlpha=1; ctx.fillStyle='#2a3642'; ctx.fillRect(w-2,0,2,h); // 0 dBTP fence (visual)
  }

  // Nordic PPM – horisontell canvas
  // Range: -54 dBFS till -9 dBFS (45 dB span) = -36 dBu till +9 dBu
  // TEST = 0 dBu = -18 dBFS, PML = +9 dBu = -9 dBFS
  function drawHBar_PPM(canvas, dBfsL, dBfsR){
    const dpr=window.devicePixelRatio||1;
    const rect = canvas.getBoundingClientRect();
    const w=Math.floor(rect.width*dpr), h=Math.floor(rect.height*dpr);
    if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h }
    const ctx = canvas.getContext('2d');
    const dbMin=-54, dbMax=-9, dbSpan=dbMax-dbMin; // 45 dB
    function xFromDb(db){ const c=Math.max(dbMin,Math.min(dbMax,db)); return Math.round((c-dbMin)/dbSpan*w) }
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#0e151a'; ctx.fillRect(0,0,w,h);
    const step=1;
    // Färgzoner för Nordic PPM (baserat på dBu-nivåer)
    function segColor(db){
      // db är i dBFS, konvertera till dBu: dBu = dBFS + 18
      const dBu = db + 18;
      if(dBu >= 6) return getCss('--hot');      // +6 dBu och över = rött (nära PML)
      if(dBu >= 0) return getCss('--warn');     // 0 till +6 dBu = orange (över TEST)
      return getCss('--ok');                     // Under TEST = grönt
    }
    function drawChannel(yTop, val){
      // Bakgrund (dimmat)
      for(let d=dbMin; d<dbMax; d+=step){
        const x0=xFromDb(d), x1=xFromDb(d+step);
        ctx.globalAlpha=.14;
        ctx.fillStyle=segColor(d+step/2);
        ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12);
      }
      // Aktiv bar
      const tEnd = Math.min(dbMax, val);
      for(let d=dbMin; d<tEnd; d+=step){
        const x0=xFromDb(d), x1=xFromDb(Math.min(d+step,tEnd));
        ctx.globalAlpha=.9;
        ctx.fillStyle=segColor(d+step/2);
        ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12);
      }
    }
    drawChannel(h*0.35, dBfsL); drawChannel(h*0.55, dBfsR);
    ctx.globalAlpha=1; ctx.fillStyle='#2a3642'; ctx.fillRect(w-2,0,2,h); // +9 dBu fence
  }

  let rmsHoldL=0, rmsHoldR=0; let lastTsDB=performance.now();
  function drawDBFS(){
    analyserL.getFloatTimeDomainData(bufL); analyserR.getFloatTimeDomainData(bufR);
    let sL=0,sR=0; for(let i=0;i<bufL.length;i++){ sL+=bufL[i]*bufL[i]; sR+=bufR[i]*bufR[i] }
    const rmsL=Math.sqrt(sL/bufL.length), rmsR=Math.sqrt(sR/bufR.length);
    const now=performance.now(); const dt=Math.max(0.001,(now-lastTsDB)/1000); lastTsDB=now; const tau=.3, a=1-Math.exp(-dt/tau);
    rmsHoldL += a*(rmsL - rmsHoldL); rmsHoldR += a*(rmsR - rmsHoldR);
    const dBL = 20*Math.log10(rmsHoldL+1e-12); const dBR = 20*Math.log10(rmsHoldR+1e-12);
    document.getElementById('dbfsLabel').innerHTML = `L: <b>${dBL.toFixed(1)}</b> · R: <b>${dBR.toFixed(1)}</b> dBFS`;
    drawHBar_DBFS(dbfs, dBL, dBR);
  }
  layoutDBFSScale(dbfsScale);
  layoutPPMScale(ppmScale);

  function hermite(p0,p1,p2,p3,t){ const a= (-0.5*p0)+(1.5*p1)+(-1.5*p2)+(0.5*p3); const b=(p0*(-1))+ (2.5*p1)+(-2*p2)+ (0.5*p3); const c=(-0.5*p0)+(0.5*p2); const d=p1; return ((a*t+b)*t+c)*t+d; }
  function truePeakDb(buf){
    let maxAbs=0; const n=buf.length;
    for(let i=1;i<n-2;i++){
      const p0=buf[i-1], p1=buf[i], p2=buf[i+1], p3=buf[i+2];
      const a=Math.abs(p1); if(a>maxAbs) maxAbs=a;
      const t1=Math.abs(hermite(p0,p1,p2,p3,0.25)); if(t1>maxAbs) maxAbs=t1;
      const t2=Math.abs(hermite(p0,p1,p2,p3,0.50)); if(t2>maxAbs) maxAbs=t2;
      const t3=Math.abs(hermite(p0,p1,p2,p3,0.75)); if(t3>maxAbs) maxAbs=t3;
    }
    return 20*Math.log10(maxAbs + 1e-9);
  }
  let tpSmoothL=-60, tpSmoothR=-60;
  function drawTruePeak(){
    analyserL.getFloatTimeDomainData(bufL); analyserR.getFloatTimeDomainData(bufR);
    const rawL = Math.min(0, truePeakDb(bufL)); const rawR = Math.min(0, truePeakDb(bufR));
    const a = 0.25; tpSmoothL = tpSmoothL + a*(rawL - tpSmoothL); tpSmoothR = tpSmoothR + a*(rawR - tpSmoothR);
    document.getElementById('tpLabel').innerHTML = `L: <b>${tpSmoothL.toFixed(1)}</b> · R: <b>${tpSmoothR.toFixed(1)}</b> dBTP`;
    drawDiodeBar_TP(tp, tpSmoothL, tpSmoothR);
  }
  layoutTPScale(tpScale);

  // ------- R128 -------
  const frameDur = 2048 / 48000; const mLen = Math.max(1, Math.round(0.4 / frameDur)); const sLen = Math.max(1, Math.round(3.0 / frameDur));
  const mQ = []; const sQ = []; let intEnergy = 0, intCount = 0; let stHistory = [];
  function energyFromK(){
    kAnL.getFloatTimeDomainData(kBufL); kAnR.getFloatTimeDomainData(kBufR);
    let eL=0,eR=0; for(let i=0;i<kBufL.length;i++){ eL+=kBufL[i]*kBufL[i]; eR+=kBufR[i]*kBufR[i]; }
    const rmsL = eL/kBufL.length; const rmsR = eR/kBufR.length; return (rmsL + rmsR)/2;
  }
  function lufsFromEnergy(e){ return 10*Math.log10(e + 1e-12); }
  let lastText=0;
  function updateR128(){
    const e = energyFromK(); mQ.push(e); sQ.push(e);
    if(mQ.length>mLen) mQ.shift(); if(sQ.length>sLen){ stHistory.push(sQ.shift()); if(stHistory.length>Math.round(60/3)) stHistory.shift(); }
    const mE=mQ.reduce((a,b)=>a+b,0)/mQ.length; const sE=sQ.reduce((a,b)=>a+b,0)/sQ.length;
    const mLUFS=lufsFromEnergy(mE); const sLUFS=lufsFromEnergy(sE);
    let gate=-70; if(intCount>0){ const iLU=lufsFromEnergy(intEnergy/intCount); gate=Math.max(-70, iLU-10); }
    if(sLUFS>=gate){ intEnergy+=e; intCount++; }
    const iLUFS=(intCount>0)? lufsFromEnergy(intEnergy/intCount): -Infinity;
    const stVals=stHistory.map(v=>10*Math.log10(v+1e-12)).filter(v=>v>(iLUFS-20));
    let LRA='—'; if(stVals.length>5){
      const sorted=[...stVals].sort((a,b)=>a-b);
      const p95=sorted[Math.floor(sorted.length*0.95)]; const p10=sorted[Math.floor(sorted.length*0.10)];
      LRA=(p95-p10).toFixed(1)+' LU';
    }
    const now=performance.now(); if(now-lastText>100){
      const a=.35;
      const prevM=parseFloat(lufsM.dataset.v||'-999'); const prevS=parseFloat(lufsS.dataset.v||'-999'); const prevI=parseFloat(lufsI.dataset.v||'-999');
      const mDisp=isFinite(prevM)? prevM + a*(mLUFS-prevM): mLUFS; const sDisp=isFinite(prevS)? prevS + a*(sLUFS-prevS): sLUFS; const iDisp=isFinite(prevI)? prevI + a*(iLUFS-prevI): iLUFS;
      lufsM.dataset.v=mDisp; lufsS.dataset.v=sDisp; lufsI.dataset.v=iDisp;
      lufsM.textContent=isFinite(mDisp)? mDisp.toFixed(1)+' LUFS':'—';
      lufsS.textContent=isFinite(sDisp)? sDisp.toFixed(1)+' LUFS':'—';
      lufsI.textContent = (isFinite(iDisp) ? iDisp.toFixed(1)+' LUFS' : '—');
      lraEl.textContent=LRA; lastText=now;
      // --- Update radar buffer with short-term loudness ---
      pushRadarLoudness(sDisp);
    }
  }

  // ------- Capture -------
  let sysStream=null, sysSrc=null, sysSplit=null, sysMonGain=null, sysMonitorMuted=true, sysTrimNode=null; let sysTrimDb = 0;
  function setSysTrim(dB){ sysTrimDb = clamp(parseFloat(dB)||0, -48, 24); sysTrimRange.value=sysTrimDb; sysTrimInput.value=sysTrimDb.toFixed(1); sysTrimOut.textContent = sysTrimDb.toFixed(1)+' dB'; if(sysTrimNode){ sysTrimNode.gain.value = dbToGain(sysTrimDb); } }
  setSysTrim(0); sysTrimRange.addEventListener('input', e=> setSysTrim(e.target.value)); sysTrimInput.addEventListener('change', e=> setSysTrim(e.target.value)); sysTrimInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ setSysTrim(e.target.value); e.target.blur(); }}); sysTrimReset.addEventListener('click', ()=> setSysTrim(0));

  async function startTabCapture(){
    try{
      await ac.resume();
      sysStream = await navigator.mediaDevices.getDisplayMedia({audio:{echoCancellation:false,noiseSuppression:false,autoGainControl:false,channelCount:2}, video:true});
      sysStream.getVideoTracks().forEach(t=>t.stop());
      const track = sysStream.getAudioTracks()[0]; if(!track) throw new Error('No audio track available.');
      try{ track.applyConstraints({advanced:[{channelCount:2}]}); }catch{}
      track.contentHint='music';
      sysSrc = ac.createMediaStreamSource(sysStream);
      sysTrimNode = ac.createGain(); sysTrimNode.gain.value = dbToGain(sysTrimDb);
      sysSrc.connect(sysTrimNode);
      sysSplit = connectStereoToMix(sysTrimNode);
      sysMonGain = ac.createGain(); sysMonGain.gain.value = 0; // muted by default
      sysTrimNode.connect(sysMonGain).connect(ac.destination);
      btnSysMonMute.classList.remove('btn-active'); btnSysMonMute.classList.add('btn-ghost'); btnSysMonMute.textContent='Unmute system monitor'; sysMonState.textContent='(muted)'; sysMonitorMuted=true;
      const set = track.getSettings?track.getSettings():{};
      info.srcKind.textContent=track.kind||'audio'; info.cc.textContent=set.channelCount??'unknown'; info.sr.textContent=ac.sampleRate+' Hz'; info.stOK.textContent=(set.channelCount>=2?'Yes':'Uncertain/Mono?');
      btnTab.disabled=true; btnStop.disabled=false; dbgTab.textContent='yes';
    }catch(e){ alert(e.message||e) }
  }
  function stopCapture(){
    try{ sysStream && sysStream.getTracks().forEach(t=>t.stop()) }catch{}
    try{ sysSrc && sysSrc.disconnect() }catch{} try{ sysTrimNode && sysTrimNode.disconnect() }catch{} try{ sysSplit && sysSplit.disconnect() }catch{} try{ sysMonGain && sysMonGain.disconnect() }catch{}
    sysStream=null; sysSrc=null; sysTrimNode=null; sysSplit=null; sysMonGain=null; sysMonitorMuted=true; btnSysMonMute.textContent='Unmute system monitor'; sysMonState.textContent='(muted)'; btnSysMonMute.classList.remove('btn-active'); btnSysMonMute.classList.add('btn-ghost'); btnTab.disabled=false; btnStop.disabled=true; dbgTab.textContent='no';
  }
  function toggleSysMonitorMute(){
    if(!sysMonGain) return;
    sysMonitorMuted = !sysMonitorMuted; sysMonGain.gain.value = sysMonitorMuted ? 0 : parseFloat(sysMonGainEl.value);
    sysMonVal.textContent = sysMonGainEl.value;
    if (sysMonitorMuted){ btnSysMonMute.classList.remove('btn-active'); btnSysMonMute.classList.add('btn-ghost'); btnSysMonMute.textContent='Unmute system monitor'; sysMonState.textContent='(muted)'; }
    else { btnSysMonMute.classList.add('btn-active'); btnSysMonMute.classList.remove('btn-ghost'); btnSysMonMute.textContent='Mute system monitor'; sysMonState.textContent='(on)'; }
    
    // Update monitor status display
    const monitorStatus = document.getElementById('monitorStatus');
    const genStatus = monitorMuted ? '<b>OFF</b>' : '<b>ON</b>' + (!monitorMuted ? ' (default)' : '');
    const sysStatus = sysMonitorMuted ? '<b>OFF</b>' + (sysMonitorMuted ? ' (default)' : '') : '<b>ON</b>';
    monitorStatus.innerHTML = `System monitor: ${sysStatus}<br>Generator monitor: ${genStatus}`;
  }
  sysMonGainEl.addEventListener('input', ()=>{ sysMonVal.textContent=sysMonGainEl.value; if(sysMonGain && !sysMonitorMuted){ sysMonGain.gain.value=parseFloat(sysMonGainEl.value) } });

  // ------- Generator -------
  // Exakt -18.00 dBFS RMS för sinus ⇒ A = √2 * 10^(-18/20) ≈ 0.177827941
  const SINE_A_FOR_MINUS18 = Math.SQRT2 * Math.pow(10, -18/20);
  let genOsc=null, genGain=null, leftGain=null, rightGain=null, merger=null, genMonGain=null; let monitorMuted=false;

  async function startGenerator(){
    await ac.resume();
    if(genOsc) return;

    genOsc = ac.createOscillator(); genOsc.type='sine'; genOsc.frequency.value=440;
    genGain = ac.createGain(); genGain.gain.value=SINE_A_FOR_MINUS18; // exakt -18 dBFS RMS
    leftGain = ac.createGain(); rightGain = ac.createGain(); leftGain.gain.value=1; rightGain.gain.value=1;
    merger = ac.createChannelMerger(2);
    genOsc.connect(genGain); genGain.connect(leftGain); genGain.connect(rightGain);
    leftGain.connect(merger,0,0); rightGain.connect(merger,0,1);

    genMonGain = ac.createGain(); genMonGain.gain.value = 0; // monitor muted default
    merger.connect(genMonGain).connect(ac.destination);

    const genSplit = ac.createChannelSplitter(2);
    merger.connect(genSplit);
    genSplit.connect(mixL,0); genSplit.connect(mixR,1);
    genSplit.connect(kHP_L,0); genSplit.connect(kHP_R,1);

    genOsc.start();
    btnTone.textContent='Stop tone'; dbgGen.textContent='yes';
    btnMonMute.classList.add('btn-active'); btnMonMute.classList.remove('btn-ghost'); btnMonMute.textContent='Mute generator monitor'; monState.textContent='(on)'; monitorMuted = false;
  }
  async function stopGenerator(){
    try{ genOsc && genOsc.stop() }catch{}
    [genGain,leftGain,rightGain,merger,genMonGain].forEach(n=>{ try{ n && n.disconnect && n.disconnect() }catch{} });
    genOsc=null; genGain=null; leftGain=null; rightGain=null; merger=null; genMonGain=null; btnTone.textContent='Start/Stop tone'; dbgGen.textContent='no';
  }
  function toggleGenMonitorMute(){
    if(!genMonGain) return;
    monitorMuted = !monitorMuted; genMonGain.gain.value = monitorMuted ? 0 : parseFloat(monGainEl.value);
    monVal.textContent = monGainEl.value;
    if (monitorMuted){ btnMonMute.classList.remove('btn-active'); btnMonMute.classList.add('btn-ghost'); btnMonMute.textContent='Unmute generator monitor'; monState.textContent='(muted)'; }
    else { btnMonMute.classList.add('btn-active'); btnMonMute.classList.remove('btn-ghost'); btnMonMute.textContent='Mute generator monitor'; monState.textContent='(on)'; }
    
    // Update monitor status display
    const monitorStatus = document.getElementById('monitorStatus');
    const genStatus = monitorMuted ? '<b>OFF</b>' : '<b>ON</b>' + (!monitorMuted ? ' (default)' : '');
    const sysStatus = sysMonitorMuted ? '<b>OFF</b>' + (sysMonitorMuted ? ' (default)' : '') : '<b>ON</b>';
    monitorStatus.innerHTML = `System monitor: ${sysStatus}<br>Generator monitor: ${genStatus}`;
  }
  monGainEl.addEventListener('input', ()=>{ monVal.textContent=monGainEl.value; if(genMonGain && !monitorMuted){ genMonGain.gain.value=parseFloat(monGainEl.value) } });

  // ------- Sidebar Collapse System -------
  function initSidebarToggle() {
    const sidebarToggle = document.getElementById('sidebarToggle');
    const wrap = document.getElementById('wrap');
    const metersSection = document.querySelector('.visning');
    let isCollapsed = false;
    
    // Function to update toggle button vertical position (center to meters panel)
    function updateToggleVerticalPosition() {
      if (metersSection) {
        const metersRect = metersSection.getBoundingClientRect();
        const centerY = metersRect.top + (metersRect.height / 2);
        sidebarToggle.style.top = centerY + 'px';
      }
    }
    
    // Update vertical position on load and resize
    updateToggleVerticalPosition();
    window.addEventListener('resize', updateToggleVerticalPosition);
    
    sidebarToggle.addEventListener('click', () => {
      isCollapsed = !isCollapsed;
      
      if (isCollapsed) {
        wrap.classList.add('sidebar-collapsed');
      } else {
        wrap.classList.remove('sidebar-collapsed');
      }
      
      // Update toggle vertical position after animation and trigger layout recalculation
      setTimeout(() => {
        updateToggleVerticalPosition();
        // **BEST PRACTICE 2025: Use scheduled layout update instead of direct call**
        scheduleLayoutUpdate(xyCard, layoutXY);
        // Trigger resize event for any other responsive elements
        window.dispatchEvent(new Event('resize'));
      }, 400);
    });
    
    // Keyboard shortcut: Ctrl/Cmd + B to toggle sidebar
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
        e.preventDefault();
        sidebarToggle.click();
      }
    });
  }

  // ------- Drag & Drop System -------
  let draggedElement = null;
  let dragOffset = { x: 0, y: 0 };
  let isDragging = false;
  
  // **BEST PRACTICE 2025: Drag-Aware Layout Management**
  // Prevents layout thrashing during drag operations by freezing expensive calculations
  let isDragLayoutFrozen = false;
  
  // **BEST PRACTICE 2025: Debounced ResizeObserver Pattern**
  // Prevents cascade resize events and ensures smooth performance during layout changes
  const resizeDebouncer = new Map();
  
  /**
   * Schedules layout updates using requestAnimationFrame to prevent blocking the main thread
   * @param {Element} element - The element being observed for resize
   * @param {Function} callback - The layout function to execute
   */
  function scheduleLayoutUpdate(element, callback) {
    // Cancel any pending layout update for this element
    if (resizeDebouncer.has(element)) {
      cancelAnimationFrame(resizeDebouncer.get(element));
    }
    
    // Schedule new update on next available frame
    const rafId = requestAnimationFrame(() => {
      try {
        resizeDebouncer.delete(element);
        
        // **BEST PRACTICE 2025: Performance monitoring for layout operations**
        const startTime = performance.now();
        callback();
        const endTime = performance.now();
        
        // Log performance warnings for slow layout operations (>16ms = missing 60fps)
        if (endTime - startTime > 16) {
          console.warn(`Layout operation took ${(endTime - startTime).toFixed(2)}ms - may affect 60fps performance`);
        }
        
      } catch (error) {
        console.error('Layout update failed:', error);
        // Remove failed element from debouncer to prevent stuck states
        resizeDebouncer.delete(element);
      }
    });
    
    resizeDebouncer.set(element, rafId);
  }
  
  /**
   * Canvas State Preservation Pattern for Vectorscope
   * Prevents visual "zoom-in" effects during drag operations by preserving canvas content
   */
  function preserveCanvasState() {
    // Skip if canvas isn't properly initialised
    if (!xy || !xy.width || !xy.height || !xyCtx) {
      console.debug('Canvas preservation skipped - canvas not ready');
      return () => {};
    }
    
    try {
      const canvasState = {
        width: xy.width,
        height: xy.height,
        imageData: xyCtx.getImageData(0, 0, xy.width, xy.height)
      };
      
      // **BEST PRACTICE 2025: Memory-conscious canvas handling**
      // Return restoration function with cleanup capabilities
      return () => {
        try {
          if (xy.width === canvasState.width && xy.height === canvasState.height) {
            xyCtx.putImageData(canvasState.imageData, 0, 0);
          } else {
            console.debug('Canvas dimensions changed, skipping restoration');
          }
        } catch (error) {
          console.warn('Canvas restoration failed:', error);
        }
      };
      
    } catch (error) {
      console.warn('Canvas state preservation failed:', error);
      return () => {};
    }
  }

  function initDragAndDrop() {
    const meterPanels = document.querySelectorAll('.meter');
    
    meterPanels.forEach(panel => {
      // Mouse events
      panel.addEventListener('mousedown', handleDragStart);
      panel.addEventListener('dragover', handleDragOver);
      panel.addEventListener('drop', handleDrop);
      
      // Touch events for mobile
      panel.addEventListener('touchstart', handleTouchStart);
      
      // Make draggable
      panel.draggable = true;
      panel.addEventListener('dragstart', handleDragStartNative);
    });

    // Global events
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('touchmove', handleTouchMove);
    document.addEventListener('touchend', handleTouchEnd);
  }

  function handleDragStart(e) {
    // **FIX: Only start drag on actual mouse movement, not on click**
    // Store mouse position but don't activate visual drag state yet
    const rect = e.currentTarget.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    // Store potential drag element but don't activate drag state
    draggedElement = e.currentTarget;
    
    // Don't add dragging class or freeze layout until actual movement occurs
    // This prevents static blue highlighting on simple clicks
  }

  function handleDragStartNative(e) {
    // **FIX: Clear any previous dragging states (only one panel at a time)**
    document.querySelectorAll('.meter.dragging').forEach(el => {
      el.classList.remove('dragging');
    });
    
    draggedElement = e.currentTarget;
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', e.currentTarget.outerHTML);
    
    // **BEST PRACTICE 2025: Preserve vectorscope canvas state before potential layout changes**
    const restoreCanvas = preserveCanvasState();
    
    // **BEST PRACTICE 2025: Freeze layout system to prevent visual glitches**
    isDragLayoutFrozen = true;
    
    // **FIX: Immediately activate drag state for native drag-and-drop**
    // Native drag-and-drop needs immediate visual feedback
    isDragging = true;
    
    // Delay to allow visual state to update
    setTimeout(() => {
      if (draggedElement) {
        draggedElement.classList.add('dragging');
        // Restore canvas if it was affected by the visual state change
        restoreCanvas();
      }
    }, 0);
  }

  function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    // Remove drag-over from all elements first
    document.querySelectorAll('.meter').forEach(el => {
      el.classList.remove('drag-over');
    });
    
    // Only add to current target if it's valid
    if (e.currentTarget !== draggedElement && e.currentTarget.classList.contains('meter')) {
      e.currentTarget.classList.add('drag-over');
    }
  }

  function handleDrop(e) {
    e.preventDefault();
    
    const dropTarget = e.currentTarget;
    dropTarget.classList.remove('drag-over');
    
    if (draggedElement && dropTarget !== draggedElement && dropTarget.classList.contains('meter')) {
      // Swap positions
      swapElements(draggedElement, dropTarget);
    }
    
    // **BEST PRACTICE 2025: Restore layout system after drag operation**
    isDragLayoutFrozen = false;
    
    // **FIX: Properly clean up all drag state**
    if (draggedElement) {
      draggedElement.classList.remove('dragging');
      draggedElement = null;
    }
    
    // Reset drag state
    isDragging = false;
    
    // Remove drag-over from all elements
    document.querySelectorAll('.meter').forEach(el => {
      el.classList.remove('drag-over');
    });
    
    // **BEST PRACTICE 2025: Schedule vectorscope layout update after drag completion**
    scheduleLayoutUpdate(xyCard, layoutXY);
  }

  function handleTouchStart(e) {
    const touch = e.touches[0];
    const rect = e.currentTarget.getBoundingClientRect();
    dragOffset.x = touch.clientX - rect.left;
    dragOffset.y = touch.clientY - rect.top;
    
    draggedElement = e.currentTarget;
    draggedElement.classList.add('dragging');
    isDragging = true;
    
    // **BEST PRACTICE 2025: Freeze layout during touch drag operations**
    isDragLayoutFrozen = true;
    
    e.preventDefault();
  }

  function handleDragMove(e) {
    // **FIX: Only activate drag state when actual movement occurs**
    if (!draggedElement) return;
    
    // Calculate movement distance from initial mouse position
    const rect = draggedElement.getBoundingClientRect();
    const currentX = e.clientX;
    const currentY = e.clientY;
    const initialX = rect.left + dragOffset.x;
    const initialY = rect.top + dragOffset.y;
    
    const distance = Math.sqrt(
      Math.pow(currentX - initialX, 2) + Math.pow(currentY - initialY, 2)
    );
    
    // Only activate drag state if mouse moved more than 5 pixels
    // This prevents accidental drag activation on clicks
    if (distance > 5 && !isDragging) {
      isDragging = true;
      isDragLayoutFrozen = true;
      
      // Clear any other dragging panels (only one at a time)
      document.querySelectorAll('.meter.dragging').forEach(el => {
        if (el !== draggedElement) {
          el.classList.remove('dragging');
        }
      });
      
      // Now activate visual drag state
      draggedElement.classList.add('dragging');
    }
  }

  function handleTouchMove(e) {
    if (!isDragging || !draggedElement) return;
    
    const touch = e.touches[0];
    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
    
    // Remove previous drag-over
    document.querySelectorAll('.meter').forEach(el => {
      el.classList.remove('drag-over');
    });
    
    // Add drag-over to current target
    if (elementUnderTouch && elementUnderTouch.classList.contains('meter') && elementUnderTouch !== draggedElement) {
      elementUnderTouch.classList.add('drag-over');
    }
    
    e.preventDefault();
  }

  function handleDragEnd(e) {
    // **FIX: Clean up drag state properly**
    if (draggedElement) {
      draggedElement.classList.remove('dragging');
    }
    
    // Reset all drag state variables
    draggedElement = null;
    isDragging = false;
    
    // **BEST PRACTICE 2025: Restore layout system after mouse drag**
    isDragLayoutFrozen = false;
    scheduleLayoutUpdate(xyCard, layoutXY);
  }

  function handleTouchEnd(e) {
    if (!isDragging || !draggedElement) return;
    
    const touch = e.changedTouches[0];
    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
    
    if (elementUnderTouch && elementUnderTouch.classList.contains('meter') && elementUnderTouch !== draggedElement) {
      swapElements(draggedElement, elementUnderTouch);
    }
    
    // Clean up
    draggedElement.classList.remove('dragging');
    document.querySelectorAll('.meter').forEach(el => {
      el.classList.remove('drag-over');
    });
    
    draggedElement = null;
    isDragging = false;
    
    // **BEST PRACTICE 2025: Restore layout system after touch drag**
    isDragLayoutFrozen = false;
    scheduleLayoutUpdate(xyCard, layoutXY);
  }

  function swapElements(el1, el2) {
    // Add transition class for smooth animation
    el1.classList.add('transitioning');
    el2.classList.add('transitioning');
    
    // Create temporary placeholder
    const temp = document.createElement('div');
    temp.style.display = 'none';
    
    // Insert temp before el1
    el1.parentNode.insertBefore(temp, el1);
    
    // Move el1 to where el2 is
    el2.parentNode.insertBefore(el1, el2);
    
    // Move el2 to where el1 was (temp position)
    temp.parentNode.insertBefore(el2, temp);
    
    // Remove temp
    temp.remove();
    
    // Remove transition class after animation
    setTimeout(() => {
      el1.classList.remove('transitioning');
      el2.classList.remove('transitioning');
    }, 400);
  }

  // ------- Loop -------
  let startTs=performance.now(); let leftMuteTimer=0;
  function loop(){
    if (muteLeft.checked && leftGain){
      leftMuteTimer += 16.7; const period=1500, win=500;
      const on = (leftMuteTimer % period) >= win; const target = on ? 1 : 0;
      if (leftGain.gain.value !== target){ leftGain.gain.setValueAtTime(target, ac.currentTime) }
    }
    layoutXY(); updatePPM(); drawXY(); drawCorr(); drawDBFS(); drawTruePeak(); updateR128();
    // Pass momentary LUFS to radar for live value
    let mVal = parseFloat(lufsM && lufsM.dataset.v);
    drawLoudnessRadar(isFinite(mVal) ? mVal : undefined);
    uptimeEl.textContent = ((performance.now()-startTs)/1000).toFixed(1);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  
  // **BEST PRACTICE 2025: Modern ResizeObserver Implementation**
  // Replaces multiple observers with debounced, scheduled updates to prevent cascade resize events
  
  /**
   * Intersection Observer for Visibility-Based Updates
   * Only triggers layout updates when vectorscope is actually visible to user
   */
  const visibilityObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting && !isDragLayoutFrozen) {
        scheduleLayoutUpdate(entry.target, layoutXY);
      }
    });
  }, {
    // Trigger when at least 10% of the element is visible
    threshold: 0.1
  });
  
  /**
   * Modern ResizeObserver with Debouncing
   * Prevents layout thrashing by using scheduled updates
   */
  const modernResizeObserver = new ResizeObserver((entries) => {
    entries.forEach(entry => {
      // Only process if not currently dragging
      if (!isDragLayoutFrozen) {
        scheduleLayoutUpdate(entry.target, layoutXY);
      }
    });
  });
  
  // Observe key elements with modern pattern
  modernResizeObserver.observe(meters);
  modernResizeObserver.observe(xyCard);
  visibilityObserver.observe(xyCard);

  // ------- Bind -------
  btnTab.onclick  = startTabCapture; btnStop.onclick = stopCapture; btnTone.onclick = async()=>{ if(!genOsc) await startGenerator(); else await stopGenerator(); };
  btnMonMute.onclick = toggleGenMonitorMute; btnSysMonMute.onclick = toggleSysMonitorMute;

  // ------- Boot: ingen auto-ton, allt muted default -------
  let booted=false; async function boot(){ if(booted) return; booted=true; await ac.resume(); }
  ['pointerdown','click','keydown','touchstart'].forEach(evt=>window.addEventListener(evt, boot, { once:true, passive:true }));
  
  // Initialize systems
  initSidebarToggle();
  initDragAndDrop();
  
  // **BEST PRACTICE 2025: Cleanup Functions for Memory Management**
  // Proper cleanup prevents memory leaks in long-running applications
  
  /**
   * Cleanup function for when the application is unloaded
   * Cancels all pending animations and disconnects observers
   */
  function cleanup() {
    // Cancel all pending layout updates
    resizeDebouncer.forEach((rafId) => {
      cancelAnimationFrame(rafId);
    });
    resizeDebouncer.clear();
    
    // Disconnect observers
    if (modernResizeObserver) {
      modernResizeObserver.disconnect();
    }
    if (visibilityObserver) {
      visibilityObserver.disconnect();
    }
    
    console.debug('TSG Audio Meters: Cleanup completed');
  }
  
  // Register cleanup for page unload
  window.addEventListener('beforeunload', cleanup);
  
  // **DEVELOPMENT MODE: Performance monitoring and debugging**
  if (typeof window !== 'undefined' && window.location?.hostname === 'localhost') {
    // Enable performance monitoring in development
    console.log('TSG Audio Meters: Development mode active');
    console.log('- Drag-aware layout system: ✓');
    console.log('- Modern ResizeObserver pattern: ✓');
    console.log('- CSS Container Queries: ✓');
    console.log('- Canvas state preservation: ✓');
    console.log('- Memory cleanup handlers: ✓');
  }
})();
</script>
</body>
</html>          