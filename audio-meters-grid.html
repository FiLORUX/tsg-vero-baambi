<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TSG Suite | VEROBAAMBI</title>
  <style>
    :root{
      --bg:#141618; --panel:#1b1f23; --ink:#e8eef9; --muted:#a9b2c7; --outline:#2a2f36; --grid:#29323b;
      --ok:#58d38c; --warn:#ffde58; --caution:#ff9a2d; --hot:#ff5a63; --cyan:#69bfff;
      --btn:#2d6bff; --btn-dark:#1e4edd; --btn-ghost:#0b1222;
      --meter-gap: 1.2em;
      /* **BEST PRACTICE 2025: Modern CSS Custom Properties for Performance** */
      /* Centralised values for consistent theming and easy maintenance */
      --drag-transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --canvas-border-radius: 10px;
      --vectorscope-min-size: 160px;
      --resize-debounce-delay: 16ms; /* ~60fps */
      --visibility-threshold: 0.1; /* 10% visibility for intersection observer */
    }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
    header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,rgba(20,22,24,.95),rgba(20,22,24,.6));backdrop-filter:saturate(140%) blur(8px);border-bottom:1px solid var(--outline)}
    h1{margin:0;padding:16px 20px;font-size:16px;letter-spacing:.3px}
    /* Loudness Radar Panel (RTW/TC style) - Responsiv layout */
    .loudnessRadarModule {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      align-items: stretch;
      justify-content: center;
      height: 100%;
      gap: 12px;
      min-height: 0;
      position: relative;
      min-width: 0;
      overflow: hidden;
    }
    .loudnessRadarModule .canvasPad {
      flex: 1 1 180px;
      min-width: 100px;
      max-width: min(50%, 340px);
      aspect-ratio: 1/1;
      margin: 0;
      background: none;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      min-height: 0;
    }
    #loudnessRadar {
      width: 100%;
      height: 100%;
      aspect-ratio: 1/1;
      background: #181c20;
      border-radius: 50%;
      border: 2px solid var(--outline);
      box-shadow: 0 4px 24px rgba(0,0,0,0.25);
      display: block;
      max-width: 100%;
      min-width: 80px;
      min-height: 80px;
    }
    .r128-subpanel {
      flex: 1 1 180px;
      min-width: 140px;
      max-width: 320px;
      background: rgba(20,22,24,0.92);
      border-radius: 10px;
      border: 1px solid var(--outline);
      box-shadow: 0 2px 8px rgba(0,0,0,0.10);
      padding: 10px 12px 8px 12px;
      margin-top: 0;
      font-size: 14px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      justify-content: flex-start;
      overflow: hidden;
      min-height: 0;
    }
    .r128-subpanel header {
  font-size: 13px;
  color: var(--muted);
  margin-bottom: 4px;
  font-weight: 700;
  letter-spacing: .2px;
  display: flex;
  align-items: center;
  gap: 8px;
    }

    /* LUFS value overlay i radar center */
    .loudnessRadarModule .canvasPad .radar-lufs-value {
      position: absolute;
      left: 0; right: 0; top: 0; bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      font-size: clamp(1.2rem, 4vw, 2.5rem);
      font-weight: 800;
      color: var(--cyan);
      text-shadow: 0 2px 12px #000, 0 0 2px #69bfff;
      letter-spacing: 0.5px;
      z-index: 2;
    }

    /* R128 värden - responsiva */
    .r128 .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .r128 .big {
      font-size: clamp(16px, 3vw, 26px);
      font-weight: 800;
      letter-spacing: .3px;
      white-space: nowrap;
    }
    .r128 small {
      color: #a9b2c7;
      font-size: clamp(10px, 1.5vw, 12px);
      white-space: nowrap;
    }

    .wrap{
      box-sizing:border-box;
      padding:20px;
      display:grid;
      gap:16px;
      grid-template-columns: var(--sidebar-width, 360px) 1fr;
      grid-template-rows: 1fr; 
      height:calc(100dvh - 56px);
      transition: grid-template-columns 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    /*
     * Sidebar Collapse System - GPU-only animation
     * Använder ENDAST transform + opacity (GPU-accelererad)
     * Ingen grid-template-columns ändring = ingen layout thrash
     */
    .sidebar-container {
      position: relative;
      overflow: visible;
      /* GPU-hint för smooth animation */
      will-change: transform;
    }

    .sidebar-content {
      display: grid;
      gap: 16px;
      grid-template-rows: 2fr 1fr 1fr;
      height: 100%;
      /* GPU-only properties */
      will-change: transform, opacity;
    }

    /* Animerade transitions - läggs till efter page load */
    .sidebar-ready .sidebar-container {
      transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .sidebar-ready .sidebar-content {
      transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                  opacity 0.3s ease;
    }

    .sidebar-ready .wrap {
      transition: grid-template-columns 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    /* Collapsed state */
    .wrap.sidebar-collapsed {
      grid-template-columns: 48px 1fr;
    }

    .sidebar-collapsed .sidebar-content {
      transform: translateX(-100%);
      opacity: 0;
      pointer-events: none;
    }

    /* Initial collapsed state (ingen animation vid page load) */
    .sidebar-start-collapsed .wrap {
      grid-template-columns: 48px 1fr;
    }

    .sidebar-start-collapsed .sidebar-content {
      transform: translateX(-100%);
      opacity: 0;
      pointer-events: none;
    }
    
    .collapse-toggle {
      position: fixed;
      left: calc(var(--sidebar-width, 360px) + 20px - 24px);
      transform: translateY(-50%);
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--panel), rgba(147, 197, 253, 0.1));
      border: 1px solid var(--outline);
      border-radius: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 4px 16px rgba(0,0,0,.25);
    }
    
    /* Collapsed state för toggle */
    .sidebar-collapsed .collapse-toggle,
    .sidebar-start-collapsed .collapse-toggle {
      left: 24px;
      opacity: 0;
    }

    /* Transition endast när ready */
    .sidebar-ready .collapse-toggle {
      transition: left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                  opacity 0.3s ease 0.2s;
    }

    /* Hover-zone: visa toggle när man hovrar vänstra kanten eller själva toggle */
    .sidebar-collapsed .sidebar-container:hover .collapse-toggle,
    .sidebar-collapsed .collapse-toggle:hover,
    .sidebar-start-collapsed .sidebar-container:hover .collapse-toggle,
    .sidebar-start-collapsed .collapse-toggle:hover {
      opacity: 1;
    }

    .sidebar-ready .sidebar-collapsed .collapse-toggle:hover,
    .sidebar-ready .sidebar-collapsed .sidebar-container:hover .collapse-toggle {
      transition-delay: 0s;
    }
    
    .collapse-toggle:hover {
      background: linear-gradient(135deg, rgba(147, 197, 253, 0.2), rgba(34, 211, 238, 0.1));
      box-shadow: 0 6px 24px rgba(0,0,0,.35), 0 0 16px rgba(147, 197, 253, 0.3);
      transform: translateY(-50%) scale(1.05);
      border-color: rgba(147, 197, 253, 0.5);
    }
    
    .collapse-toggle svg {
      width: 20px;
      height: 20px;
      fill: var(--ink);
    }

    .sidebar-ready .collapse-toggle svg {
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .sidebar-collapsed .collapse-toggle svg,
    .sidebar-start-collapsed .collapse-toggle svg {
      transform: rotate(180deg);
    }
    
    .collapse-toggle:hover svg {
      fill: rgba(147, 197, 253, 0.9);
    }
    .card{background:var(--panel);border:1px solid var(--outline);border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.25);padding:14px;min-height:0;overflow:hidden}
    .card h2{margin:0 0 10px;font-size:13px;color:var(--muted);letter-spacing:.35px;font-weight:700;text-transform:uppercase}

    .visning{
      grid-column:2;
      grid-row:1;
      display:grid;
      grid-template-rows:auto 1fr;
      gap:12px;
      min-height:0;
      transition: margin 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      margin-right: 0;
    }

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{background:var(--btn);border:0;color:white;padding:9px 12px;border-radius:11px;font-weight:700;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    .btn-ghost{background:var(--btn-ghost);color:var(--ink);border:1px solid #2a3a5f}
    .btn-active{background:var(--btn-dark)}

    label{font-size:12px;color:var(--muted)}
    code.small{font-size:12px;color:var(--muted)}

    /* Visning */
    .meters{display:grid;grid-template-columns:7fr 3fr;grid-template-rows:1fr;height:100%;gap:12px;min-height:0;overflow:hidden}
    .stack-left{
      display: grid;
      grid-template-rows: 2fr 1fr 1fr 1fr;  /* Loudness 2fr, RMS/TP/VU 1fr vardera */
      gap: 12px;
      min-height: 0;
      align-items: stretch;
      grid-auto-rows: 1fr;
      height: 100%;
    }
    .stack-right{display:grid;grid-template-rows:1fr;gap:12px;min-height:0}
    .meter{
      background: #111416;
      border: 1px solid var(--outline);
      border-radius: 12px;
      padding: var(--meter-gap) 2vw;
      position: relative;
      min-height: 0;
      display: flex;
      flex-direction: column;
      flex: 1 1 0;
      height: 100%;
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }
    .meter header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--meter-gap);
    }
    .badge{font-size:11px;padding:3px 8px;border-radius:999px;border:1px solid var(--outline);background:#0f1214;color:#cfe1ff}
    .tiny{opacity:.85;font-size:12px}

    canvas{display:block;width:100%;height:160px;background:#0d0f11;border-radius:10px;border:1px solid var(--outline)}

/* XY + Corr (vertikal layout: goniometer ovan, correlation under) */
/* Båda ska ALLTID vara kvadratiska */
.xyGrid {
  display: flex;
  flex-direction: column;
  gap: 12px;
  align-items: center;
  justify-content: flex-start;
  width: 100%;
  height: 100%;
}

.xySquare, .corrWrap {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-width: 0;
  aspect-ratio: 1;  /* ALLTID kvadratisk */
}

/* Goniometer: ALLTID kvadratisk, storlek sätts av JS */
.xySquare {
  flex: 0 0 auto;
  min-width: 120px;
  min-height: 120px;
  margin: 0 auto;
}

/* Correlation: ALLTID kvadratisk, storlek sätts av JS */
.corrWrap {
  flex: 0 0 auto;
  min-width: 60px;
  min-height: 60px;
  margin: 0 auto;
}

.corrWrap .canvasPad {
  height: 100%;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

#xy {
  width: 100% !important;
  height: 100% !important;
  display: block;
  aspect-ratio: 1;
}

#corr {
  width: 100% !important;
  height: 100% !important;
  display: block;
  aspect-ratio: 1;
}

.xySquare .overlay {
  position: absolute;
  left: 50%;
  bottom: 8px;
  transform: translateX(-50%);
  z-index: 2;
  pointer-events: none;
}

.corrWrap .overlay {
  position: absolute;
  left: 50%;
  bottom: 8px;
  transform: translateX(-50%);
  z-index: 2;
  pointer-events: none;
}

/*
 * Tabular Numbers - Framtidssäker implementation
 *
 * font-variant-numeric: tabular-nums gör att ALLA siffror får samma bredd
 * oavsett vilken font som används (så länge fonten stöder OpenType tnum).
 *
 * Detta är den moderna standarden (CSS Fonts Module Level 4) och tillåter
 * fritt byte av typsnitt utan att siffror "hoppar".
 *
 * Fallback: font-feature-settings för äldre browsers.
 * Monospace-fallback endast om fonten saknar tnum-stöd.
 */
.tabular-nums,
.mono-num,
.big,
.hLabel b,
.overlay b,
#r128Time,
#corrVal,
#monoDevVal,
#lufsM,
#lufsS,
#lufsI,
#lra,
#r128TpMax {
  font-variant-numeric: tabular-nums;
  font-feature-settings: "tnum" 1; /* Fallback för äldre browsers */
}

/*
 * För element som KRÄVER absolut fixed-width (t.ex. timers, counters)
 * kan man lägga till monospace som extra säkerhet:
 */
.mono-num-strict {
  font-variant-numeric: tabular-nums;
  font-feature-settings: "tnum" 1;
  font-family: ui-monospace, 'SF Mono', 'Fira Code', monospace;
}

/* Mono Deviation meter */
.monoDevWrap {
  width: 100%;
  max-width: 200px;
  margin: 0 auto;
  padding: 8px 0;
}
.monoDevWrap .canvasPad {
  height: 32px;
  width: 100%;
}
.monoDevWrap canvas {
  border-radius: 6px !important;
}
.monoDevWrap .overlay {
  position: absolute;
  left: 50%;
  bottom: 4px;
  transform: translateX(-50%);
  font-size: 10px;
  padding: 1px 5px;
}

/* Canvas-pad gemensamma regler */
.canvasPad {
  width: 100%;
  height: 100%;
  position: relative;
}
.canvasPad > canvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  border-radius: 10px;
  border: 1px solid var(--outline);
  background: #0d0f11;
  box-sizing: border-box;
}

    /* Horisontella stapel-metrar */
    .hMeter{position:relative;height:100%;min-height:80px;margin-bottom: var(--meter-gap);}
    .hMeter canvas{position:absolute;inset:0;width:100%;height:100%}
    .hScale{position:absolute;inset:0;pointer-events:none}
    .hLabel{position:absolute;bottom:4px;left:8px;font-size:11px;color:#cfe1ff;background:rgba(0,0,0,.25);padding:2px 6px;border-radius:8px;border:1px solid #2a2f36}

    .overlay{position:absolute;left:10px;bottom:8px;background:rgba(0,0,0,.25);padding:2px 6px;border-radius:8px;font-size:12px;color:#cfe1ff;border:1px solid #2a2f36;text-align:left}
    .gonio-overlay{left:auto;right:10px}

    /* R128 – sifferpanel (huvudregler finns ovan) */
    .r128{display:flex;flex-direction:column;gap:6px;min-height:0;overflow:hidden}

    .kv{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:8px}
    .kv div{background:#0f1214;border:1px solid var(--outline);border-radius:9px;padding:6px 8px}
    .kv small{display:block;font-size:11px;color:#a9b2c7}
    .kv .wide{grid-column:span 2}

    input[type="number"]{width:78px;background:#0f1214;border:1px solid #2a2f36;border-radius:8px;color:var(--ink);padding:6px}
    .hdr{display:flex;align-items:center;justify-content:space-between;padding:6px 20px}
    .brand{flex:1 1 60%;min-width:480px}
    .brand svg{display:block;height:64px;width:100%}
    .status{color:var(--muted);font-weight:600;margin-left:8px;white-space:nowrap}
    .brand svg{display:block;height:60px;width:auto}
    .status{color:var(--muted);font-weight:600;margin-left:8px;white-space:nowrap}

    /* Divider/linje under rubrik */
    .meter .divider {
      border: none;
      border-top: 1px solid var(--outline);
      margin: 0 0 var(--meter-gap) 0;
      width: 100%;
      background: none;
    }
    /* Modul styles */
    .xyModule {
      height: 100%;
      display: flex;
      align-items: center;
      background: none;
      min-height: 0;
      padding: var(--meter-gap);
    }
    .hMeter {
      position: relative;
      height: 160px;
      margin-bottom: var(--meter-gap);
    }

    /* Drag & Drop Responsive Panels */
    .meter {
      cursor: grab;
    }

    .meter.dragging {
      cursor: grabbing;
        transition: var(--drag-transition);
        position: relative;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      .meter:hover {
        box-shadow: 0 8px 32px rgba(0,0,0,.4), 0 0 20px rgba(147, 197, 253, 0.3);
        border-color: rgba(147, 197, 253, 0.5);
        background: linear-gradient(135deg, var(--panel), rgba(147, 197, 253, 0.03));
      }

      .meter:hover h2 {
        color: rgba(147, 197, 253, 0.9);
        text-shadow: 0 0 8px rgba(147, 197, 253, 0.3);
      }

      .meter.dragging {
        cursor: grabbing;
        transform: scale(0.95);
        box-shadow: 0 16px 48px rgba(0,0,0,.6), 0 0 32px rgba(147, 197, 253, 0.2);
        border: 2px solid rgba(147, 197, 253, 0.3);
        z-index: 1000;
        background: linear-gradient(135deg, var(--panel), rgba(147, 197, 253, 0.02));
      }

      .meter.dragging::before {
        content: '';
        position: absolute;
        inset: -2px;
        border-radius: 16px;
        background: linear-gradient(45deg, rgba(147, 197, 253, 0.3), rgba(34, 211, 238, 0.3));
        z-index: -1;
        filter: blur(8px);
      }

      .meter.drag-over {
        border: 2px dashed rgba(147, 197, 253, 0.6);
        background: rgba(147, 197, 253, 0.05);
        animation: pulse-glow 1s ease-in-out infinite alternate;
      }

      .meter.transitioning {
        transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }

      @keyframes pulse-glow {
        0% { box-shadow: 0 0 16px rgba(147, 197, 253, 0.3); }
        100% { box-shadow: 0 0 24px rgba(147, 197, 253, 0.5); }
      }
  </style>
  <!-- Sidebar state BEFORE render - förhindrar "flash" -->
  <script>
    (function() {
      if (localStorage.getItem('tsg-sidebar-collapsed') === 'true') {
        document.documentElement.classList.add('sidebar-start-collapsed');
      }
    })();
  </script>
</head>
<body>
<header>
  <div class="hdr">
    <div class="brand">
      <!-- Vector logotyp: VEROBAAMBI utan mellanrum, BAAMBI tätare -->
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 4000 200"
     width="100%" height="auto"
     preserveAspectRatio="xMidYMid meet"
     role="img"
     aria-label="TSG Suite | VEROBAAMBI | Broadcast Audio Alignment & Meter Bridge Interface">
  <defs>
    <linearGradient id="lock-cyan" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="#38BDF8"/>
      <stop offset="1" stop-color="#22D3EE"/>
    </linearGradient>
  </defs>

  <text x="2%" y="50%" dominant-baseline="middle"
        font-family="Inter, Segoe UI, system-ui, -apple-system, Roboto, sans-serif"
        font-size="100">

    <!-- TSG Suite i samma cyan som tagline -->
    <tspan fill="#93C5FD" font-weight="800" letter-spacing="0.75">TSG Suite</tspan>

    <!-- separator -->
    <tspan fill="#6B7280" font-weight="300" dx="1.2em">|</tspan>

    <!-- VERO = extra bold -->
    <tspan fill="#E5E7EB" font-weight="950" letter-spacing="4" dx="1.2em">VERO</tspan>
    <!-- BAAMBI = väldigt tunn och tight -->
    <tspan fill="#E5E7EB" font-weight="200" letter-spacing="-3">BAAMBI</tspan>

    <!-- separator -->
    <tspan fill="#6B7280" font-weight="300" dx="1.2em">|</tspan>

    <!-- Tagline i samma cyan som TSG Suite -->
    <tspan fill="#93C5FD" font-weight="600" font-size="75" letter-spacing="2.5" dx="1.2em">
      Broadcast Audio Alignment &amp; Meter Bridge Interface
    </tspan>
  </text>
</svg>
    </div>
  </div>
</header>

<div id="wrap" class="wrap">
  <div class="sidebar-container">
    <div class="sidebar-content">
      <section class="card leftTop">
        <h2>System / Chrome tab</h2>
        <div class="row">
          <button id="btnTab">Start capture</button>
          <button id="btnStop" class="btn-ghost" disabled>Stop capture</button>
        </div>
        <p class="tiny">Captures via <code class="small">getDisplayMedia({audio:true})</code>. <b>Default:</b> monitoring OFF.</p>
        <div class="row" style="margin-top:6px;align-items:center">
          <label>System monitor:</label>
          <input type="range" id="sysMonGain" min="0" max="1" step="0.01" value="0.20" />
          <span id="sysMonVal" class="tiny">0.20</span>
          <button id="btnSysMonMute" class="btn-ghost">Unmute system monitor</button>
          <span id="sysMonState" class="tiny">(muted)</span>
        </div>
        <div class="row" style="align-items:center">
          <label>Line-up (Chrome, dB):</label>
          <input type="range" id="sysTrimRange" min="-48" max="24" step="0.1" value="0" />
          <input type="number" id="sysTrimInput" min="-48" max="24" step="0.1" value="0.0" />
          <span class="tiny" id="sysTrimOut">0.0 dB</span>
          <button id="sysTrimReset" class="btn-ghost" style="white-space:nowrap">Reset 0 dB</button>
        </div>
        <div class="kv" id="info">
          <div><small>Source</small><span id="srcKind">–</span></div>
          <div><small>Channel count</small><span id="cc">–</span></div>
          <div><small>Sample rate</small><span id="sr">–</span></div>
          <div><small>Stereo OK?</small><span id="stOK">–</span></div>
        </div>
        <p class="tiny">Tip: avoid feedback. Do <i>not</i> share this tab if you intend to enable the system monitor.</p>
      </section>

      <section class="card leftBottom">
        <h2>Internal test tone generator</h2>
        <div class="row" style="align-items:center;flex-wrap:wrap;gap:8px">
          <button id="btnTone">Start/Stop tone</button>
          <select id="genPreset" style="padding:4px 8px;border-radius:6px;background:#0f1214;border:1px solid var(--outline);color:var(--ink);font-size:12px">
            <option value="400" selected>400 Hz · EBU broadcast line-up</option>
            <option value="1000">1 kHz · digital test tone (AES-style)</option>
            <option value="997">997 Hz · FFT-optimised test tone</option>
            <option value="440">440 Hz · musical A (non-broadcast)</option>
          </select>
          <span class="badge" id="genBadge">400 Hz · −18 dBFS peak (0 dBu / 0 PPM · EBU alignment)</span>
        </div>
        <div class="row" style="margin-top:6px;align-items:center">
          <label><input type="checkbox" id="muteLeft"> EBU stereo-ID (L pulsed 250 ms / 3 s)</label>
          <span class="tiny" style="margin-left:8px;opacity:0.7">ITU-R BR.1385 / EBU R49</span>
        </div>
        <div class="row" style="margin-top:6px;align-items:center">
          <label>Generator monitor:</label>
          <input type="range" id="monGain" min="0" max="1" step="0.01" value="0.20" />
          <span id="monVal" class="tiny">0.20</span>
          <button id="btnMonMute" class="btn-ghost">Unmute generator monitor</button>
          <span id="monState" class="tiny">(muted)</span>
        </div>
      </section>

      <section class="card leftFooter">
        <h2>Status & live data</h2>
        <div class="kv">
          <div><small>Uptime (s)</small><span id="uptime">0.0</span></div>
          <div><small>AudioContext</small><span id="ctxState">–</span></div>
          <div><small>Tone running</small><span id="dbgGen">no</span></div>
          <div><small>Tab capture running</small><span id="dbgTab">no</span></div>
          <div class="wide"><small>Monitor status</small><span id="monitorStatus" class="tiny">System monitor: <b>OFF</b> (default)<br>Generator monitor: <b>ON</b> (default)</span></div>
        </div>
      </section>
    </div>
    
    <div class="collapse-toggle" id="sidebarToggle">
      <svg viewBox="0 0 24 24">
        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
      </svg>
    </div>
  </div>

  <section class="card visning">
    <h2>Meters</h2>
    <div class="meters" id="meters">
      <div class="stack-left">
        <div class="meter" id="loudnessRadarCard">
<header><label>Loudness</label><span class="badge">Radar + EBU R128</span></header>
          <div class="loudnessRadarModule">
            <!-- Radar canvas will be implemented here -->
            <div class="canvasPad">
              <canvas id="loudnessRadar"></canvas>
              <div class="radar-lufs-value" id="radarLufsValue">—</div>
            </div>
            <!-- Sub-panel: existing R128 loudness panel -->
            <div class="r128-subpanel">
              <header><label>Loudness (EBU R128)</label><span class="badge">M/S/I + LRA + TP</span></header>
              <div class="r128">
                <div class="row"><small>M</small><span class="big" id="lufsM">--.- LUFS</span></div>
                <div class="row"><small>S</small><span class="big" id="lufsS">--.- LUFS</span></div>
                <div class="row"><small>I</small><span class="big" id="lufsI">--.- LUFS</span></div>
                <div class="row"><small>LRA</small><span class="big" id="lra">--.- LU</span></div>
                <div class="row"><small>TP</small><span class="big" id="r128TpMax">--.- dBTP</span></div>
                <div class="row"><small title="Time since start or reset">Elapsed</small><span class="big" id="r128Time">--:--:--</span></div>
                <div class="row" style="margin-top:4px"><button class="btn-ghost" id="r128Reset" style="width:100%;padding:6px 0;font-size:11px">Reset</button></div>
              </div>
            </div>
          </div>
        </div>
        <div class="meter" id="dbfsCard">
          <header><label>Digital RMS (dBFS)</label><span class="badge">Average digital level · 0 dBFS = full-scale sine</span></header>
          <div class="hMeter">
            <canvas id="dbfs" height="160"></canvas>
            <div class="hScale" id="dbfsScale"></div>
            <span class="hLabel" id="dbfsLabel">L: <b id="dbL">--.-</b> · R: <b id="dbR">--.-</b> dBFS</span>
          </div>
        </div>
        <div class="meter" id="tpCard">
          <header><label>True Peak (dBTP)</label><span class="badge">4× oversampling · 0 dBTP = full scale</span></header>
          <div class="hMeter">
            <canvas id="tp" height="160"></canvas>
            <div class="hScale" id="tpScale"></div>
            <span class="hLabel" id="tpLabel">L: <b id="tpL">--.-</b> · R: <b id="tpR">--.-</b> dBTP</span>
          </div>
        </div>
        <div class="meter" id="ppmCard">
          <header><label>Nordic PPM</label><span class="badge">IEC Type I · 0 PPM = 0 dBu (−18 dBFS peak)</span></header>
          <div class="hMeter">
            <canvas id="ppmCanvas" height="160"></canvas>
            <div class="hScale" id="ppmScale"></div>
            <span class="hLabel" id="ppmLabel">L: <b id="ppmLVal">--.-</b> · R: <b id="ppmRVal">--.-</b> PPM</span>
          </div>
        </div>
      </div>
      <div class="stack-right">
        <div class="meter" id="xyCard">
          <header><label>Stereo Vectorscope (Goniometer + Phase Correlation)</label></header>
          <div class="xyModule">
            <div class="xyGrid">
              <div class="xySquare" id="xyWrap">
                <div class="canvasPad"><canvas id="xy"></canvas></div>
                <div class="overlay gonio-overlay">Mono = 45°</div>
              </div>
              <div class="corrWrap">
                <div class="canvasPad"><canvas id="corr"></canvas></div>
                <div class="overlay">ρ = <b id="corrVal">+-.--</b></div>
              </div>
              <div class="monoDevWrap">
                <div class="canvasPad"><canvas id="monoDev"></canvas></div>
                <div class="overlay">L/R = <b id="monoDevVal">--.-</b> dB</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
</div>

<script>
(async function(){

  // =====================================================
  // LOUDNESS RADAR MODULE (Clarity-style)
  // =====================================================
  const LoudnessRadar = (function() {
    'use strict';

    // ----- R A D A R  S C A L E  (Clarity-lik) -----
    // 10 ringar, 6 dB mellanrum: -5, -11, -17, -23, -29, -35, -41, -47, -53, -59
    const RADAR_MAX_LUFS = -5;
    const RADAR_MIN_LUFS = -59;
    const RADAR_RING_STEP = 6;
    const RADAR_TARGET_LUFS = -23; // EBU R128 broadcast target

    function lufsToRadius(lufs, rOuter, rInner) {
      const clamped = Math.max(RADAR_MIN_LUFS, Math.min(RADAR_MAX_LUFS, lufs));
      const t = (clamped - RADAR_MIN_LUFS) / (RADAR_MAX_LUFS - RADAR_MIN_LUFS); // 0..1
      // Yttre ring = t=1 ≈ "loud", inre = t=0 ≈ "tyst" – samma känsla som Clarity
      return rInner + (1 - t) * (rOuter - rInner);
    }

    // Clarity-style färgzoner
    function radarColorForLufs(lufs) {
      if (lufs > -11) return '#ff4335';   // röd – för högt
      if (lufs > -17) return '#ff9a2d';   // orange
      if (lufs > -23) return '#ffd94a';   // gul – runt target
      if (lufs > -29) return '#88d65c';   // ljusgrön
      if (lufs > -41) return '#2fbf8f';   // turkos/grön
      return '#1f2933';                   // mörk bakgrund för låg nivå
    }

    function drawRadarBackground(ctx, cx, cy, rOuter, rInner) {
      ctx.save();
      const gradient = ctx.createRadialGradient(cx, cy, rInner, cx, cy, rOuter);
      gradient.addColorStop(0, '#0a0c0e');
      gradient.addColorStop(1, '#181c20');
      ctx.beginPath();
      ctx.arc(cx, cy, rOuter, 0, 2 * Math.PI);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.strokeStyle = '#2a2f36';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, cy, rInner, 0, 2 * Math.PI);
      ctx.fillStyle = '#0d0f11';
      ctx.fill();
      ctx.strokeStyle = '#1a1e22';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }

    // Clarity-style grid med -23 target-ring
    function drawRadarGrid(ctx, cx, cy, rOuter, rInner) {
      ctx.save();
      ctx.lineCap = 'round';

      // Ringarna (var 6 dB)
      for (let lu = RADAR_MIN_LUFS; lu <= RADAR_MAX_LUFS; lu += RADAR_RING_STEP) {
        const r = lufsToRadius(lu, rOuter, rInner);
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);

        if (lu === RADAR_TARGET_LUFS) {
          // "Target"-ringen (-23 LUFS) – streckad, blå, starkare
          ctx.strokeStyle = '#40a0ff';
          ctx.setLineDash([4, 4]);
          ctx.lineWidth = 2.0;
        } else {
          ctx.strokeStyle = '#4b5563';
          ctx.setLineDash([2, 6]);
          ctx.lineWidth = 1.0;
        }
        ctx.stroke();
      }

      // Spokes var 30° (12 "klockslag")
      ctx.setLineDash([]);
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 1.0;
      for (let deg = 0; deg < 360; deg += 30) {
        const a = (deg - 90) * Math.PI / 180;   // 0° = kl 12
        const r1 = rInner * 0.6;
        const r2 = rOuter;
        ctx.beginPath();
        ctx.moveTo(cx + r1 * Math.cos(a), cy + r1 * Math.sin(a));
        ctx.lineTo(cx + r2 * Math.cos(a), cy + r2 * Math.sin(a));
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawRadarSegments(ctx, cx, cy, rOuter, rInner, history, maxAge) {
      ctx.save();
      const now = Date.now();
      const segmentCount = history.length;
      const anglePerSegment = (2 * Math.PI) / Math.max(segmentCount, 60);
      history.forEach((point, index) => {
        const age = now - point.t;
        if (age < 0 || age > maxAge) return;
        const normalizedAge = age / maxAge;
        const startAngle = (2 * Math.PI * normalizedAge) - Math.PI / 2;
        const endAngle = startAngle + anglePerSegment;
        const lufs = Math.max(RADAR_MIN_LUFS, Math.min(RADAR_MAX_LUFS, point.v));
        const r = lufsToRadius(lufs, rOuter, rInner);
        const color = radarColorForLufs(lufs);
        const opacity = 0.85 * (1 - normalizedAge * 0.3);
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, r, startAngle, endAngle);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.globalAlpha = opacity;
        ctx.fill();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 0.5;
        ctx.stroke();
      });
      if (history.length > 0) {
        const sweepAngle = -Math.PI / 2;
        ctx.globalAlpha = 0.9;
        ctx.strokeStyle = '#69bfff';
        ctx.lineWidth = 2;
        ctx.shadowColor = '#69bfff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + rOuter * Math.cos(sweepAngle), cy + rOuter * Math.sin(sweepAngle));
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
      ctx.restore();
    }

    // Radiella LUFS-labels längs kl 3-spaken (visar skalan för radie, inte vinkel)
    // Visa endast nyckelringar för läsbarhet: -5, -11, -17, -23 (target), -35, -47, -59
    const RADAR_SCALE_LABELS = [-5, -17, -23, -29, -41, -59];

    function drawRadarLabels(ctx, cx, cy, rOuter, rInner, canvasWidth) {
      ctx.save();
      const fontSize = Math.max(8, Math.floor(canvasWidth * 0.020));
      ctx.font = `600 ${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, sans-serif`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';

      // Placera labels längs kl 3-spaken (0 radianer = höger)
      const labelAngle = 0;

      RADAR_SCALE_LABELS.forEach(lufs => {
        const r = lufsToRadius(lufs, rOuter, rInner);
        const x = cx + r * Math.cos(labelAngle) + 3;
        const y = cy + r * Math.sin(labelAngle);

        // Highlight target (-23 LUFS)
        if (lufs === RADAR_TARGET_LUFS) {
          ctx.fillStyle = '#40a0ff';
          ctx.font = `700 ${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, sans-serif`;
        } else {
          ctx.fillStyle = '#6b7280';
          ctx.font = `600 ${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, sans-serif`;
        }
        ctx.fillText(lufs.toString(), x, y);
      });

      ctx.restore();
    }

    function drawCenterLUFS(ctx, cx, cy, rInner, momentaryLufs) {
      ctx.save();
      const fontSize = Math.max(14, rInner * 0.35);
      ctx.font = `800 ${fontSize}px ui-sans-serif, Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if (typeof momentaryLufs === 'number' && isFinite(momentaryLufs)) {
        const color = radarColorForLufs(momentaryLufs);
        ctx.shadowColor = color;
        ctx.shadowBlur = 10;
        ctx.fillStyle = color;
        ctx.fillText(momentaryLufs.toFixed(1), cx, cy);
      } else {
        ctx.fillStyle = '#6b7280';
        ctx.fillText('—', cx, cy);
      }
      ctx.restore();
    }

    function drawEmptyRadar(ctx, w, h) {
      const cx = w / 2;
      const cy = h / 2;
      const rOuter = Math.min(w, h) * 0.42;
      const rInner = rOuter * 0.12;
      drawRadarBackground(ctx, cx, cy, rOuter, rInner);
      drawRadarGrid(ctx, cx, cy, rOuter, rInner);
      drawRadarLabels(ctx, cx, cy, rOuter, rInner, w);
      ctx.save();
      ctx.font = '600 12px ui-sans-serif, Arial';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#6b7280';
      ctx.fillText('Waiting for audio...', cx, cy);
      ctx.restore();
    }

    function render(canvas, ctx, history, momentaryLufs, maxSeconds) {
      const w = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
      const h = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, w, h);
      if (!history.length) {
        drawEmptyRadar(ctx, w, h);
        return;
      }
      const cx = w / 2;
      const cy = h / 2;
      const rOuter = Math.min(w, h) * 0.42;
      const rInner = rOuter * 0.12;
      const maxAge = maxSeconds * 1000;
      drawRadarBackground(ctx, cx, cy, rOuter, rInner);
      drawRadarGrid(ctx, cx, cy, rOuter, rInner);
      drawRadarSegments(ctx, cx, cy, rOuter, rInner, history, maxAge);
      drawRadarLabels(ctx, cx, cy, rOuter, rInner, w);
      drawCenterLUFS(ctx, cx, cy, rInner, momentaryLufs);
    }

    return { render: render };
  })();
  
  function drawLoudnessRadar(momentaryLufs) {
    LoudnessRadar.render(loudnessRadar, loudnessRadarCtx, radarHistory, momentaryLufs, radarMaxSeconds);
  }

  // ------- DOM -------

  const wrap = document.getElementById('wrap');
  const meters = document.getElementById('meters');
  // --- Loudness Radar ---
  const loudnessRadar = document.getElementById('loudnessRadar');
  const loudnessRadarCtx = loudnessRadar.getContext('2d');
  // --- Stereo Vectorscope ---
  const xyCard = document.getElementById('xyCard');
  const xyWrap = document.getElementById('xyWrap');
  const xy = document.getElementById('xy'), xyCtx = xy.getContext('2d');
  const corr = document.getElementById('corr'), corrCtx = corr.getContext('2d');
  const corrVal = document.getElementById('corrVal');

  const dbfs = document.getElementById('dbfs'), dbfsScale = document.getElementById('dbfsScale');
  const dbL = document.getElementById('dbL'), dbR = document.getElementById('dbR');
  const tp = document.getElementById('tp'), tpScale = document.getElementById('tpScale');
  const tpL = document.getElementById('tpL'), tpR = document.getElementById('tpR');

  // --- R128 Subpanel ---
  const lufsM = document.getElementById('lufsM');
  const lufsS = document.getElementById('lufsS');
  const lufsI = document.getElementById('lufsI');
  const lraEl = document.getElementById('lra');

  // --- Radar Data Buffer ---
  // Holds the last 60s of short-term loudness (or as much as fits)
  const radarHistory = [];
  const radarMaxSeconds = 60;
  // Called from updateR128()
  function pushRadarLoudness(val) {
    const now = Date.now();
    radarHistory.push({ t: now, v: val });
    // Remove old
    while (radarHistory.length > 2 && (now - radarHistory[0].t) > radarMaxSeconds*1000) radarHistory.shift();
  }

  const btnTab  = document.getElementById('btnTab');
  const btnStop = document.getElementById('btnStop');
  const btnTone = document.getElementById('btnTone');
  const btnMonMute = document.getElementById('btnMonMute');
  const monState = document.getElementById('monState');
  const muteLeft = document.getElementById('muteLeft');
  const monGainEl = document.getElementById('monGain');
  const monVal = document.getElementById('monVal');

  const btnSysMonMute = document.getElementById('btnSysMonMute');
  const sysMonState = document.getElementById('sysMonState');
  const sysMonGainEl = document.getElementById('sysMonGain');
  const sysMonVal = document.getElementById('sysMonVal');

  const sysTrimRange = document.getElementById('sysTrimRange');
  const sysTrimInput = document.getElementById('sysTrimInput');
  const sysTrimOut = document.getElementById('sysTrimOut');
  const sysTrimReset = document.getElementById('sysTrimReset');

  const info = { srcKind: document.getElementById('srcKind'), cc: document.getElementById('cc'), sr: document.getElementById('sr'), stOK: document.getElementById('stOK') };

  const ppmCanvas = document.getElementById('ppmCanvas');
  const ppmScale = document.getElementById('ppmScale');
  const ppmLVal = document.getElementById('ppmLVal');
  const ppmRVal = document.getElementById('ppmRVal');
  const ctxState = document.getElementById('ctxState');
  const dbgGen   = document.getElementById('dbgGen');
  const dbgTab   = document.getElementById('dbgTab');
  const uptimeEl = document.getElementById('uptime');

  // ------- Helpers -------
  function getCss(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
  const dbToGain = dB => Math.pow(10, dB/20);
  const clamp = (v,min,max)=>Math.max(min,Math.min(max, v));

  // ------- dB Formatters (fixed-width, monospace-vänliga) -------
  // Alla formatterare ger konsekvent bredd så siffror inte "hoppar"

  // formatDb: Fixed-width dB (t.ex. "-23.4", " -3.4", "  0.0")
  // width = totalt antal tecken inklusive tecken och decimal
  function formatDb(value, decimals = 1, width = 5) {
    if (!isFinite(value) || value < -99) return '--.-'.padStart(width);
    const str = value.toFixed(decimals);
    return str.padStart(width);
  }

  // formatDbu: Med snap-to-zero för PPM, alltid med +/- tecken
  function formatDbu(value, decimals = 1, snapWindow = 0.25, width = 5) {
    if (!isFinite(value) || value < -99) return '--.-'.padStart(width);
    const snapped = (Math.abs(value) < snapWindow) ? 0 : value;
    const sign = snapped >= 0 ? '+' : '';
    return (sign + snapped.toFixed(decimals)).padStart(width);
  }

  // formatDbSigned: Alltid med +/− tecken, fixed-width
  function formatDbSigned(value, decimals = 1, width = 5) {
    if (!isFinite(value) || Math.abs(value) > 99) return '--.-'.padStart(width);
    const sign = value >= 0 ? '+' : '';
    return (sign + value.toFixed(decimals)).padStart(width);
  }

  // formatLufs: För LUFS-värden (t.ex. "-23.4 LUFS")
  function formatLufs(value, decimals = 1) {
    if (!isFinite(value) || value < -99) return '--.- LUFS';
    return value.toFixed(decimals).padStart(5) + ' LUFS';
  }

  // formatCorr: Korrelation (-1.00 till +1.00)
  function formatCorr(value) {
    if (!isFinite(value)) return '+-.--';
    const sign = value >= 0 ? '+' : '';
    return sign + value.toFixed(2);
  }

  // formatTime: Elapsed time (hh:mm:ss) - fixed width
  function formatTime(ms) {
    if (!isFinite(ms) || ms < 0) return '--:--:--';
    const totalSec = Math.floor(ms / 1000);
    const h = Math.floor(totalSec / 3600);
    const m = Math.floor((totalSec % 3600) / 60);
    const s = totalSec % 60;
    return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
  }

  // ------- Layout -------
  function sizeWrap(){ const headerH = document.querySelector('header').offsetHeight; wrap.style.height = `calc(100dvh - ${headerH}px)`; }
  sizeWrap(); window.addEventListener('resize', sizeWrap);

  function layoutXY(){
    // **DRAG-AWARE LAYOUT: Skip expensive calculations during drag operations**
    if (isDragLayoutFrozen) {
      console.debug('layoutXY: Skipped due to active drag operation');
      return;
    }

    const dpr = window.devicePixelRatio || 1;
    const xyModule = xyCard.querySelector('.xyModule');
    if (!xyModule) return;

    const moduleH = xyModule.clientHeight;
    const moduleW = xyModule.clientWidth;
    const gap = 12;

    // Båda ska vara KVADRATISKA och staplad vertikalt
    // Layout: goniometer överst (större), korrelation under (mindre men inte för liten)
    const totalH = moduleH;

    // Goniometer: tar ca 72% av höjden, men är kvadratisk (begränsas av bredd)
    const gonioTargetH = totalH * 0.72;
    const gonioSide = Math.max(120, Math.min(gonioTargetH, moduleW));
    xyWrap.style.width = gonioSide + 'px';
    xyWrap.style.height = gonioSide + 'px';

    const w = Math.floor(gonioSide * dpr), h = Math.floor(gonioSide * dpr);
    if (xy.width !== w || xy.height !== h) {
      xy.width = w;
      xy.height = h;
    }

    // Correlation: KVADRATISK, använder KVARVARANDE utrymme efter goniometer
    const corrWrapEl = document.querySelector('.corrWrap');
    if (corrWrapEl) {
      // Tillgängligt utrymme under goniometern
      const remainingH = totalH - gonioSide - gap;
      // Korrelationsmätaren ska vara kvadratisk: begränsas av min(remaining height, width)
      // Men ska inte bli för liten - minst 80px, och inte större än 50% av goniometern
      const corrMaxBySpace = Math.min(remainingH, moduleW * 0.6);
      const corrSide = Math.max(80, Math.min(corrMaxBySpace, gonioSide * 0.5));
      corrWrapEl.style.width = corrSide + 'px';
      corrWrapEl.style.height = corrSide + 'px';

      const cw = Math.floor(corrSide * dpr), ch = Math.floor(corrSide * dpr);
      if (corr.width !== cw || corr.height !== ch) {
        corr.width = cw;
        corr.height = ch;
      }
    }
  }

  // ------- Audio graph -------
  const ac = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
  ctxState && (ctxState.textContent = ac.state); ac.onstatechange = () => { if(ctxState) ctxState.textContent = ac.state };

  // Analysbuss L/R
  const mixL = ac.createGain(); mixL.gain.value = 1; const mixR = ac.createGain(); mixR.gain.value = 1;
  const analyserL = ac.createAnalyser(); analyserL.fftSize = 2048; const analyserR = ac.createAnalyser(); analyserR.fftSize = 2048;
  mixL.connect(analyserL); mixR.connect(analyserR);
  const bufL = new Float32Array(analyserL.fftSize); const bufR = new Float32Array(analyserR.fftSize);

  // K-weighting path (approx) för R128
  const kHP_L = ac.createBiquadFilter(); kHP_L.type='highpass'; kHP_L.frequency.value=38; kHP_L.Q.value=0.5;
  const kHS_L = ac.createBiquadFilter(); kHS_L.type='highshelf'; kHS_L.frequency.value=4000; kHS_L.gain.value=4; kHP_L.connect(kHS_L);
  const kHP_R = ac.createBiquadFilter(); kHP_R.type='highpass'; kHP_R.frequency.value=38; kHP_R.Q.value=0.5;
  const kHS_R = ac.createBiquadFilter(); kHS_R.type='highshelf'; kHS_R.frequency.value=4000; kHS_R.gain.value=4; kHP_R.connect(kHS_R);

  const kAnL = ac.createAnalyser(); kAnL.fftSize = 2048; const kBufL = new Float32Array(kAnL.fftSize);
  const kAnR = ac.createAnalyser(); kAnR.fftSize = 2048; const kBufR = new Float32Array(kAnR.fftSize);
  kHS_L.connect(kAnL); kHS_R.connect(kAnR);

  function connectStereoToMix(node){ const split = ac.createChannelSplitter(2); node.connect(split); split.connect(mixL,0); split.connect(mixR,1); split.connect(kHP_L,0); split.connect(kHP_R,1); return split; }

  // ------- Nordic PPM – IEC Type I, 0 PPM = 0 dBu (−18 dBFS peak) -------
  // Skala: -36 till +9 dBu (dBFS: -54 till -9), PML = +9 dBu = -9 dBFS
  // Ballistik: 5 ms attack (quasi-peak), linjär decay 20 dB / 1.7 s
  let ppmHoldL = -60, ppmHoldR = -60, lastTsPPM = performance.now();
  const PPM_ATTACK_MS = 5;          // 5 ms integration (IEC Type I)
  const PPM_DECAY_DB_PER_S = 20/1.7; // 20 dB på 1.7 s ≈ 11.76 dB/s (linjär)
  const PPM_MIN_DB = -54;           // -36 PPM = -54 dBFS
  const PPM_MAX_DB = -9;            // +9 PPM = -9 dBFS

  // Peak-hold för PPM (RTW broadcast standard: 3 sekunder)
  let ppmPeakHoldL = -60, ppmPeakHoldR = -60, ppmPeakTimeL = 0, ppmPeakTimeR = 0;
  const PPM_PEAK_HOLD_SEC = 3; // 3 sekunder peak-hold (RTW broadcast standard)

  function quasiPeakDb(buf, sampleRate){
    // Quasi-peak: hitta max amplitude med ~5ms integration
    // Vid 48kHz = 240 samples per 5ms fönster
    const windowSamples = Math.max(1, Math.round(sampleRate * PPM_ATTACK_MS / 1000));
    let maxPeak = 0;
    for(let i = 0; i < buf.length; i += windowSamples){
      let windowMax = 0;
      const end = Math.min(i + windowSamples, buf.length);
      for(let j = i; j < end; j++){
        const abs = Math.abs(buf[j]);
        if(abs > windowMax) windowMax = abs;
      }
      if(windowMax > maxPeak) maxPeak = windowMax;
    }
    return 20 * Math.log10(maxPeak + 1e-12);
  }

  function updatePPM(){
    const now = performance.now();
    const dt = Math.max(0.001, (now - lastTsPPM) / 1000);
    lastTsPPM = now;

    // Hämta samples
    analyserL.getFloatTimeDomainData(bufL);
    analyserR.getFloatTimeDomainData(bufR);

    // Quasi-peak mätning (dBFS)
    const peakDbL = quasiPeakDb(bufL, ac.sampleRate);
    const peakDbR = quasiPeakDb(bufR, ac.sampleRate);

    // Nordic PPM ballistik:
    // Attack: omedelbart till nytt peak (inom 5ms integration redan i quasiPeakDb)
    // Decay: linjär 20 dB / 1.7 s
    const decayDb = PPM_DECAY_DB_PER_S * dt;

    // L kanal
    if(peakDbL > ppmHoldL){
      ppmHoldL = peakDbL; // Snabb attack
    } else {
      ppmHoldL = Math.max(PPM_MIN_DB, ppmHoldL - decayDb); // Linjär decay
    }

    // R kanal
    if(peakDbR > ppmHoldR){
      ppmHoldR = peakDbR;
    } else {
      ppmHoldR = Math.max(PPM_MIN_DB, ppmHoldR - decayDb);
    }

    // Clamp till skalan
    const dispL = Math.max(PPM_MIN_DB, Math.min(PPM_MAX_DB, ppmHoldL));
    const dispR = Math.max(PPM_MIN_DB, Math.min(PPM_MAX_DB, ppmHoldR));

    // Peak-hold logik (10 sekunder)
    const nowSec = now / 1000;
    if (dispL > ppmPeakHoldL) { ppmPeakHoldL = dispL; ppmPeakTimeL = nowSec; }
    else if (nowSec - ppmPeakTimeL > PPM_PEAK_HOLD_SEC) { ppmPeakHoldL = dispL; ppmPeakTimeL = nowSec; }
    if (dispR > ppmPeakHoldR) { ppmPeakHoldR = dispR; ppmPeakTimeR = nowSec; }
    else if (nowSec - ppmPeakTimeR > PPM_PEAK_HOLD_SEC) { ppmPeakHoldR = dispR; ppmPeakTimeR = nowSec; }

    // Rita med peak-hold
    drawHBar_PPM(ppmCanvas, dispL, dispR, ppmPeakHoldL, ppmPeakHoldR);

    // Visa i PPM (= dBu), RTW-style: L: +2.0 PPM
    const ppmL = dispL + 18; // dBFS -> PPM/dBu
    const ppmR = dispR + 18;
    // Visa "--.-" om signalen är vid botten av skalan (ingen meningsfull signal)
    const ppmFloor = PPM_MIN_DB + 18; // -36 dBu
    const ppmLStr = (dispL <= PPM_MIN_DB + 1) ? '--.-' : formatDbu(ppmL);
    const ppmRStr = (dispR <= PPM_MIN_DB + 1) ? '--.-' : formatDbu(ppmR);
    document.getElementById('ppmLabel').innerHTML = `L: <b>${ppmLStr} PPM</b> · R: <b>${ppmRStr} PPM</b>`;
  }
  // Reset-funktion för PPM peak-hold
  window.resetPPMPeak = function(){ ppmPeakHoldL = -60; ppmPeakHoldR = -60; };

  // ------- XY + Correlation -------
  function drawXY(){
    const w=xy.width,h=xy.height; if(!w||!h) return;
    const fade = 0.10; xyCtx.fillStyle = `rgba(13,15,17,${fade})`; xyCtx.fillRect(0,0,w,h);
    analyserL.getFloatTimeDomainData(bufL); analyserR.getFloatTimeDomainData(bufR);
    let n=Math.min(bufL.length,bufR.length), mL=0,mR=0; for(let i=0;i<n;i++){ mL+=bufL[i]; mR+=bufR[i]; } mL/=n; mR/=n;
    xyCtx.globalAlpha=0.85; xyCtx.globalCompositeOperation='lighter'; xyCtx.fillStyle='rgba(105,191,255,.85)'; const px = Math.max(1, Math.floor((window.devicePixelRatio||1)));
    let prevX=null, prevY=null;
    for(let i=0;i<n;i+=2){
      const L=bufL[i]-mL, R=bufR[i]-mR;
      // Centrera och skala korrekt för -18 dBFS
      const x = (L * w/2) + w/2;  // Skala -1..1 till 0..w
      const y = h - ((R * h/2) + h/2);  // Skala -1..1 till 0..h, invertera för y
      if(prevX!==null){ xyCtx.globalAlpha=.35; xyCtx.strokeStyle='rgba(105,191,255,.35)'; xyCtx.beginPath(); xyCtx.moveTo(prevX,prevY); xyCtx.lineTo(x,y); xyCtx.stroke(); }
      xyCtx.globalAlpha=.85; xyCtx.fillRect(x,y,px,px); prevX=x; prevY=y;
    }
    xyCtx.globalCompositeOperation='source-over'; xyCtx.globalAlpha=1; xyCtx.strokeStyle = '#3a4855'; xyCtx.lineWidth = 1;
    xyCtx.beginPath();
    xyCtx.moveTo(w/2,0); xyCtx.lineTo(w/2,h);
    xyCtx.moveTo(0,h/2); xyCtx.lineTo(w,h/2);
    xyCtx.moveTo(0,h); xyCtx.lineTo(w,0);
    xyCtx.moveTo(0,0); xyCtx.lineTo(w,h);
    xyCtx.stroke();
  }

  function corrNow(l,r){
    let n=Math.min(l.length,r.length), sL=0,sR=0; for(let i=0;i<n;i++){ sL+=l[i]; sR+=r[i] }
    const mL=sL/n, mR=sR/n; let num=0,dL=0,dR=0;
    for(let i=0;i<n;i++){ const L=l[i]-mL, R=r[i]-mR; num+=L*R; dL+=L*L; dR+=R*R }
    return num/(Math.sqrt(dL*dR)+1e-20);
  }
  let corrHold=0, corrUp=.25, corrDn=.06;
  function drawCorr(){
    analyserL.getFloatTimeDomainData(bufL); analyserR.getFloatTimeDomainData(bufR);
    const cRaw = Math.max(-1, Math.min(1, corrNow(bufL,bufR)));
    corrHold = cRaw>corrHold ? corrHold + corrUp*(cRaw-corrHold) : corrHold + corrDn*(cRaw-corrHold);
    
    // Uppdatera canvas-storlek baserat på faktisk elementstorlek
    const dpr = window.devicePixelRatio || 1;
    const rect = corr.getBoundingClientRect();
    const w = Math.floor(rect.width * dpr);
    const h = Math.floor(rect.height * dpr);
    
    if (corr.width !== w || corr.height !== h) {
      corr.width = w;
      corr.height = h;
      // Sätt CSS-storlek för att matcha element
      corr.style.width = `${rect.width}px`;
      corr.style.height = `${rect.height}px`;
    }
    
    const ctx = corrCtx;
    ctx.clearRect(0,0,w,h);
    const box = { x: Math.floor(w*0.18), y: Math.floor(16*dpr), w: Math.floor(w*0.64), h: h-(32*dpr) };
    const yFromV = v => Math.round(box.y + (1 - (v+1)/2) * box.h);
    ctx.strokeStyle='#3a4855'; ctx.strokeRect(box.x, box.y, box.w, box.h);
    ctx.fillStyle='#88a3bf'; const ticksV=[-1,-0.5,0,0.5,1];
    
    // Anpassa font och streck för HiDPI
    const tickWidth = Math.ceil(6 * dpr);
    const tickHeight = Math.ceil(1 * dpr);
    ctx.font = `${Math.round(10*dpr)}px ui-sans-serif`;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'left';
    
    for(const tv of ticksV){
      const y = yFromV(tv);
      // Rita skalstreck med rätt DPR-storlek
      ctx.fillRect(box.x-tickWidth, y, tickWidth, tickHeight);
      ctx.fillRect(box.x+box.w, y, tickWidth, tickHeight);
      // Rita text
      ctx.fillText(tv.toString(), box.x+box.w+Math.round(8*dpr), y);
    }
    const y0 = yFromV(0); const yc = yFromV(corrHold);
    // RTW-style färgzoner för correlation
    // Grönt (≥+0.3): stabil stereo, bra mono-kompatibilitet
    // Amber (−0.3 till +0.3): gränsland, reverb eller smal stereo
    // Rött (<−0.3): risk för kansellering i mono
    const col = (corrHold < -0.3) ? getCss('--hot') : (corrHold >= 0.3 ? getCss('--ok') : getCss('--warn'));
    ctx.globalAlpha=.18; ctx.fillStyle='#0f1214'; ctx.fillRect(box.x, box.y, box.w, box.h);
    ctx.globalAlpha=.85; ctx.fillStyle=col;
    if (yc < y0) { ctx.fillRect(box.x+2, yc, box.w-4, (y0 - yc)); }
    else { ctx.fillRect(box.x+2, y0, box.w-4, (yc - y0)); }
    ctx.globalAlpha=1; ctx.fillStyle='#2a3642'; ctx.fillRect(box.x+1, y0, box.w-2, 1);
    corrVal.textContent = formatCorr(corrHold);
  }

  // ------- Mono Deviation (L/R Balance) -------
  const monoDevCanvas = document.getElementById('monoDev');
  const monoDevCtx = monoDevCanvas.getContext('2d');
  const monoDevVal = document.getElementById('monoDevVal');
  let monoDevHold = 0;

  function drawMonoDev() {
    analyserL.getFloatTimeDomainData(bufL);
    analyserR.getFloatTimeDomainData(bufR);

    // Beräkna RMS för L och R
    let sumL = 0, sumR = 0;
    for (let i = 0; i < bufL.length; i++) {
      sumL += bufL[i] * bufL[i];
      sumR += bufR[i] * bufR[i];
    }
    const rmsL = Math.sqrt(sumL / bufL.length);
    const rmsR = Math.sqrt(sumR / bufR.length);

    // L/R balance i dB (positiv = L högre, negativ = R högre)
    const balanceDb = 20 * Math.log10((rmsL + 1e-12) / (rmsR + 1e-12));
    const clampedBalance = Math.max(-12, Math.min(12, balanceDb));

    // Smooth
    const a = 0.15;
    monoDevHold = isFinite(clampedBalance) ? monoDevHold + a * (clampedBalance - monoDevHold) : 0;

    // Canvas setup med HiDPI
    const dpr = window.devicePixelRatio || 1;
    const rect = monoDevCanvas.getBoundingClientRect();
    const w = Math.floor(rect.width * dpr);
    const h = Math.floor(rect.height * dpr);

    if (monoDevCanvas.width !== w || monoDevCanvas.height !== h) {
      monoDevCanvas.width = w;
      monoDevCanvas.height = h;
    }

    const ctx = monoDevCtx;
    ctx.clearRect(0, 0, w, h);

    // Rita bakgrund
    const pad = Math.round(8 * dpr);
    const barY = Math.round(h * 0.35);
    const barH = Math.round(h * 0.3);
    const barX = pad;
    const barW = w - 2 * pad;

    ctx.fillStyle = '#0f1214';
    ctx.fillRect(barX, barY, barW, barH);
    ctx.strokeStyle = '#3a4855';
    ctx.strokeRect(barX, barY, barW, barH);

    // Mittstrecket (0 dB)
    const centerX = barX + barW / 2;
    ctx.fillStyle = '#5a6a7a';
    ctx.fillRect(centerX - 1, barY - 4 * dpr, 2, barH + 8 * dpr);

    // Tick marks vid ±3, ±6, ±12 dB
    const ticks = [-12, -6, -3, 3, 6, 12];
    ctx.fillStyle = '#3a4855';
    ctx.font = `${Math.round(8 * dpr)}px ui-monospace, monospace`;
    ctx.textBaseline = 'top';
    ctx.textAlign = 'center';
    for (const t of ticks) {
      const xPos = centerX + (t / 12) * (barW / 2);
      ctx.fillRect(xPos - 0.5, barY - 2 * dpr, 1, barH + 4 * dpr);
    }

    // Rita balance-bar
    const devX = centerX + (monoDevHold / 12) * (barW / 2);
    const devW = Math.abs(devX - centerX);

    // Färg baserat på deviation
    let col;
    const absDev = Math.abs(monoDevHold);
    if (absDev < 1.5) col = getCss('--ok');       // Grön: bra balans
    else if (absDev < 3) col = getCss('--cyan');  // Cyan: lätt deviation
    else if (absDev < 6) col = getCss('--warn');  // Amber: märkbar
    else col = getCss('--hot');                    // Röd: stark obalans

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = col;
    if (monoDevHold >= 0) {
      ctx.fillRect(centerX, barY + 2, devW, barH - 4);
    } else {
      ctx.fillRect(centerX - devW, barY + 2, devW, barH - 4);
    }
    ctx.globalAlpha = 1;

    // L och R labels
    ctx.fillStyle = '#6b7280';
    ctx.font = `${Math.round(9 * dpr)}px ui-sans-serif`;
    ctx.textAlign = 'left';
    ctx.fillText('L', barX + 2 * dpr, barY + barH + 3 * dpr);
    ctx.textAlign = 'right';
    ctx.fillText('R', barX + barW - 2 * dpr, barY + barH + 3 * dpr);

    // Uppdatera display
    monoDevVal.textContent = formatDbSigned(monoDevHold, 1, 5);
  }

  // ------- Digital RMS (dBFS) – Average digital level, 0 dBFS = full-scale sine -------
  const dbfsMarks = [-60,-50,-40,-30,-24,-18,-12,-6,-3,0];
  function layoutDBFSScale(el){
    el.innerHTML='';
    dbfsMarks.forEach(m=>{
      const x = ((m+60)/60)*100;
      const t=document.createElement('div');
      t.style.position='absolute'; t.style.left=`calc(${x}% - 0.5px)`; t.style.top='25%'; t.style.height='50%'; t.style.width='1px'; t.style.background='#2a3642';
      el.appendChild(t);
      const lab=document.createElement('div');
      lab.textContent=m + ' dBFS';
      lab.style.position='absolute'; lab.style.left=`calc(${x}% - 32px)`; lab.style.top='8px'; lab.style.width='64px'; lab.style.textAlign='center'; lab.style.fontSize='10px'; lab.style.color='#88a3bf';
      el.appendChild(lab);
    });
    // TEST -21 dBFS RMS (= 0 dBu = -18 dBFS peak för sinus)
    const x = ((-21+60)/60)*100;
    const ref=document.createElement('div');
    ref.style.position='absolute';
    ref.style.left=`calc(${x}% - 0.5px)`;
    ref.style.top='25%';
    ref.style.height='50%';
    ref.style.width='1px';
    ref.style.background=getCss('--cyan');
    ref.style.opacity='0.95';
    el.appendChild(ref);
    const tag=document.createElement('div');
    tag.innerHTML='<div>TEST</div><div>−21 dBFS RMS</div><div>−18 dBFS peak</div>';
    tag.style.position='absolute';
    tag.style.left=`calc(${x}% - 40px)`;
    tag.style.bottom='4px';
    tag.style.width='80px';
    tag.style.textAlign='center';
    tag.style.fontSize='9px';
    tag.style.color=getCss('--cyan');
    tag.style.fontWeight='bold';
    tag.style.lineHeight='1.15';
    tag.style.background='none';
    tag.style.borderRadius='0';
    tag.style.padding='0';
    el.appendChild(tag);
  }

  // ------- True Peak (dBTP) – 4× oversampling, 0 dBTP = full scale -------
  function layoutTPScale(el){
    el.innerHTML='';
    const marks = [-60,-50,-40,-30,-24,-18,-12,-6,-3,0];
    marks.forEach(m=>{
      const x = ((m+60)/60)*100;
      const t=document.createElement('div');
      t.style.position='absolute'; t.style.left=`calc(${x}% - 1px)`; t.style.top='25%'; t.style.height='50%'; t.style.width='2px'; t.style.background='#2a3642';
      el.appendChild(t);
      const lab=document.createElement('div');
      lab.textContent = m + ' dBTP';
      lab.style.position='absolute'; lab.style.left=`calc(${x}% - 32px)`; lab.style.top='6px'; lab.style.width='64px'; lab.style.textAlign='center'; lab.style.fontSize='10px'; lab.style.color='#88a3bf';
      el.appendChild(lab);
    });
    // warn zones (styled like VU Nordic, label at bottom, color-coded)
    const warn=[
      {v:-6,c:'var(--warn)',w:1,label:'−6 dBTP',color:getCss('--warn')},
      {v:-3,c:'var(--caution)',w:1,label:'−3 dBTP',color:getCss('--caution')},
      {v:-1,c:'var(--hot)',w:1,label:'−1 dBTP',color:getCss('--hot')}
    ];
    for(const mk of warn){
      const x=((mk.v+60)/60)*100;
      const col=document.createElement('div');
      col.style.position='absolute'; col.style.left=`calc(${x}% - 0.5px)`; col.style.top='25%'; col.style.height='50%'; col.style.width=`${mk.w}px`; col.style.background=`${mk.c}`; col.style.opacity='0.95';
      el.appendChild(col);
      let dbfsEq = '';
      if(mk.v === -6) dbfsEq = '-9 dBFS';
      if(mk.v === -3) dbfsEq = '-6 dBFS';
      if(mk.v === -1) dbfsEq = '-4 dBFS';
      const tag=document.createElement('div');
      tag.innerHTML = `<div>${dbfsEq}</div>`;
      tag.style.position='absolute';
      tag.style.left=`calc(${x}% - 32px)`;
      tag.style.bottom='8px';  // Samma luftiga spacing som blå TEST-text
      tag.style.width='64px';
      tag.style.textAlign='center';
      tag.style.fontSize='10px';
      tag.style.color=mk.color;
      tag.style.fontWeight='bold';
      tag.style.lineHeight='1.2';
      tag.style.background='none';
      tag.style.borderRadius='0';
      tag.style.padding='0';
      el.appendChild(tag);
    }
    // TEST -18 dBTP = -18 dBFS peak (broadcast alignment)
    const xRef = ((-18+60)/60)*100;
    const ref=document.createElement('div');
    ref.style.position='absolute';
    ref.style.left=`calc(${xRef}% - 1px)`;
    ref.style.top='25%';
    ref.style.height='50%';
    ref.style.width='2px';
    ref.style.background=getCss('--cyan');
    ref.style.opacity='0.95';
    el.appendChild(ref);
    // TEST label below blue line
    const tag=document.createElement('div');
    tag.innerHTML='<div>TEST</div><div>−18 dBTP</div><div>−18 dBFS peak</div>';
    tag.style.position='absolute';
    tag.style.left=`calc(${xRef}% - 40px)`;
    tag.style.bottom='4px';
    tag.style.width='80px';
    tag.style.textAlign='center';
    tag.style.fontSize='9px';
    tag.style.color=getCss('--cyan');
    tag.style.fontWeight='bold';
    tag.style.lineHeight='1.2';
    tag.style.background='none';
    tag.style.borderRadius='0';
    tag.style.padding='0';
    el.appendChild(tag);
  }

  // Nordic PPM – RTW-style skala i PPM-steg
  // PPM-skala: -36 till +9 där 0 PPM = 0 dBu = -18 dBFS peak
  // RTW-operators standard axis-labels: −∞, −3, 0, +3, +6, +9 PPM
  const ppmMarks = [
    {ppm: -36, label: '−∞'},    // Längst till vänster, visar −∞ för "floor"
    {ppm: -3, label: '−3'},
    {ppm: 0, label: '0'},
    {ppm: 3, label: '+3'},
    {ppm: 6, label: '+6'},
    {ppm: 9, label: '+9'}
  ];
  function layoutPPMScale(el){
    el.innerHTML='';
    const dbMin=-54, dbMax=-9, dbSpan=dbMax-dbMin; // 45 dB i dBFS
    // PPM = dBu, dBFS = dBu - 18
    ppmMarks.forEach(m=>{
      const dBFS = m.ppm - 18;
      const x = ((dBFS-dbMin)/dbSpan)*100;
      const t=document.createElement('div');
      t.style.position='absolute'; t.style.left=`calc(${x}% - 0.5px)`; t.style.top='25%'; t.style.height='50%'; t.style.width='1px'; t.style.background='#2a3642';
      el.appendChild(t);
      const lab=document.createElement('div');
      lab.textContent = m.label;
      lab.style.position='absolute'; lab.style.left=`calc(${x}% - 20px)`; lab.style.top='6px'; lab.style.width='40px'; lab.style.textAlign='center'; lab.style.fontSize='10px'; lab.style.color='#88a3bf';
      el.appendChild(lab);
    });
    // TEST = 0 PPM = 0 dBu = -18 dBFS (cyan linje)
    const xTest = ((-18-dbMin)/dbSpan)*100;
    const ref=document.createElement('div');
    ref.style.position='absolute';
    ref.style.left=`calc(${xTest}% - 1px)`;
    ref.style.top='25%';
    ref.style.height='50%';
    ref.style.width='2px';
    ref.style.background=getCss('--cyan');
    ref.style.opacity='0.95';
    el.appendChild(ref);
    const tag=document.createElement('div');
    tag.innerHTML='<div>TEST</div><div>0 PPM (0 dBu)</div><div>−18 dBFS peak</div>';
    tag.style.position='absolute';
    tag.style.left=`calc(${xTest}% - 44px)`;
    tag.style.bottom='4px';
    tag.style.width='88px';
    tag.style.textAlign='center';
    tag.style.fontSize='9px';
    tag.style.color=getCss('--cyan');
    tag.style.fontWeight='bold';
    tag.style.lineHeight='1.15';
    tag.style.background='none';
    tag.style.borderRadius='0';
    tag.style.padding='0';
    el.appendChild(tag);
    // PML = +9 PPM = +9 dBu = -9 dBFS (röd markering)
    const xPML = ((-9-dbMin)/dbSpan)*100;
    const pmlLine=document.createElement('div');
    pmlLine.style.position='absolute';
    pmlLine.style.left=`calc(${xPML}% - 1px)`;
    pmlLine.style.top='25%';
    pmlLine.style.height='50%';
    pmlLine.style.width='2px';
    pmlLine.style.background=getCss('--hot');
    pmlLine.style.opacity='0.95';
    el.appendChild(pmlLine);
    const pmlTag=document.createElement('div');
    pmlTag.innerHTML='<div>PML</div><div>+9 PPM</div>';
    pmlTag.style.position='absolute';
    pmlTag.style.left=`calc(${xPML}% - 32px)`;
    pmlTag.style.bottom='8px';
    pmlTag.style.width='64px';
    pmlTag.style.textAlign='center';
    pmlTag.style.fontSize='10px';
    pmlTag.style.color=getCss('--hot');
    pmlTag.style.fontWeight='bold';
    pmlTag.style.lineHeight='1.2';
    pmlTag.style.background='none';
    pmlTag.style.borderRadius='0';
    pmlTag.style.padding='0';
    el.appendChild(pmlTag);
  }

  function drawHBar_DBFS(canvas, valueL, valueR){
    const dpr=window.devicePixelRatio||1;
    const w=Math.floor(canvas.clientWidth*dpr), h=Math.floor(canvas.height);
    if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h }
    const ctx = canvas.getContext('2d');
    function xFromDb(db){ const c=Math.max(-60,Math.min(0,db)); return Math.round((c+60)/60*w) }
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#0e151a'; ctx.fillRect(0,0,w,h);
    const step=1;
    function drawChannel(yTop, val){
      for(let d=-60; d<0; d+=step){ const x0=xFromDb(d), x1=xFromDb(d+step); ctx.globalAlpha=.14; ctx.fillStyle=getCss('--ok'); ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12); }
      const tEnd = Math.min(0, val);
      for(let d=-60; d<tEnd; d+=step){ const x0=xFromDb(d), x1=xFromDb(Math.min(d+step,tEnd)); ctx.globalAlpha=.9; ctx.fillStyle=getCss('--ok'); ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12); }
    }
    drawChannel(h*0.35, valueL); drawChannel(h*0.55, valueR);
    ctx.globalAlpha=1; ctx.fillStyle='#2a3642'; ctx.fillRect(w-2,0,2,h); // 0 dBFS fence
  }

  // True Peak (dBTP) – diode style rendering med peak-hold markör
  function drawDiodeBar_TP(canvas, valueL, valueR, peakHoldL, peakHoldR){
    const dpr=window.devicePixelRatio||1; const w=Math.floor(canvas.clientWidth*dpr), h=Math.floor(canvas.height);
    if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h }
    const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,w,h); ctx.fillStyle='#0e151a'; ctx.fillRect(0,0,w,h);
    const step=1; const xFromDb = db => Math.round((Math.max(-60,Math.min(0,db))+60)/60*w);
    function segColor(db){ if(db>=-1) return getCss('--hot'); if(db>=-3) return getCss('--caution'); if(db>=-6) return getCss('--warn'); return getCss('--ok'); }
    function drawChannel(yTop, val, peakHold){
      // Bakgrund (dimmat)
      for(let d=-60; d<0; d+=step){ const x0=xFromDb(d), x1=xFromDb(d+step); const col=segColor(d+step/2); ctx.globalAlpha=.14; ctx.fillStyle=col; ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12); }
      // Aktiv stapel
      const tEnd = Math.min(0, val);
      for(let d=-60; d<tEnd; d+=step){
        const x0=xFromDb(d), x1=xFromDb(Math.min(d+step,tEnd));
        let col=segColor(tEnd); if(tEnd<-1){ col=segColor(d+step/2); }
        ctx.globalAlpha=.9; ctx.fillStyle=col; ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12);
      }
      // Peak-hold markör (tunn vertikal linje)
      if (peakHold !== undefined && peakHold > -60) {
        const xPeak = xFromDb(peakHold);
        const peakColor = segColor(peakHold);
        ctx.globalAlpha = 1;
        ctx.fillStyle = peakColor;
        // Rita tunn linje (2px bred) med ljusare färg
        ctx.fillRect(xPeak - 1, yTop - 2, 2, h*0.12 + 4);
        // Liten "tick" topp
        ctx.fillRect(xPeak - 3, yTop - 2, 6, 2);
      }
    }
    drawChannel(h*0.35, valueL, peakHoldL); drawChannel(h*0.55, valueR, peakHoldR);
    ctx.globalAlpha=1; ctx.fillStyle='#2a3642'; ctx.fillRect(w-2,0,2,h); // 0 dBTP fence (visual)
  }

  // Nordic PPM – horisontell canvas rendering med RTW-style färgzoner
  // Range: -54 dBFS till -9 dBFS (45 dB span) = -36 PPM till +9 PPM
  // 0 PPM = 0 dBu = -18 dBFS peak, PML = +9 PPM = -9 dBFS
  function drawHBar_PPM(canvas, dBfsL, dBfsR, peakHoldL, peakHoldR){
    const dpr=window.devicePixelRatio||1;
    const rect = canvas.getBoundingClientRect();
    const w=Math.floor(rect.width*dpr), h=Math.floor(rect.height*dpr);
    if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h }
    const ctx = canvas.getContext('2d');
    const dbMin=-54, dbMax=-9, dbSpan=dbMax-dbMin; // 45 dB
    function xFromDb(db){ const c=Math.max(dbMin,Math.min(dbMax,db)); return Math.round((c-dbMin)/dbSpan*w) }
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle='#0e151a'; ctx.fillRect(0,0,w,h);
    const step=1;
    // RTW-style färgzoner för Nordic PPM (PPM = dBu = dBFS + 18)
    function segColor(db){
      const ppm = db + 18; // dBFS -> PPM/dBu
      if(ppm >= 6) return getCss('--hot');        // +6 till +9 PPM: rött (nära PML)
      if(ppm >= 0) return getCss('--warn');       // 0 till +6 PPM: amber (varning)
      if(ppm >= -3) return getCss('--cyan');      // -3 till 0 PPM: cyan/teal (nominal)
      return getCss('--ok');                       // Under -3 PPM: grönt (headroom)
    }
    function drawChannel(yTop, val, peakHold){
      // Bakgrund (dimmat)
      for(let d=dbMin; d<dbMax; d+=step){
        const x0=xFromDb(d), x1=xFromDb(d+step);
        ctx.globalAlpha=.14;
        ctx.fillStyle=segColor(d+step/2);
        ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12);
      }
      // Aktiv bar
      const tEnd = Math.min(dbMax, val);
      for(let d=dbMin; d<tEnd; d+=step){
        const x0=xFromDb(d), x1=xFromDb(Math.min(d+step,tEnd));
        ctx.globalAlpha=.9;
        ctx.fillStyle=segColor(d+step/2);
        ctx.fillRect(x0,yTop,(x1-x0)-1,h*0.12);
      }
      // Peak-hold markör (RTW-style: tunn linje)
      if (peakHold !== undefined && peakHold > dbMin) {
        const xPeak = xFromDb(peakHold);
        const peakColor = segColor(peakHold);
        ctx.globalAlpha = 1;
        ctx.fillStyle = peakColor;
        ctx.fillRect(xPeak - 1, yTop - 2, 2, h*0.12 + 4);
        ctx.fillRect(xPeak - 3, yTop - 2, 6, 2);
      }
    }
    drawChannel(h*0.35, dBfsL, peakHoldL); drawChannel(h*0.55, dBfsR, peakHoldR);
    ctx.globalAlpha=1; ctx.fillStyle='#2a3642'; ctx.fillRect(w-2,0,2,h); // +9 PPM fence
  }

  let rmsHoldL=0, rmsHoldR=0; let lastTsDB=performance.now();
  function drawDBFS(){
    analyserL.getFloatTimeDomainData(bufL); analyserR.getFloatTimeDomainData(bufR);
    let sL=0,sR=0; for(let i=0;i<bufL.length;i++){ sL+=bufL[i]*bufL[i]; sR+=bufR[i]*bufR[i] }
    const rmsL=Math.sqrt(sL/bufL.length), rmsR=Math.sqrt(sR/bufR.length);
    const now=performance.now(); const dt=Math.max(0.001,(now-lastTsDB)/1000); lastTsDB=now; const tau=.3, a=1-Math.exp(-dt/tau);
    rmsHoldL += a*(rmsL - rmsHoldL); rmsHoldR += a*(rmsR - rmsHoldR);
    const dBL = 20*Math.log10(rmsHoldL+1e-12); const dBR = 20*Math.log10(rmsHoldR+1e-12);
    // Visa "--.-" om signalen är under botten av skalan (-60 dBFS)
    const dbfsLStr = (dBL <= -59) ? '--.-' : formatDb(dBL);
    const dbfsRStr = (dBR <= -59) ? '--.-' : formatDb(dBR);
    document.getElementById('dbfsLabel').innerHTML = `L: <b>${dbfsLStr}</b> · R: <b>${dbfsRStr}</b> dBFS`;
    drawHBar_DBFS(dbfs, dBL, dBR);
  }
  layoutDBFSScale(dbfsScale);
  layoutPPMScale(ppmScale);

  function hermite(p0,p1,p2,p3,t){ const a= (-0.5*p0)+(1.5*p1)+(-1.5*p2)+(0.5*p3); const b=(p0*(-1))+ (2.5*p1)+(-2*p2)+ (0.5*p3); const c=(-0.5*p0)+(0.5*p2); const d=p1; return ((a*t+b)*t+c)*t+d; }
  function truePeakDb(buf){
    let maxAbs=0; const n=buf.length;
    for(let i=1;i<n-2;i++){
      const p0=buf[i-1], p1=buf[i], p2=buf[i+1], p3=buf[i+2];
      const a=Math.abs(p1); if(a>maxAbs) maxAbs=a;
      const t1=Math.abs(hermite(p0,p1,p2,p3,0.25)); if(t1>maxAbs) maxAbs=t1;
      const t2=Math.abs(hermite(p0,p1,p2,p3,0.50)); if(t2>maxAbs) maxAbs=t2;
      const t3=Math.abs(hermite(p0,p1,p2,p3,0.75)); if(t3>maxAbs) maxAbs=t3;
    }
    return 20*Math.log10(maxAbs + 1e-9);
  }
  let tpSmoothL=-60, tpSmoothR=-60;
  // Peak-hold för True Peak (RTW-style): 3 sekunders hold
  let tpPeakHoldL=-60, tpPeakHoldR=-60, tpPeakTimeL=0, tpPeakTimeR=0;
  const TP_PEAK_HOLD_SEC = 3; // 3 sekunder peak-hold
  let tpOverFlag = false; // OVER-indikator

  function drawTruePeak(){
    analyserL.getFloatTimeDomainData(bufL); analyserR.getFloatTimeDomainData(bufR);
    const rawL = Math.min(0, truePeakDb(bufL)); const rawR = Math.min(0, truePeakDb(bufR));
    const a = 0.25; tpSmoothL = tpSmoothL + a*(rawL - tpSmoothL); tpSmoothR = tpSmoothR + a*(rawR - tpSmoothR);

    // Peak-hold logik
    const now = performance.now() / 1000;
    if (tpSmoothL > tpPeakHoldL) { tpPeakHoldL = tpSmoothL; tpPeakTimeL = now; }
    else if (now - tpPeakTimeL > TP_PEAK_HOLD_SEC) { tpPeakHoldL = tpSmoothL; tpPeakTimeL = now; }
    if (tpSmoothR > tpPeakHoldR) { tpPeakHoldR = tpSmoothR; tpPeakTimeR = now; }
    else if (now - tpPeakTimeR > TP_PEAK_HOLD_SEC) { tpPeakHoldR = tpSmoothR; tpPeakTimeR = now; }

    // OVER-indikator om TP >= -1.0 dBTP
    const maxPeak = Math.max(tpPeakHoldL, tpPeakHoldR);
    if (maxPeak >= -1.0) tpOverFlag = true;

    // Label med peak-hold max och OVER-indikator
    const overHtml = tpOverFlag ? '<span style="color:var(--hot);font-weight:bold;margin-left:8px">OVER</span>' : '';
    const peakMaxVal = Math.max(tpPeakHoldL, tpPeakHoldR);
    const peakMaxStr = peakMaxVal > -59 ? `Max: <b>${formatDb(peakMaxVal)}</b> dBTP` : '';
    // Visa "--.-" om signalen är under botten av skalan (-60 dBTP)
    const tpLStr = (tpSmoothL <= -59) ? '--.-' : formatDb(tpSmoothL);
    const tpRStr = (tpSmoothR <= -59) ? '--.-' : formatDb(tpSmoothR);
    document.getElementById('tpLabel').innerHTML = `L: <b>${tpLStr}</b> · R: <b>${tpRStr}</b> dBTP · ${peakMaxStr}${overHtml}`;

    drawDiodeBar_TP(tp, tpSmoothL, tpSmoothR, tpPeakHoldL, tpPeakHoldR);
  }
  // Reset-funktion för OVER-indikator (kan kopplas till en knapp)
  window.resetTPOver = function(){ tpOverFlag = false; tpPeakHoldL = -60; tpPeakHoldR = -60; };
  layoutTPScale(tpScale);

  // ------- R128 – EBU R128 Loudness med broadcast target −23 LUFS -------
  const LOUDNESS_TARGET = -23; // Europa broadcast target (EBU R128)
  const frameDur = 2048 / 48000; const mLen = Math.max(1, Math.round(0.4 / frameDur)); const sLen = Math.max(1, Math.round(3.0 / frameDur));
  const mQ = []; const sQ = []; let intEnergy = 0, intCount = 0; let stHistory = [];

  // R128 panel: TPmax och elapsed time
  let r128TpMax = -Infinity;
  let r128StartTime = performance.now();
  const r128TpMaxEl = document.getElementById('r128TpMax');
  const r128TimeEl = document.getElementById('r128Time');
  const r128ResetBtn = document.getElementById('r128Reset');

  function resetR128() {
    // Reset integrated loudness
    intEnergy = 0; intCount = 0;
    mQ.length = 0; sQ.length = 0; stHistory = [];
    // Reset TPmax
    r128TpMax = -Infinity;
    tpOverFlag = false;
    tpPeakHoldL = -60; tpPeakHoldR = -60;
    // Reset time
    r128StartTime = performance.now();
    // Reset radar
    radarHistory.length = 0;
    // Update display (fixed-width placeholders)
    lufsM.textContent = '--.- LUFS'; lufsS.textContent = '--.- LUFS'; lufsI.textContent = '--.- LUFS';
    lraEl.textContent = '--.- LU';
    r128TpMaxEl.textContent = '--.- dBTP';
    r128TimeEl.textContent = '--:--:--';
  }
  r128ResetBtn.addEventListener('click', resetR128);

  // Färg baserat på avstånd från target
  function loudnessColor(lufs) {
    if (!isFinite(lufs)) return 'var(--muted)';
    const offset = lufs - LOUDNESS_TARGET;
    if (offset >= -1 && offset <= 1) return getCss('--ok');      // −24 till −22: grönt (on target)
    if (offset < -1) return getCss('--cyan');                     // Under −24: cyan (too quiet)
    if (offset <= 3) return getCss('--warn');                     // −22 till −20: amber (bit loud)
    return getCss('--hot');                                        // Över −20: rött (too loud)
  }
  function energyFromK(){
    kAnL.getFloatTimeDomainData(kBufL); kAnR.getFloatTimeDomainData(kBufR);
    let eL=0,eR=0; for(let i=0;i<kBufL.length;i++){ eL+=kBufL[i]*kBufL[i]; eR+=kBufR[i]*kBufR[i]; }
    const rmsL = eL/kBufL.length; const rmsR = eR/kBufR.length; return (rmsL + rmsR)/2;
  }
  function lufsFromEnergy(e){ return 10*Math.log10(e + 1e-12); }
  let lastText=0;
  function updateR128(){
    const e = energyFromK(); mQ.push(e); sQ.push(e);
    if(mQ.length>mLen) mQ.shift(); if(sQ.length>sLen){ stHistory.push(sQ.shift()); if(stHistory.length>Math.round(60/3)) stHistory.shift(); }
    const mE=mQ.reduce((a,b)=>a+b,0)/mQ.length; const sE=sQ.reduce((a,b)=>a+b,0)/sQ.length;
    const mLUFS=lufsFromEnergy(mE); const sLUFS=lufsFromEnergy(sE);
    let gate=-70; if(intCount>0){ const iLU=lufsFromEnergy(intEnergy/intCount); gate=Math.max(-70, iLU-10); }
    if(sLUFS>=gate){ intEnergy+=e; intCount++; }
    const iLUFS=(intCount>0)? lufsFromEnergy(intEnergy/intCount): -Infinity;
    const stVals=stHistory.map(v=>10*Math.log10(v+1e-12)).filter(v=>v>(iLUFS-20));
    let LRA='--.- LU'; if(stVals.length>5){
      const sorted=[...stVals].sort((a,b)=>a-b);
      const p95=sorted[Math.floor(sorted.length*0.95)]; const p10=sorted[Math.floor(sorted.length*0.10)];
      LRA = (p95-p10).toFixed(1).padStart(4) + ' LU';
    }
    const now=performance.now(); if(now-lastText>100){
      const a=.35;
      const prevM=parseFloat(lufsM.dataset.v||'-999'); const prevS=parseFloat(lufsS.dataset.v||'-999'); const prevI=parseFloat(lufsI.dataset.v||'-999');
      const mDisp=isFinite(prevM)? prevM + a*(mLUFS-prevM): mLUFS; const sDisp=isFinite(prevS)? prevS + a*(sLUFS-prevS): sLUFS; const iDisp=isFinite(prevI)? prevI + a*(iLUFS-prevI): iLUFS;
      lufsM.dataset.v=mDisp; lufsS.dataset.v=sDisp; lufsI.dataset.v=iDisp;
      // Momentary
      lufsM.textContent = formatLufs(mDisp);
      lufsM.style.color = loudnessColor(mDisp);
      // Short-term
      lufsS.textContent = formatLufs(sDisp);
      lufsS.style.color = loudnessColor(sDisp);
      // Integrated med offset från target
      if (isFinite(iDisp)) {
        const offsetLU = iDisp - LOUDNESS_TARGET;
        const offsetStr = formatDbSigned(offsetLU, 1, 5);
        lufsI.innerHTML = `${formatLufs(iDisp)} <span style="opacity:0.7;font-size:0.85em">(${offsetStr})</span>`;
        lufsI.style.color = loudnessColor(iDisp);
      } else {
        lufsI.textContent = '--.- LUFS';
        lufsI.style.color = '';
      }
      lraEl.textContent = LRA; lastText=now;

      // --- TPmax: spåra max true peak sedan reset ---
      const currentTpMax = Math.max(tpPeakHoldL, tpPeakHoldR);
      if (currentTpMax > r128TpMax) r128TpMax = currentTpMax;
      if (isFinite(r128TpMax) && r128TpMax > -60) {
        r128TpMaxEl.textContent = formatDb(r128TpMax, 1, 5) + ' dBTP';
        r128TpMaxEl.style.color = r128TpMax >= -1.0 ? getCss('--hot') : getCss('--ok');
      } else {
        r128TpMaxEl.textContent = '--.- dBTP';
        r128TpMaxEl.style.color = '';
      }

      // --- Elapsed time ---
      const elapsed = now - r128StartTime;
      r128TimeEl.textContent = formatTime(elapsed);

      // --- Update radar buffer with short-term loudness ---
      pushRadarLoudness(sDisp);
    }
  }

  // ------- Capture -------
  let sysStream=null, sysSrc=null, sysSplit=null, sysMonGain=null, sysMonitorMuted=true, sysTrimNode=null; let sysTrimDb = 0;
  function setSysTrim(dB){ sysTrimDb = clamp(parseFloat(dB)||0, -48, 24); sysTrimRange.value=sysTrimDb; sysTrimInput.value=sysTrimDb.toFixed(1); sysTrimOut.textContent = sysTrimDb.toFixed(1)+' dB'; if(sysTrimNode){ sysTrimNode.gain.value = dbToGain(sysTrimDb); } }
  setSysTrim(0); sysTrimRange.addEventListener('input', e=> setSysTrim(e.target.value)); sysTrimInput.addEventListener('change', e=> setSysTrim(e.target.value)); sysTrimInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ setSysTrim(e.target.value); e.target.blur(); }}); sysTrimReset.addEventListener('click', ()=> setSysTrim(0));

  async function startTabCapture(){
    try{
      await ac.resume();
      sysStream = await navigator.mediaDevices.getDisplayMedia({audio:{echoCancellation:false,noiseSuppression:false,autoGainControl:false,channelCount:2}, video:true});
      sysStream.getVideoTracks().forEach(t=>t.stop());
      const track = sysStream.getAudioTracks()[0]; if(!track) throw new Error('No audio track available.');
      try{ track.applyConstraints({advanced:[{channelCount:2}]}); }catch{}
      track.contentHint='music';
      sysSrc = ac.createMediaStreamSource(sysStream);
      sysTrimNode = ac.createGain(); sysTrimNode.gain.value = dbToGain(sysTrimDb);
      sysSrc.connect(sysTrimNode);
      sysSplit = connectStereoToMix(sysTrimNode);
      sysMonGain = ac.createGain(); sysMonGain.gain.value = 0; // muted by default
      sysTrimNode.connect(sysMonGain).connect(ac.destination);
      btnSysMonMute.classList.remove('btn-active'); btnSysMonMute.classList.add('btn-ghost'); btnSysMonMute.textContent='Unmute system monitor'; sysMonState.textContent='(muted)'; sysMonitorMuted=true;
      const set = track.getSettings?track.getSettings():{};
      info.srcKind.textContent=track.kind||'audio'; info.cc.textContent=set.channelCount??'unknown'; info.sr.textContent=ac.sampleRate+' Hz'; info.stOK.textContent=(set.channelCount>=2?'Yes':'Uncertain/Mono?');
      btnTab.disabled=true; btnStop.disabled=false; dbgTab.textContent='yes';
    }catch(e){ alert(e.message||e) }
  }
  function stopCapture(){
    try{ sysStream && sysStream.getTracks().forEach(t=>t.stop()) }catch{}
    try{ sysSrc && sysSrc.disconnect() }catch{} try{ sysTrimNode && sysTrimNode.disconnect() }catch{} try{ sysSplit && sysSplit.disconnect() }catch{} try{ sysMonGain && sysMonGain.disconnect() }catch{}
    sysStream=null; sysSrc=null; sysTrimNode=null; sysSplit=null; sysMonGain=null; sysMonitorMuted=true; btnSysMonMute.textContent='Unmute system monitor'; sysMonState.textContent='(muted)'; btnSysMonMute.classList.remove('btn-active'); btnSysMonMute.classList.add('btn-ghost'); btnTab.disabled=false; btnStop.disabled=true; dbgTab.textContent='no';
  }
  function toggleSysMonitorMute(){
    if(!sysMonGain) return;
    sysMonitorMuted = !sysMonitorMuted; sysMonGain.gain.value = sysMonitorMuted ? 0 : parseFloat(sysMonGainEl.value);
    sysMonVal.textContent = sysMonGainEl.value;
    if (sysMonitorMuted){ btnSysMonMute.classList.remove('btn-active'); btnSysMonMute.classList.add('btn-ghost'); btnSysMonMute.textContent='Unmute system monitor'; sysMonState.textContent='(muted)'; }
    else { btnSysMonMute.classList.add('btn-active'); btnSysMonMute.classList.remove('btn-ghost'); btnSysMonMute.textContent='Mute system monitor'; sysMonState.textContent='(on)'; }
    
    // Update monitor status display
    const monitorStatus = document.getElementById('monitorStatus');
    const genStatus = monitorMuted ? '<b>OFF</b>' : '<b>ON</b>' + (!monitorMuted ? ' (default)' : '');
    const sysStatus = sysMonitorMuted ? '<b>OFF</b>' + (sysMonitorMuted ? ' (default)' : '') : '<b>ON</b>';
    monitorStatus.innerHTML = `System monitor: ${sysStatus}<br>Generator monitor: ${genStatus}`;
  }
  sysMonGainEl.addEventListener('input', ()=>{ sysMonVal.textContent=sysMonGainEl.value; if(sysMonGain && !sysMonitorMuted){ sysMonGain.gain.value=parseFloat(sysMonGainEl.value) } });

  // ------- Generator -------
  // Broadcast-alignment: −18 dBFS betyder PEAK/quasi-peak nivå (EBU R68)
  // För sinus: Amplitude = 10^(-18/20) ≈ 0.126 → Peak = -18 dBFS
  // RMS blir då -21 dBFS (3 dB lägre pga crest factor √2)
  const SINE_A_FOR_MINUS18_PEAK = Math.pow(10, -18/20); // ≈ 0.126
  let genOsc=null, genGain=null, leftGain=null, rightGain=null, merger=null, genMonGain=null; let monitorMuted=false;

  // Generator presets (frekvens → badge-text)
  const genPresets = {
    '400':  '400 Hz · −18 dBFS peak (0 dBu / 0 PPM · EBU alignment)',
    '1000': '1 kHz · −18 dBFS peak (digital test tone · AES-style)',
    '997':  '997 Hz · −18 dBFS peak (FFT-optimised test tone)',
    '440':  '440 Hz · −18 dBFS peak (musical A · non-broadcast)'
  };
  const genPresetEl = document.getElementById('genPreset');
  const genBadgeEl = document.getElementById('genBadge');
  let currentGenFreq = 400; // Standard: 400 Hz (EBU broadcast line-up)

  // Uppdatera badge och frekvens vid preset-ändring
  genPresetEl.addEventListener('change', () => {
    const freq = parseInt(genPresetEl.value);
    currentGenFreq = freq;
    genBadgeEl.textContent = genPresets[freq] || genPresets['400'];
    // Om generatorn redan kör, uppdatera frekvensen live
    if (genOsc) {
      genOsc.frequency.value = freq;
    }
  });

  async function startGenerator(){
    await ac.resume();
    if(genOsc) return;

    genOsc = ac.createOscillator(); genOsc.type='sine'; genOsc.frequency.value=currentGenFreq;
    genGain = ac.createGain(); genGain.gain.value=SINE_A_FOR_MINUS18_PEAK; // Peak vid -18 dBFS (0 dBu)
    leftGain = ac.createGain(); rightGain = ac.createGain(); leftGain.gain.value=1; rightGain.gain.value=1;
    merger = ac.createChannelMerger(2);
    genOsc.connect(genGain); genGain.connect(leftGain); genGain.connect(rightGain);
    leftGain.connect(merger,0,0); rightGain.connect(merger,0,1);

    genMonGain = ac.createGain(); genMonGain.gain.value = 0; // monitor muted default
    merger.connect(genMonGain).connect(ac.destination);

    const genSplit = ac.createChannelSplitter(2);
    merger.connect(genSplit);
    genSplit.connect(mixL,0); genSplit.connect(mixR,1);
    genSplit.connect(kHP_L,0); genSplit.connect(kHP_R,1);

    genOsc.start();
    btnTone.textContent='Stop tone'; dbgGen.textContent='yes';
    btnMonMute.classList.add('btn-active'); btnMonMute.classList.remove('btn-ghost'); btnMonMute.textContent='Mute generator monitor'; monState.textContent='(on)'; monitorMuted = false;
  }
  async function stopGenerator(){
    try{ genOsc && genOsc.stop() }catch{}
    [genGain,leftGain,rightGain,merger,genMonGain].forEach(n=>{ try{ n && n.disconnect && n.disconnect() }catch{} });
    genOsc=null; genGain=null; leftGain=null; rightGain=null; merger=null; genMonGain=null; btnTone.textContent='Start/Stop tone'; dbgGen.textContent='no';
  }
  function toggleGenMonitorMute(){
    if(!genMonGain) return;
    monitorMuted = !monitorMuted; genMonGain.gain.value = monitorMuted ? 0 : parseFloat(monGainEl.value);
    monVal.textContent = monGainEl.value;
    if (monitorMuted){ btnMonMute.classList.remove('btn-active'); btnMonMute.classList.add('btn-ghost'); btnMonMute.textContent='Unmute generator monitor'; monState.textContent='(muted)'; }
    else { btnMonMute.classList.add('btn-active'); btnMonMute.classList.remove('btn-ghost'); btnMonMute.textContent='Mute generator monitor'; monState.textContent='(on)'; }
    
    // Update monitor status display
    const monitorStatus = document.getElementById('monitorStatus');
    const genStatus = monitorMuted ? '<b>OFF</b>' : '<b>ON</b>' + (!monitorMuted ? ' (default)' : '');
    const sysStatus = sysMonitorMuted ? '<b>OFF</b>' + (sysMonitorMuted ? ' (default)' : '') : '<b>ON</b>';
    monitorStatus.innerHTML = `System monitor: ${sysStatus}<br>Generator monitor: ${genStatus}`;
  }
  monGainEl.addEventListener('input', ()=>{ monVal.textContent=monGainEl.value; if(genMonGain && !monitorMuted){ genMonGain.gain.value=parseFloat(monGainEl.value) } });

  // ------- Sidebar Collapse System -------
  const SIDEBAR_STATE_KEY = 'tsg-sidebar-collapsed';

  function initSidebarToggle() {
    const sidebarToggle = document.getElementById('sidebarToggle');
    const wrap = document.getElementById('wrap');
    const metersSection = document.querySelector('.visning');
    const html = document.documentElement;

    // Kolla initial state (satt av inline script i <head>)
    let isCollapsed = html.classList.contains('sidebar-start-collapsed');

    // Synka wrap class med initial state
    if (isCollapsed) {
      wrap.classList.add('sidebar-collapsed');
    }

    // Aktivera transitions EFTER första renderingen (förhindrar flash)
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        html.classList.add('sidebar-ready');
        // Ta bort initial-klassen nu när wrap har rätt class
        html.classList.remove('sidebar-start-collapsed');
      });
    });

    // Function to update toggle button vertical position (center to meters panel)
    function updateToggleVerticalPosition() {
      if (metersSection) {
        const metersRect = metersSection.getBoundingClientRect();
        const centerY = metersRect.top + (metersRect.height / 2);
        sidebarToggle.style.top = centerY + 'px';
      }
    }

    // Update vertical position on load and resize
    updateToggleVerticalPosition();
    window.addEventListener('resize', updateToggleVerticalPosition);

    sidebarToggle.addEventListener('click', () => {
      isCollapsed = !isCollapsed;

      // Spara state till localStorage
      localStorage.setItem(SIDEBAR_STATE_KEY, isCollapsed);

      if (isCollapsed) {
        wrap.classList.add('sidebar-collapsed');
      } else {
        wrap.classList.remove('sidebar-collapsed');
      }

      // Update toggle vertical position after animation and trigger layout recalculation
      setTimeout(() => {
        updateToggleVerticalPosition();
        // **BEST PRACTICE 2025: Use scheduled layout update instead of direct call**
        scheduleLayoutUpdate(xyCard, layoutXY);
        // Trigger resize event for any other responsive elements
        window.dispatchEvent(new Event('resize'));
      }, 400);
    });
    
    // Keyboard shortcut: Ctrl/Cmd + B to toggle sidebar
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
        e.preventDefault();
        sidebarToggle.click();
      }
    });
  }

  // ------- Drag & Drop System -------
  let draggedElement = null;
  let dragOffset = { x: 0, y: 0 };
  let isDragging = false;
  
  // **BEST PRACTICE 2025: Drag-Aware Layout Management**
  // Prevents layout thrashing during drag operations by freezing expensive calculations
  let isDragLayoutFrozen = false;
  
  // **BEST PRACTICE 2025: Debounced ResizeObserver Pattern**
  // Prevents cascade resize events and ensures smooth performance during layout changes
  const resizeDebouncer = new Map();
  
  /**
   * Schedules layout updates using requestAnimationFrame to prevent blocking the main thread
   * @param {Element} element - The element being observed for resize
   * @param {Function} callback - The layout function to execute
   */
  function scheduleLayoutUpdate(element, callback) {
    // Cancel any pending layout update for this element
    if (resizeDebouncer.has(element)) {
      cancelAnimationFrame(resizeDebouncer.get(element));
    }
    
    // Schedule new update on next available frame
    const rafId = requestAnimationFrame(() => {
      try {
        resizeDebouncer.delete(element);
        
        // **BEST PRACTICE 2025: Performance monitoring for layout operations**
        const startTime = performance.now();
        callback();
        const endTime = performance.now();
        
        // Log performance warnings for slow layout operations (>16ms = missing 60fps)
        if (endTime - startTime > 16) {
          console.warn(`Layout operation took ${(endTime - startTime).toFixed(2)}ms - may affect 60fps performance`);
        }
        
      } catch (error) {
        console.error('Layout update failed:', error);
        // Remove failed element from debouncer to prevent stuck states
        resizeDebouncer.delete(element);
      }
    });
    
    resizeDebouncer.set(element, rafId);
  }
  
  /**
   * Canvas State Preservation Pattern for Vectorscope
   * Prevents visual "zoom-in" effects during drag operations by preserving canvas content
   */
  function preserveCanvasState() {
    // Skip if canvas isn't properly initialised
    if (!xy || !xy.width || !xy.height || !xyCtx) {
      console.debug('Canvas preservation skipped - canvas not ready');
      return () => {};
    }
    
    try {
      const canvasState = {
        width: xy.width,
        height: xy.height,
        imageData: xyCtx.getImageData(0, 0, xy.width, xy.height)
      };
      
      // **BEST PRACTICE 2025: Memory-conscious canvas handling**
      // Return restoration function with cleanup capabilities
      return () => {
        try {
          if (xy.width === canvasState.width && xy.height === canvasState.height) {
            xyCtx.putImageData(canvasState.imageData, 0, 0);
          } else {
            console.debug('Canvas dimensions changed, skipping restoration');
          }
        } catch (error) {
          console.warn('Canvas restoration failed:', error);
        }
      };
      
    } catch (error) {
      console.warn('Canvas state preservation failed:', error);
      return () => {};
    }
  }

  function initDragAndDrop() {
    const meterPanels = document.querySelectorAll('.meter');
    
    meterPanels.forEach(panel => {
      // Mouse events
      panel.addEventListener('mousedown', handleDragStart);
      panel.addEventListener('dragover', handleDragOver);
      panel.addEventListener('drop', handleDrop);
      
      // Touch events for mobile
      panel.addEventListener('touchstart', handleTouchStart);
      
      // Make draggable
      panel.draggable = true;
      panel.addEventListener('dragstart', handleDragStartNative);
    });

    // Global events
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('touchmove', handleTouchMove);
    document.addEventListener('touchend', handleTouchEnd);
  }

  function handleDragStart(e) {
    // **FIX: Only start drag on actual mouse movement, not on click**
    // Store mouse position but don't activate visual drag state yet
    const rect = e.currentTarget.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    // Store potential drag element but don't activate drag state
    draggedElement = e.currentTarget;
    
    // Don't add dragging class or freeze layout until actual movement occurs
    // This prevents static blue highlighting on simple clicks
  }

  function handleDragStartNative(e) {
    // **FIX: Clear any previous dragging states (only one panel at a time)**
    document.querySelectorAll('.meter.dragging').forEach(el => {
      el.classList.remove('dragging');
    });
    
    draggedElement = e.currentTarget;
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', e.currentTarget.outerHTML);
    
    // **BEST PRACTICE 2025: Preserve vectorscope canvas state before potential layout changes**
    const restoreCanvas = preserveCanvasState();
    
    // **BEST PRACTICE 2025: Freeze layout system to prevent visual glitches**
    isDragLayoutFrozen = true;
    
    // **FIX: Immediately activate drag state for native drag-and-drop**
    // Native drag-and-drop needs immediate visual feedback
    isDragging = true;
    
    // Delay to allow visual state to update
    setTimeout(() => {
      if (draggedElement) {
        draggedElement.classList.add('dragging');
        // Restore canvas if it was affected by the visual state change
        restoreCanvas();
      }
    }, 0);
  }

  function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    // Remove drag-over from all elements first
    document.querySelectorAll('.meter').forEach(el => {
      el.classList.remove('drag-over');
    });
    
    // Only add to current target if it's valid
    if (e.currentTarget !== draggedElement && e.currentTarget.classList.contains('meter')) {
      e.currentTarget.classList.add('drag-over');
    }
  }

  function handleDrop(e) {
    e.preventDefault();
    
    const dropTarget = e.currentTarget;
    dropTarget.classList.remove('drag-over');
    
    if (draggedElement && dropTarget !== draggedElement && dropTarget.classList.contains('meter')) {
      // Swap positions
      swapElements(draggedElement, dropTarget);
    }
    
    // **BEST PRACTICE 2025: Restore layout system after drag operation**
    isDragLayoutFrozen = false;
    
    // **FIX: Properly clean up all drag state**
    if (draggedElement) {
      draggedElement.classList.remove('dragging');
      draggedElement = null;
    }
    
    // Reset drag state
    isDragging = false;
    
    // Remove drag-over from all elements
    document.querySelectorAll('.meter').forEach(el => {
      el.classList.remove('drag-over');
    });
    
    // **BEST PRACTICE 2025: Schedule vectorscope layout update after drag completion**
    scheduleLayoutUpdate(xyCard, layoutXY);
  }

  function handleTouchStart(e) {
    const touch = e.touches[0];
    const rect = e.currentTarget.getBoundingClientRect();
    dragOffset.x = touch.clientX - rect.left;
    dragOffset.y = touch.clientY - rect.top;
    
    draggedElement = e.currentTarget;
    draggedElement.classList.add('dragging');
    isDragging = true;
    
    // **BEST PRACTICE 2025: Freeze layout during touch drag operations**
    isDragLayoutFrozen = true;
    
    e.preventDefault();
  }

  function handleDragMove(e) {
    // **FIX: Only activate drag state when actual movement occurs**
    if (!draggedElement) return;
    
    // Calculate movement distance from initial mouse position
    const rect = draggedElement.getBoundingClientRect();
    const currentX = e.clientX;
    const currentY = e.clientY;
    const initialX = rect.left + dragOffset.x;
    const initialY = rect.top + dragOffset.y;
    
    const distance = Math.sqrt(
      Math.pow(currentX - initialX, 2) + Math.pow(currentY - initialY, 2)
    );
    
    // Only activate drag state if mouse moved more than 5 pixels
    // This prevents accidental drag activation on clicks
    if (distance > 5 && !isDragging) {
      isDragging = true;
      isDragLayoutFrozen = true;
      
      // Clear any other dragging panels (only one at a time)
      document.querySelectorAll('.meter.dragging').forEach(el => {
        if (el !== draggedElement) {
          el.classList.remove('dragging');
        }
      });
      
      // Now activate visual drag state
      draggedElement.classList.add('dragging');
    }
  }

  function handleTouchMove(e) {
    if (!isDragging || !draggedElement) return;
    
    const touch = e.touches[0];
    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
    
    // Remove previous drag-over
    document.querySelectorAll('.meter').forEach(el => {
      el.classList.remove('drag-over');
    });
    
    // Add drag-over to current target
    if (elementUnderTouch && elementUnderTouch.classList.contains('meter') && elementUnderTouch !== draggedElement) {
      elementUnderTouch.classList.add('drag-over');
    }
    
    e.preventDefault();
  }

  function handleDragEnd(e) {
    // **FIX: Clean up drag state properly**
    if (draggedElement) {
      draggedElement.classList.remove('dragging');
    }
    
    // Reset all drag state variables
    draggedElement = null;
    isDragging = false;
    
    // **BEST PRACTICE 2025: Restore layout system after mouse drag**
    isDragLayoutFrozen = false;
    scheduleLayoutUpdate(xyCard, layoutXY);
  }

  function handleTouchEnd(e) {
    if (!isDragging || !draggedElement) return;
    
    const touch = e.changedTouches[0];
    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
    
    if (elementUnderTouch && elementUnderTouch.classList.contains('meter') && elementUnderTouch !== draggedElement) {
      swapElements(draggedElement, elementUnderTouch);
    }
    
    // Clean up
    draggedElement.classList.remove('dragging');
    document.querySelectorAll('.meter').forEach(el => {
      el.classList.remove('drag-over');
    });
    
    draggedElement = null;
    isDragging = false;
    
    // **BEST PRACTICE 2025: Restore layout system after touch drag**
    isDragLayoutFrozen = false;
    scheduleLayoutUpdate(xyCard, layoutXY);
  }

  function swapElements(el1, el2) {
    // Add transition class for smooth animation
    el1.classList.add('transitioning');
    el2.classList.add('transitioning');
    
    // Create temporary placeholder
    const temp = document.createElement('div');
    temp.style.display = 'none';
    
    // Insert temp before el1
    el1.parentNode.insertBefore(temp, el1);
    
    // Move el1 to where el2 is
    el2.parentNode.insertBefore(el1, el2);
    
    // Move el2 to where el1 was (temp position)
    temp.parentNode.insertBefore(el2, temp);
    
    // Remove temp
    temp.remove();
    
    // Remove transition class after animation
    setTimeout(() => {
      el1.classList.remove('transitioning');
      el2.classList.remove('transitioning');
    }, 400);
  }

  // ------- Loop -------
  let startTs=performance.now(); let leftMuteTimer=0;
  function loop(){
    // EBU Stereo-ID (ITU-R BR.1385 / EBU R49):
    // Standard broadcast line-up tone med stereo-identifikation:
    // - Höger kanal: kontinuerlig ton
    // - Vänster kanal: 250 ms avbrott ("pulse") var 3:e sekund
    // Källa: EBU R49, ITU-R BR.1385, Grass Valley 12G test pattern spec
    if (muteLeft.checked && leftGain){
      leftMuteTimer += 16.7;
      const EBU_PERIOD_MS = 3000;  // 3 sekunder mellan pulser
      const EBU_MUTE_MS = 250;     // 250 ms mute/avbrott på vänster
      const on = (leftMuteTimer % EBU_PERIOD_MS) >= EBU_MUTE_MS;
      const target = on ? 1 : 0;
      if (leftGain.gain.value !== target){ leftGain.gain.setValueAtTime(target, ac.currentTime) }
    }
    layoutXY(); updatePPM(); drawXY(); drawCorr(); drawMonoDev(); drawDBFS(); drawTruePeak(); updateR128();
    // Pass momentary LUFS to radar for live value
    let mVal = parseFloat(lufsM && lufsM.dataset.v);
    drawLoudnessRadar(isFinite(mVal) ? mVal : undefined);
    uptimeEl.textContent = ((performance.now()-startTs)/1000).toFixed(1);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  
  // **BEST PRACTICE 2025: Modern ResizeObserver Implementation**
  // Replaces multiple observers with debounced, scheduled updates to prevent cascade resize events
  
  /**
   * Intersection Observer for Visibility-Based Updates
   * Only triggers layout updates when vectorscope is actually visible to user
   */
  const visibilityObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting && !isDragLayoutFrozen) {
        scheduleLayoutUpdate(entry.target, layoutXY);
      }
    });
  }, {
    // Trigger when at least 10% of the element is visible
    threshold: 0.1
  });
  
  /**
   * Modern ResizeObserver with Debouncing
   * Prevents layout thrashing by using scheduled updates
   */
  const modernResizeObserver = new ResizeObserver((entries) => {
    entries.forEach(entry => {
      // Only process if not currently dragging
      if (!isDragLayoutFrozen) {
        scheduleLayoutUpdate(entry.target, layoutXY);
      }
    });
  });
  
  // Observe key elements with modern pattern
  modernResizeObserver.observe(meters);
  modernResizeObserver.observe(xyCard);
  visibilityObserver.observe(xyCard);

  // ------- Bind -------
  btnTab.onclick  = startTabCapture; btnStop.onclick = stopCapture; btnTone.onclick = async()=>{ if(!genOsc) await startGenerator(); else await stopGenerator(); };
  btnMonMute.onclick = toggleGenMonitorMute; btnSysMonMute.onclick = toggleSysMonitorMute;

  // ------- Boot: ingen auto-ton, allt muted default -------
  let booted=false; async function boot(){ if(booted) return; booted=true; await ac.resume(); }
  ['pointerdown','click','keydown','touchstart'].forEach(evt=>window.addEventListener(evt, boot, { once:true, passive:true }));
  
  // Initialize systems
  initSidebarToggle();
  initDragAndDrop();
  
  // **BEST PRACTICE 2025: Cleanup Functions for Memory Management**
  // Proper cleanup prevents memory leaks in long-running applications
  
  /**
   * Cleanup function for when the application is unloaded
   * Cancels all pending animations and disconnects observers
   */
  function cleanup() {
    // Cancel all pending layout updates
    resizeDebouncer.forEach((rafId) => {
      cancelAnimationFrame(rafId);
    });
    resizeDebouncer.clear();
    
    // Disconnect observers
    if (modernResizeObserver) {
      modernResizeObserver.disconnect();
    }
    if (visibilityObserver) {
      visibilityObserver.disconnect();
    }
    
    console.debug('TSG Audio Meters: Cleanup completed');
  }
  
  // Register cleanup for page unload
  window.addEventListener('beforeunload', cleanup);
  
  // **DEVELOPMENT MODE: Performance monitoring and debugging**
  if (typeof window !== 'undefined' && window.location?.hostname === 'localhost') {
    // Enable performance monitoring in development
    console.log('TSG Audio Meters: Development mode active');
    console.log('- Drag-aware layout system: ✓');
    console.log('- Modern ResizeObserver pattern: ✓');
    console.log('- CSS Container Queries: ✓');
    console.log('- Canvas state preservation: ✓');
    console.log('- Memory cleanup handlers: ✓');
  }
})();
</script>
</body>
</html>          